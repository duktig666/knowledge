# JVM面试题

## 1. JVM的内存结构

### 运行时数据区

![运行时数据区内存结构图](https://gitee.com/koala010/typora/raw/master/img/20210621153304.png)

线程共享方法区和堆，独占虚拟机栈、本地方法栈和程序计数器。

#### 程序计数器

程序计数器是一块较小的内存空间，可以看做当前线程执行的字节码的行号指示器。

**作用：**

1. **字节码解释器通过改变程序计数器来依次读取指令，从而实现流程控制**。如：顺序选择、选择、循环、异常处理。
2. **在多线程的情况下，程序计数器记录当前线程的执行位置，以便线程切换回来可以得知上次的执行位置**。（问题：线程为什么独占程序计数器的答案）

**注意：**

- **程序计数器是唯一一个在《Java虚拟机规范》中没有规定任何`OutOfMemoryError`情况的区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**
- 如果正在执行的是**本地（Native）方法**，这个**计数器值则应为空（`Undefined`）**。

#### 虚拟机栈

生命周期与线程相同。

虚拟机栈存储“栈帧”，每个方法会创建一个栈帧，**栈帧中存放局部变量表、操作数栈、动态链接、方法出口等信息**。

**局部变量表**：

- 局部变量表存放了编译期中各种的基本数据类型和对象引用。（栈内存一般指局部变量表）
  - 64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个
  - 局部变量表所需内存编译期完成分配，进入一个方法后，栈分配多少内存是固定的，运行期间不会改变。

方法调用就是栈帧的入栈和出栈操作。

OOM

《Java虚拟机规范》规定，

1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。

但是HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现
OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。

#### 本地方法栈

- 和虚拟机栈类似，两者的区别就是**虚拟机栈是为虚拟机执行java方法服务**，**本地方法栈为虚拟机执行native方法服务**。

- **HotSpot虚拟机不区分虚拟机栈和本地方法栈**（合二为一）。

#### 堆

- Java 虚拟机所管理的内存中最大的一块，Java 堆是**所有线程共享的一块内存区域**，在虚拟机启动时创建。

- **此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

- 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”

- JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
- 可通过参数 -Xmx -Xms 来指定运行时堆内存的大小，堆内存空间不足也会抛OutOfMemoryError异常。

#### 方法区

- 方法区也是线程共享区，用于存储【虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码等数据】

**方法区和永久代的关系**：

> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

##### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。

#### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 2. 堆中的Eden和Survivor比例问题

Eden区是一块，Survivor区是两块。

Eden区和Survivor区的比例是8：1：1。

参考：[新生代Eden与两个Survivor区的解释](https://blog.csdn.net/lojze_ly/article/details/49456255)



## 3. JVM的垃圾回收机制

**为什么需要了解垃圾回收机制**？

当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。

**哪些区域需要垃圾回收**？

程序计数器、虚拟机栈和本地方法栈同线程生命周期一致，方法/线程技结束，内存直接回收，无需过多考虑。

堆和方法区有着不确定性：一个接口多个实现类所需内存不一样，一个方法不同的条件和分支所需内存也可能不一样。只有在运行期间才知道程序会创建哪些对象、多少个对象。这部分内存分配和回收是动态，所以需要关注内存的分配与回收。

### 3.1 垃圾判断算法（如何判断对象需要被回收？）

#### 引用计数算法

> 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**

#### 可达性分析算法

> 通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![image-20210622161600979](https://gitee.com/koala010/typora/raw/master/img/ 可达性分析算法20210622161601.png)

**可作为 GC Roots 的对象**：

- **在虚拟机栈（栈帧中的本地变量表）中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- **在方法区中类静态属性引用的对象**，譬如Java类的引用类型静态变量。
- **在方法区中常量引用的对象**，譬如字符串常量池（String Table）里的引用。
- **在本地方法栈中JNI（即通常所说的Native方法）引用的对象**。
- **Java虚拟机内部的引用**，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- **所有被同步锁（synchronized关键字）持有的对象**。
- **反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等**。



**利用可达性分析算法，如何判断一个对象死亡**？

两次标记阶段。

第一次标记：对象没有与`GC Roots`相连时，判断该对象的`finalize`方法有没有被覆盖过，或者有没有被虚拟机执行过。如果没有，则直接被回收；如果执行过，对象被放置进`F-Queue`队列中，进行第二次标记。

第二次标记：如果对象在`finalize`关联上了`GC Roots`，在队列中移除（只能关联一次）；如果没有，被回收。

### 3.2 引用

JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）。

![Java四种引用的结构](https://gitee.com/koala010/typora/raw/master/img/Java四种引用的结构20210622164831.png)

**1、强引用**

强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似`Objectobj=new Object()`这种引用关系。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**2、软引用**

描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类`SoftReference`表示软引用。

**3、弱引用**

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类`WeakReference`表示弱引用。

**4、虚引用**

这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

关于应用的使用案例参考：[Java的四种引用详解与使用案例](https://blog.csdn.net/TJtulong/article/details/104879688)

提到Java引用及垃圾回收机制，当我联想到了以前的一个说法，**在链表删除一个节点的时候，将这个节点置为null，以方便下次垃圾回收机制删除**，这个操作是否有意义？

通常情况下没有什么意义，除非在特定的一些情况下：

1 同一个方法中
2 定义了一个大对象(小对象没有意义)
3 之后跟着一个非常耗时的操作.
4 没有满足JIT编译条件

 上面4个条件缺一不可,把obj显式设置成null才是有意义的。

参考：

- [在Java中将对象分配为null会影响垃圾回收吗？](https://www.itranslater.com/qa/details/2126692746223158272)
- [java中将对象赋值为null，对垃圾回收有用吗？](https://blog.csdn.net/qq_42945742/article/details/84107531)

### 3.3 垃圾回收算法

#### 分代收集理论

建立在两个分代假说之上：

1）**弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的**。

2）**强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡**。

收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

因为对象之间会存在跨代引用，进行一次Minor GC，但新生代对象可能被老年代引用，不得不在GC Roots之外再遍历老年代确保可达性分析的正确性，反之一样。可能会给内存回收带来很大的性能负担。

**跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数**。隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

需在新生代上建立一个全局的数据结构，把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用，可以缩小扫描范围。

#### 标记-清除算法（Mark-Sweep）

**标记需回收/存活对象，统一清除标记的对象**。

<img src="https://gitee.com/koala010/typora/raw/master/img/标记-清除算法20210622174750.png" alt="image-20210622174750725" style="zoom:67%;" />

**缺点**：

- **执行效率不稳定**。对象越多，效率越低。
- **内存空间的碎片化问题**。

#### 标记-复制算法（Mark-Copying）

**“半区复制”，每次只用一块内存，存活对象复制到另一块，已经使用的那一块直接清除**。

<img src="https://gitee.com/koala010/typora/raw/master/img/标记-复制算法20210622175418.png" alt="image-20210622175417983" style="zoom:67%;" />

优点：无内存碎片化问题。

缺点：对象存活率高时，大量复制，效率低。

#### 标记-整理算法（Mark-Compact）

标记存活对象，让所有存活对象移动到一端，然后清理所有的边界以外的内存。

<img src="https://gitee.com/koala010/typora/raw/master/img/ 标记-整理算法（Mark-Compact）.png" alt="image-20210622180525483" style="zoom:67%;" />

**是否移动对象都有弊端，移动内存回收比较复杂，不移动内存分配比较复杂（空间碎片化）**。

一种方案：**虚拟机平时采用标记-清除算法，暂时容忍碎片存在，直到碎片影响大到内存分配时，在进行标记-整理算法，可获得规整的内存空间**。

关于**标记-整理算法的可回收对象与存活对象如何移动？**，可参考：[垃圾回收算法——标记—整理回收](https://blog.csdn.net/luliuliu1234/article/details/104058259) （了解）

### 3.4 垃圾收集器

![垃圾收集器总结](https://gitee.com/koala010/typora/raw/master/img/垃圾收集器总结.png)

详细内容参考JavaGuide：[垃圾收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM垃圾回收?id=_4-垃圾收集器)

### 3.5内存分配与回收策略（垃圾回收过程）

- **对象优先在Eden分配**。大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
- **大对象直接进入老年代**。大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。
- **长期存活的对象将进入老年代**。
  - HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中（详见第2章）。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象
    年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX：MaxTenuringThreshold`设置。
- **动态对象年龄判定**。
  - 为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到`-XX：MaxTenuringThreshold`才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到`-XX：MaxTenuringThreshold`中要求的年龄。
- **空间分配担保**。
  - 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

（参考：深入理解Java虚拟机第三版的3.8节）



关于垃圾收集机制的详细内容可参考：[JVM垃圾回收机制](https://www.cnblogs.com/hexinwei1/p/9525737.html)

