# 网络常见面试题

## 1. HTTP状态码

关于HTTP状态码参看：[HTTP状态码（百度百科）](https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin)    [HTTP状态码（菜鸟教程）](https://www.runoob.com/http/http-status-codes.html)



## 2. https

### 2.1 https加密过程

1. 服务器的**公钥**和**身份信息**（原始信息）用一个**hash算法**生成一个**消息摘要**。
2. 使用CA机构的私钥将消息摘要加密生成**数字签名**。
3. 将原始信息和数字签名合并，形成**数字证书**，发送至客户端。
4. 客户端将原始信息用同样的hash算法再次生成消息摘要。
5. 客户端用CA机构的公钥将数字签名解密，得到CA的消息摘要。
6. 客户端将**原始信息hash后的消息摘要**与**CA解密后的消息摘要**进行对比，如果相同证明无问题。
7. 随后进行非对称+对称加密解密通信（参看下文https通信流程）

![https加密流程](https://gitee.com/koala010/typora/raw/master/img/20210624091448.png)



![https客户端解密](https://gitee.com/koala010/typora/raw/master/img/20210624091518.png)

### 2.2 https通信流程

1. 客户端发送请求。
2. 服务器发送数字证书（包含公钥）
3. 客户端用预置的CA列表验证证书（有问题，提示风险）
4. 浏览器随机生成对称密钥，并使用服务器的公钥加密
5. 服务器使用私钥进行解密，得到对称密钥
6. 双方使用对称加密进行通信

![https流程](https://gitee.com/koala010/typora/raw/master/img/20210624091840.png)



参考：

- [彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231) (演变过程和每个步骤的漏洞及解决方案讲的比较清楚)
- [谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)     [一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)  （以故事的方式讲解，更加容易理解）

## 3. TCP三次握手、四次挥手

参看：[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

### 3.1 三次握手过程

> 三次握手（Three-way Handshake）是建立TCP连接时，客户端和服务端总共发送3个包，确认双方的接受能力和发送能力是否正常，指定初始化序列号，为后面的可靠传输做准备。实质是连接服务器指定端口，建立TCP连接，同步双方的序列号和确认号，交换TCP的窗口大小信息。

![三次握手过程](https://gitee.com/koala010/typora/raw/master/img/三次握手过程20210624165041.png)

名词解释：

**SYN**：同步序列编号，是TCP/IP建立连接时使用的握手信号。表示建立连接。

**seq**：TCP报文段中第一个字节的数据编号，由本地随机生成。

**ACK**：报文段首部“ACK”字段，为1时表示发来的数据已确认接收无误。当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

**ack**：TCP报文段首部中“**确认号字段**”的具体数值，“`ack=x+1`”表示服务器希望客户端下次发送数据的字节序号为`x+1`



刚开始客户端处于**CLOSED状态**，服务端处于**LISTEN状态**。

第一次握手：

客户端给服务端发送一个SYN报文，并指明客户端的初始化序列号ISN（seq的值，假设为x）。此时客户端的状态为**CLOSED->SYN_SEND**。

发送给服务器的数据为：`SYN=1`，`seq=x`。SYN=1的报文段不能携带数据，而且需要消耗一个序号。

第二次握手：

服务器接收到客户端的SYN报文后，用自己的SYN作为应答，并且指定了服务端的初始化序列号ISN（seq的值，假设为y）。并且将ACK的值设置为客户端ISN+1（即客户端的seq+1），标识已经收到客户端的SYN报文。此时服务器的状态为**LISTEN->SYN_RCVD**。

发送给客户端的数据为：`SYN=1`，`ACK=1`，初始序号`seq=y`，确认号`ack=x+1`。

第三次握手：

客户端收到SYN报文后，应答一个ACK报文，将服务器的ISN+1（seq+1）作为ACK的值，表示收到服务器的SYN报文。此时客户端的状态为**SYN_SENT->ESTABLISHED**，服务器的状态为**SYN_RCVD->ESTABLISHED**。

发送服务端数据为：`ACK=1`，初始序号`seq=x+1`，确认号`ack=y+1`。



发送第一个SYN报文的一端执行**主动打开（active open）**，接收这个SYN并回发SYN的一端执行**被动打开（passive open）**。

### 3.2 为什么要三次握手，两次不行吗？

**第一次握手**：客户端发送网络包，服务端确认接收。可以得出：客户端发送能力和服务端接收能力正常。

**第二次握手**：服务端发送网络包，客户端确认接收。可以得出：服务端的发送、接收能力和客户端的发送能力正常，但并不能确定客户端的接收能力正常。

**第三次握手**：客户端发送网络包，服务端确认接收。可以得出：客户端服务端发送、接收能力都正常。三次发送才能保证。

**如果是两次握手可能出现的情况**：

如果客户端发送一个连接请求，但因为报文丢失没有收到确认，于是客户端又发送了第二个连接请求，服务端确认连接，发送完数据后，释放了当前的连接。但是客户端发送的第一个连接请求，可能因为是在某些网络节点长时间滞留，延误到释放第二个连接后才到达服务端，此时服务端认为这是一个新的连接请求，回复确认并建立连接，但是客户端忽略此确认，一直未向服务端发送数据，导致服务端一直等待客户端发送数据，浪费资源。

### 3.3 什么是半连接队列？

> 服务器第一次收到SYN后，处于SYN_RVCD状态，双方还未正式建立连接，此时服务器会将此种状态下的连接放在一个队列里，成为“半连接队列”。

当然，建立完三次握手的连接会放在**全连接队列**里。如果队列满，可能会出现丢包现象。

**SYN-ACK 重传次数的问题**：

服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

### 3.4 ISN(Initial Sequence Number)是固定的吗？

建立连接时发送SYN是，需要为连接选择初始序列号ISN。ISN可以看做一个32位的计数器，每4ms加1，随时间变化，每个连接具有不同的ISN。

目的是为了防止网络中被延迟的分组在以后被再次传送，而导致连接的另一方对它做出错误的解释。

三次握手中客户端和服务端要交换ISN，以便让对方知道接下来接收数据按照何种序列号组装数据。如果ISN是固定的，攻击者和容易猜出后续的确认号。

### 3.5 三次握手的过程中可以携带数据吗？

第一次和第二次不可以携带数据，第三次可以携带数据。

如果第一次握手客户端携带数据，如果有恶意攻击者攻击服务器，每次都携带了大量的数据，疯狂发送，而且不理会服务器的接收、发送能力，那么服务器需要花费很多时间和空间接受这些报文。浪费时间，可能还会导致服务器崩溃。第二次同理。

第三次，客户端已经处于ESTABLISHED状态，而且已知服务端的发送接收能力正常，所以可以携带数据。

### 3.6 什么是SYN攻击？

服务端资源在第二次握手时分配，客户端资源在第三次握手时分配。服务器容易受到SYN洪泛攻击，即客户端在短时间内伪造大量不存在的IP地址，并向服务端不断发SYN包，服务端需要回复确认并等待客户端的回复。由于源地址IP不存在，服务端不断重发直至超时，这些伪造的SYN包长时间占用未连接队列，导致正常的SYN队列满而被丢弃，从而引发网络堵塞甚至系统瘫痪。

SYN是一种典型的DoS/DDoS攻击。

检测：服务器大量存在半连接状态，特别是源地址IP是随机的，基本可以判断为SYN攻击。

在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```java
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

### 3.7 四次挥手过程

![四次挥手流程图](https://gitee.com/koala010/typora/raw/master/img/四次挥手流程图20210624203352.jpg)

名词解释：

**FIN**：代表关闭连接。

> 建立连接需要三次握手，而终止连接需要四次握手，这是由于TCP的半关闭（half-close）造成的。
>
> 半关闭：TCP提供了在结束发送后还能接收来自另一端数据的能力。

刚开始客户端和服务端都处于ESTABLISHED状态。

以下过程，假设由客户端先发起关闭请求

第一次挥手：

客户端发送FIN报文，并携带生成的序列号，停止再发送数据，主动关闭TCP连接，等待后端确认。此时客户端的状态为**ESTABLISHED->FIN_WAIT1**。

发送到服务端的数据：`FIN=1`，`seq=u`。

第二次挥手：

服务端收到FIN后，发送ACK报文，并将ACK值设置为客户端序列值+1，表明已经收到客户端的报文。此时TCP处于半关闭状态，客户端客户端到服务端的连接被释放（服务端还可以向客户端发送数据），客户端等待服务端发出的连接释放报文段。此时服务端的状态为**ESTABLISHED->CLOSE_WAIT**。

客户端收到服务端的确认后，状态为**FIN_WAIT1->FIN_WAIT2**。

发送到客户端的数据：`ACK=1`，`seq=v`，`ack=u+1`。

第三次挥手：

如果服务器也想断开连接，同客户端一样发送FIN报文，等待客户端确认。此时服务端的状态为**CLOSE_WAIT->LAST_ACK**。

发送到客户端的数据：`FIN=1`,`ACK=1`，`seq=w`，`ack=u+1`。

第四次挥手：

客户端收到FIN报文后，发送ACK报文作为应答，并携带ACK报文序列号的值（服务端seq+1）。客户端的状态为**FIN_WAIT2->TIME_WAIT**。等待2MSL后，客户端的状态为**TIME_WAIT->CLOSED**。

发送到服务端的数据：`ACK=1`，`seq=u+1`，`ack=w+1`。

服务端收到ACK报文后，状态为**LAST_ACK->CLOSED**。

如果服务端收不到ACK报文，那么服务端超时重传FIN-ACK报文，客户端重新确认，重启时间等待计时器，直至最后客户端和服务端都变为CLOSED状态。

### 3.8 挥手为什么要四次？

挥手操作需要四次，是因为**TCP提供了在一段结束发送后还能接收来自另一端数据的能力**。

握手时，SYN报文用来同步，客户端可以发送SYN报文给服务端，服务端收到后可以直接发送SYN+ACK报文来应答。但是挥手时需要考虑到服务端并不会立即关闭SOCKET，可能还需要向客户端发送数据，所以只是先回复一个ACK报文，告诉客户端“你的FIN报文我收到了”。等到数据全部发完，服务端再发送FIN报文。故需要四次挥手。

### 3.9 为什么要有2MSL等待状态？

> MSL（Maximum Segment Lifetime）可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

> TIME_WAIT状态也成为2MSL等待状态，每个具体TCP实现必须选择一个报文段最大生存时间MSL，这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

两个理由：

- **保证客户端发送的最后一个ACK报文段能够到达服务端**。
  - 第四次挥手的ACK报文可能丢失，服务端则可能不会改变为CLOSED状态。所以需要服务端超时重新发送FIN+ACK报文，客户端重新确认，重启时间等待计时器，重新发送ACK报文，保证客户端和服务端都能进入到CLOSED状态。
- **防止“已失效的连接请求报文段”出现在本连接中**。

### 3.10 三次握手和四次挥手状态变迁总结

![三次握手和四次挥手状态变迁总结](https://gitee.com/koala010/typora/raw/master/img/三次握手和四次挥手状态变迁总结.jpg)



## 4. TCP和UDP的区别

参考：

- [TCP和UDP的最完整的区别](https://www.cnblogs.com/williamjie/p/9390164.html)
- [TCP和UDP的区别](https://blog.csdn.net/zhang6223284/article/details/81414149)

|                                                      | TCP                      | UDP                                |
| :--------------------------------------------------- | ------------------------ | ---------------------------------- |
| 是否需要建立连接                                     | 是                       | 否                                 |
| 结构                                                 | 简单                     | 较复杂                             |
| 是否可靠（数据完整性）                               | 可靠                     | 不可靠                             |
| 流量控制（发送方不会发送过快而超过接收方的处理能力） | 支持                     | 不支持                             |
| 时间/延迟保障                                        | 不支持                   | 不支持                             |
| 最小带宽保障                                         | 不支持                   | 不支持                             |
| 数据发送顺序                                         | 保障                     | 不保障                             |
| 发送方式                                             | 字节流                   | 数据报                             |
| 传输速度                                             | 较慢                     | 较快                               |
| 对系统资源要求                                       | 较高                     | 较低                               |
| 适用场景                                             | 保证数据完整性、少量数据 | 可容忍一定的数据丢包、传输大量数据 |

### UDP

![UDP报头](https://gitee.com/koala010/typora/raw/master/img/UDP20210624221808.png)

UDP 除了端口号，基本啥都没有了。

**适用场景**：

- 网络情况稳定的内网或者可以在一定程度上容忍丢包的应用。
- 不需要一对一建立连接，可以广播应用。
- 需要处理速度够快，即使网络拥塞。

**例子**：

- 直播。实时性要求高，可以丢包，但不能卡顿。
- 实时游戏。实时性高，需要极大程度上降低延迟，减少网络问题对游戏的影响。
- 物联网。中断资源少，很可能是一个很小的嵌入式系统，维护TCP代价太大，而且对实时性要求比较高。

### TCP

![TCP报头](https://gitee.com/koala010/typora/raw/master/img/TCP20210624222442.png)

**报头的作用**：

- 源端口和目标端口必不可少。
- 包的序号。主要是为了解决乱序问题。TCP传输是有序的。
- 确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题。
- 状态位。SYN 是发起一个请求连接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更。
- 窗口大小。TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。

