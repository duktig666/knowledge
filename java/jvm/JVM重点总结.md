# JVM体系结构

## JVM的位置

JVM是运行在操作系统之上的，它与硬件没有直接的交互。

![image-20210619202046941](https://gitee.com/koala010/typora/raw/master/img/JVM的位置.png)

## JVM的整体结构

- HotSpot VM是目前市面上高性能虚拟机的代表作之一。
- 它采用解释器与即时编译器并存的架构。
- 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。

![image-20210619202346200](https://gitee.com/koala010/typora/raw/master/img/JVM整体结构.png)

执行引擎包含三部分：解释器，即时编译器，垃圾回收器。

## Java代码执行流程

![image-20210619202926817](https://gitee.com/koala010/typora/raw/master/img/Java代码执行流程.png)

JIT缓存热点代码

## Java架构模型

Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。

### 基于栈式架构的特点
- 设计和实现更简单，适用于资源受限的系统;
- 避开了寄存器的分配难题:使用零地址指令方式分配。
- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
- 不需要硬件支持，可移植性更好，更好实现跨平台

### 基于寄存器架构的特点

- 典型的应用是x86的二进制指令集:比如传统的PC以及Android 的 Davlik虚拟机。
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作。
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

## JVM的生命周期

### 启动

Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类( initial class）来完成的，这个类是由虚拟机的具体实现指定的。

### 执行

- 一个运行中的Java虚拟机有着一个清晰的任务:执行Java程序。
- 程序开始执行时他才运行，程序结束时他就停止。
- 执行一个所谓的 Java程序的时候，真真正正在执行的是一个叫做Java 虚拟机的进程。

### 退出

虚拟机退出的情况：

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止，由于操作系统用现错误而导致Java虚拟机进程终止
- 某线程调用Runtime类或system类的exit方法，或Runtime类的 halt方法，并且Java安全管理器也允许这次exit或halt 操作。
- 除此之外，JNI ( Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java 虚拟机的退出情况。



# 垃圾回收

参看：[JVM 垃圾回收](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)

# JDK 监控和故障处理工具总结

参看：[JDK 监控和故障处理工具总结](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93)



# 虚拟机执行子系统

## 虚拟机类加载机制

### 类的生命周期

![类的生命周期](https://gitee.com/koala010/typora/raw/master/img/类的生命周期20210622091915.png)

### 类的加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

