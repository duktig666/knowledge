# JVM面试题

## 1. JVM的内存结构

### 运行时数据区

![运行时数据区内存结构图](https://gitee.com/koala010/typora/raw/master/img/20210621153304.png)



![JVM内存结构](https://gitee.com/koala010/typora/raw/master/img/20210810171112.png)



线程共享方法区和堆，独占虚拟机栈、本地方法栈和程序计数器。

#### 程序计数器

程序计数器是一块较小的内存空间，可以看做当前线程执行的字节码的行号指示器。

**作用：**

1. **字节码解释器通过改变程序计数器来依次读取指令，从而实现流程控制**。如：顺序选择、选择、循环、异常处理。
2. **在多线程的情况下，程序计数器记录当前线程的执行位置，以便线程切换回来可以得知上次的执行位置**。（问题：线程为什么独占程序计数器的答案）

**注意：**

- **程序计数器是唯一一个在《Java虚拟机规范》中没有规定任何`OutOfMemoryError`情况的区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**
- 如果正在执行的是Java方法，记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是**本地（Native）方法**，这个**计数器值则应为空（`Undefined`）**。

#### 虚拟机栈

生命周期与线程相同。

虚拟机栈存储“栈帧”，每个方法会创建一个栈帧，**栈帧中存放局部变量表、操作数栈、动态链接、方法出口等信息**。

**局部变量表**：

- 局部变量表存放了编译期中各种的基本数据类型和对象引用。（栈内存一般指局部变量表）
  - 64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个
  - 局部变量表所需内存编译期完成分配，进入一个方法后，栈分配多少内存是固定的，运行期间不会改变。

方法调用就是栈帧的入栈和出栈操作。

OOM

《Java虚拟机规范》规定，

1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出`StackOverflowError`异常。
2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出`OutOfMemoryError`异常。

但是HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现
OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。

#### 本地方法栈

- 和虚拟机栈类似，两者的区别就是**虚拟机栈是为虚拟机执行java方法服务**，**本地方法栈为虚拟机执行native方法服务**。

- **HotSpot虚拟机不区分虚拟机栈和本地方法栈**（合二为一）。

#### 堆

- Java 虚拟机所管理的内存中最大的一块，Java 堆是**所有线程共享的一块内存区域**，在虚拟机启动时创建。

- **此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

- 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”

- JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
- 可通过参数 -Xmx -Xms 来指定运行时堆内存的大小，在Java堆中没有内存完成实例分配，并且也无法扩展时，会抛`OutOfMemoryError`异常。

#### 方法区

- 方法区也是线程共享区，用于存储【虚拟机加载的**类信息**（类的版本、字段、方法、接口），**常量**，**静态变量**，**即时编译器编译后的代码缓存**等数据】

**方法区和永久代的关系**：

> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

**JDK8移除了永久代，改为元空间代替。为什么？**

因为永久代有上限，导致Java应用更容易遇到内存溢出问题。

内存回收的目标主要针对 常量池的回收 和 类型的卸载。

##### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分，用于**存放编译期生成的各种字面量与符号引用**（属于类信息的一部分）。

《Java虚拟机规范》并没有做任何细节要求，可以由供应商自己实现。

运行时常量池与Class文件常量池对比 最大特征是**具备动态性**。运行时可以将新的常量放入池中，典型的有`String`类的`intern()`方法。

> `String`类的`intern()`方法：返回字符串对象的规范化表示形式。
>
> 一个初始时为空的字符串池，它由类 String 私有地维护。
>
> **当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 `equals(Object)` 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。**
>
> 它遵循对于任何两个字符串 s 和 t，当且仅当 `s.equals(t)` 为 `true` 时，`s.intern() == t.intern() `才为 `true`。

#### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 异常出现**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

一般配置虚拟机参数时会根据实际内存去设置-Xmx等信息，但经常忽略直接内存，导致总内存大于物理内存限制，动态扩容时出现`OutOfMemoryError` 异常。

## 2. 堆中的Eden和Survivor比例问题

Eden区是一块，Survivor区是两块。

Eden区和Survivor区的比例是8：1：1。

参考：[新生代Eden与两个Survivor区的解释](https://blog.csdn.net/lojze_ly/article/details/49456255)



## 3. JVM的垃圾回收机制

**为什么需要了解垃圾回收机制**？

当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。

**哪些区域需要垃圾回收**？

程序计数器、虚拟机栈和本地方法栈同线程生命周期一致，方法/线程技结束，内存直接回收，无需过多考虑。

堆和方法区有着不确定性：一个接口多个实现类所需内存不一样，一个方法不同的条件和分支所需内存也可能不一样。只有在运行期间才知道程序会创建哪些对象、多少个对象。这部分内存分配和回收是动态，所以需要关注内存的分配与回收。

### 3.1 垃圾判断算法（如何判断对象需要被回收？）

#### 引用计数算法

> 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**

#### 可达性分析算法

> 通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![image-20210622161600979](https://gitee.com/koala010/typora/raw/master/img/ 可达性分析算法20210622161601.png)

**可作为 GC Roots 的对象**：

- **在虚拟机栈（栈帧中的本地变量表）中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- **在方法区中类静态属性引用的对象**，譬如Java类的引用类型静态变量。
- **在方法区中常量引用的对象**，譬如字符串常量池（String Table）里的引用。
- **在本地方法栈中JNI（即通常所说的Native方法）引用的对象**。
- **Java虚拟机内部的引用**，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- **所有被同步锁（synchronized关键字）持有的对象**。
- **反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等**。



**利用可达性分析算法，如何判断一个对象死亡**？

两次标记阶段。

第一次标记：对象没有与`GC Roots`相连时，判断该对象的`finalize`方法有没有被覆盖过，或者有没有被虚拟机执行过。如果没有，则直接被回收；如果执行过，对象被放置进`F-Queue`队列中，进行第二次标记。

第二次标记：如果对象在`finalize`关联上了`GC Roots`，在队列中移除（只能关联一次）；如果没有，被回收。

### 3.2 引用

JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）。

![Java四种引用的结构](https://gitee.com/koala010/typora/raw/master/img/Java四种引用的结构20210622164831.png)

**1、强引用**

强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似`Objectobj=new Object()`这种引用关系。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**2、软引用**

描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类`SoftReference`表示软引用。

**3、弱引用**

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类`WeakReference`表示弱引用。

**4、虚引用**

这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

关于应用的使用案例参考：[Java的四种引用详解与使用案例](https://blog.csdn.net/TJtulong/article/details/104879688)

提到Java引用及垃圾回收机制，当我联想到了以前的一个说法，**在链表删除一个节点的时候，将这个节点置为null，以方便下次垃圾回收机制删除**，这个操作是否有意义？

通常情况下没有什么意义，除非在特定的一些情况下：

1 同一个方法中
2 定义了一个大对象(小对象没有意义)
3 之后跟着一个非常耗时的操作.
4 没有满足JIT编译条件

 上面4个条件缺一不可,把obj显式设置成null才是有意义的。

参考：

- [在Java中将对象分配为null会影响垃圾回收吗？](https://www.itranslater.com/qa/details/2126692746223158272)
- [java中将对象赋值为null，对垃圾回收有用吗？](https://blog.csdn.net/qq_42945742/article/details/84107531)

### 3.3 垃圾回收算法

#### 分代收集理论

建立在两个分代假说之上：

1）**弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的**。

2）**强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡**。

收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

因为对象之间会存在跨代引用，进行一次Minor GC，但新生代对象可能被老年代引用，不得不在GC Roots之外再遍历老年代确保可达性分析的正确性，反之一样。可能会给内存回收带来很大的性能负担。

**跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数**。隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

需在新生代上建立一个全局的数据结构，把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用，可以缩小扫描范围。

#### 标记-清除算法（Mark-Sweep）

**标记需回收/存活对象，统一清除标记的对象**。

<img src="https://gitee.com/koala010/typora/raw/master/img/标记-清除算法20210622174750.png" alt="image-20210622174750725" style="zoom:67%;" />

**缺点**：

- **执行效率不稳定**。对象越多，效率越低。
- **内存空间的碎片化问题**。

#### 标记-复制算法（Mark-Copying）

**“半区复制”，每次只用一块内存，存活对象复制到另一块，已经使用的那一块直接清除**。

<img src="https://gitee.com/koala010/typora/raw/master/img/标记-复制算法20210622175418.png" alt="image-20210622175417983" style="zoom:67%;" />

优点：无内存碎片化问题。

缺点：对象存活率高时，大量复制，效率低。

#### 标记-整理算法（Mark-Compact）

标记存活对象，让所有存活对象移动到一端，然后清理所有的边界以外的内存。

<img src="https://gitee.com/koala010/typora/raw/master/img/ 标记-整理算法（Mark-Compact）.png" alt="image-20210622180525483" style="zoom:67%;" />

**是否移动对象都有弊端，移动内存回收比较复杂，不移动内存分配比较复杂（空间碎片化）**。

一种方案：**虚拟机平时采用标记-清除算法，暂时容忍碎片存在，直到碎片影响大到内存分配时，在进行标记-整理算法，可获得规整的内存空间**。

关于**标记-整理算法的可回收对象与存活对象如何移动？**，可参考：[垃圾回收算法——标记—整理回收](https://blog.csdn.net/luliuliu1234/article/details/104058259) （了解）

### 3.4 垃圾收集器

![垃圾收集器总结](https://gitee.com/koala010/typora/raw/master/img/垃圾收集器总结.png)

JDK8默认使用ParNew（标记复制、并行、作用于新生代） + CMS的垃圾收集器（标记清除、并行、作用于老年代），追求响应速度优先，其适用于多CPU环境的Server模式的互联网或者B/S业务。

如果追求吞吐量优先，应用在后台运算并不需要太多交互场景的，可采用Parallel（标记复制、并行、作用于新生代） + Parallel Old 的垃圾收集器（标记整理、并行、作用于老年代）

详细内容参考JavaGuide：[垃圾收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM垃圾回收?id=_4-垃圾收集器)

#### CMS收集器

> **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器**。这是因为CMS收集器工作时，GC工作线程与用户线程可以`并发`执行，以此来达到降低收集停顿时间的目的。

CMS收集器仅作用于**老年代**的收集，是基于`标记-清除算法`的，它的运作过程分为4个步骤：

- 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
- 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。
- 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。
- 并发清除（CMS concurrent sweep）

> CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有**两次短暂的暂停（初始标记和重新标记）**，**达到了近似并发的目的**。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：

![CMS收集器运作图](https://gitee.com/koala010/typora/raw/master/img/20210810170643.png)

CMS收集器**优点**：并发收集、低停顿。

CMS收集器**缺点**：

- **CMS收集器对CPU资源非常敏感**。面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。
- **CMS收集器无法处理浮动垃圾（Floating Garbage）**。
  - 由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。
  - 这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
- **CMS收集器是基于标记-清除算法，该算法的缺点都有**。收集结束可能存在大量空间碎片；碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象（所以未提供CMS的新生代版本）。

#### G1收集器

> G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。

##### 特点

- **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过**并发**的方式让Java程序继续运行。
- 分代收集：G1能够自己管理不同分代内已创建对象和新对象的收集。
- 空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于**标记-整理算法**实现的收集器，从局部（两个Region之间）上来看是基于“**复制**”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。**这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC**。
- 可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。

##### **使用场景**

G1 GC切分堆内存为多个区间（Region），从而避免很多GC操作在整个Java堆或者整个年轻代进行。G1 GC只关注你有没有存货对象，都会被回收并放入可用的Region队列。G1 GC是基于Region的GC，适用于大内存机器。即使内存很大，Region扫描，性能还是很高的。

#### 介绍

在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，**G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间**，G1模块的组成如下图所示：

<img src="https://gitee.com/koala010/typora/raw/master/img/20210810165404.png" alt="G1堆" style="zoom:67%;" />

G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region，这一点可以参看如下[源码](https://link.zhihu.com/?target=http%3A//hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp)。其实这个数字既可以手动调整，G1也会根据堆大小自动进行调整。

**G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集**。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。

对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照[官方](https://link.zhihu.com/?target=https%3A//www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html) 的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能： - 实时数据占用了超过半数的堆空间； - 对象分配率或“晋升”的速度变化明显； - 期望消除耗时较长的GC或停顿（超过0.5——1秒）。

##### G1的运作过程

- **初始标记（Initial Marking）**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，**这阶段需要`停顿线程`，但耗时很短**。
- **并发标记（Concurrent Marking）**：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，**这阶段耗时较长**，但可与用户程序并发执行。
- **最终标记（Final Marking）**：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，**这阶段需要`停顿线程`，但是可并行执行**。
- **筛选回收（Live Data Counting and Evacuation）**：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

![G1运作图](https://gitee.com/koala010/typora/raw/master/img/20210810170624.png)

##### Remembered Set

G1在回收每个Region上的垃圾时，每个Region之间又有相互依赖引用关系，想要做到对全部Region进行扫描清理，那么不得不做一次全堆扫描。这样就降低了垃圾回收的效率。所以HotSpot引入了Remembered Set来专门存储于管理对象的引用依赖关系，这样当每次回收时，只需要根据Remembered Set上面的对应关系找到相对的区域进行清理，这样就可以避免扫描整个堆内存又不会遗漏某一个区域。

##### OopMap

我们都知道在GC之前要做一次GC Roots来查找对象的存活情况，一边在GC时候正确的回收。那么每次GC时候遍历所有的引用是不现实的，那么这之后就引入了OopMap，它里面记录了一些类加载时候的类型与偏移量地址等信息生成一张映射表放在OopMap中。GC开始的时候，就通过OopMap这样的一个映射表知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录下栈和寄存器中哪些位置是引用。

##### **安全点/安全区域(Safepoint/Safe Region)**

上面为了快速的分析可达性，使用了一个引用类型映射表，可以快速的知道对象内或者栈和寄存器中哪些位置引用了。那么在方法执行过程中，这些引用关系可能会随时发生变化，那么OopMap是不是也要跟着变呢？如果没出引用变化就更新OopMap那么也是不现实的，这时候就引入了安全点的概念。OopMap的作用就是在每次GC前保证是最新的就可以了。OopMap只需要在预先选定的一些位置上记录变化的OopMap就行了。在这个状态下虚拟机堆栈不在发生变化。而安全点的选定是以程序‘是否具有让程序长时间执行的特征’为标准选定的。‘长时间执行’的明显特征就是指令序列复用，例如：方法调用（方法临返回前/调用方法的call指令后），循环跳转（循环的末尾），异常跳转（可能抛异常的位置）等，具有这些功能的指令才再回产生安全点。大白话就是在程序中寻找一个安全点，当GC触发时，为了线程状态和数据的一致性，让线程都跑到这个安全点停顿下来后再执行GC。至于安全区域你可以认为在这个区域的任何位置都可以GC，即点.线,面的关系。基于安全点中断GC的方式有两种：

1. 抢先式中断（Preemptive Suspension）：抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。
2. 主动式中断（Voluntary Suspension）：主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

##### 卡表（Card Table）

有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。

HotSpot给出的解决方案是一项叫做`卡表`（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。

想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

**卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率**。

#### CMS和G1的区别

**区别一： 使用范围不一样**

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用

G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

**区别二： STW的时间**

CMS收集器以最小的停顿时间为目标的收集器。

G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

**区别三： 垃圾碎片**

CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片

G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

**区别四： 垃圾回收的过程不一样**

CMS收集器                      G1收集器

1. 初始标记                   1. 初始标记
2. 并发标记                   2. 并发标记
3. 重新标记                   3. 最终标记
4. 并发清除                   4. 筛选回收

**总览**

|                      | CMS                          | G1                                                           |
| -------------------- | ---------------------------- | ------------------------------------------------------------ |
| JDK版本              |                              |                                                              |
| 回收算法             | 标记—清除                    | 标记—整理（标记—复制）                                       |
| 运行环境             | 针对70G以内的堆内存          | 可针对好几百G的大内存                                        |
| 回收区域             | 老年代                       | 新生代和老年代                                               |
| 内存布局             | 传统连续的新生代和老年代区域 | Region(将新生代和老年代切分成Region，默认一个Region 1 M,默认2048块)<br/>MIN_REGION_SIZE：允许的最小的REGION_SIZE，即1M，不可能比1M还小；<br/>MAX_REGION_SIZE：允许的最大的REGION_SIZE，即32M，不可能比32M更大；<br/>限制最大REGION_SIZE是为了考虑GC时的清理效果； |
| 浮动垃圾             | 是                           | 否                                                           |
| 内存碎片             | 是                           | 否                                                           |
| 全堆扫描             | 是                           | 否                                                           |
| 回收时间可控         | 否                           | 是                                                           |
| 对象进入老年代的年龄 |                              |                                                              |
| 空间动态调整         | 否                           | 是（新生代5%-60%动态调整，一般不需求指定）                   |
| 调优参数             | 多（近百个）                 | 少（十几个）                                                 |



参看：

-  [7 种 JVM 垃圾收集器，看完我跪了。。](https://www.cnblogs.com/javastack/p/13152564.html)
- [弄明白CMS和G1，就靠这一篇了](https://zhuanlan.zhihu.com/p/87770882)
- [一篇文章彻底搞懂CMS与G1](https://zhuanlan.zhihu.com/p/161204689)



### 3.5内存分配与回收策略（垃圾回收过程）

- **对象优先在Eden分配**。大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
- **大对象直接进入老年代**。大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。
- **长期存活的对象将进入老年代**。
  - HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中（详见第2章）。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象
    年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX：MaxTenuringThreshold`设置。
- **动态对象年龄判定**。
  - 为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到`-XX：MaxTenuringThreshold`才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到`-XX：MaxTenuringThreshold`中要求的年龄。
- **空间分配担保**。
  - 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

（参考：深入理解Java虚拟机第三版的3.8节）



关于垃圾收集机制的详细内容可参考：[JVM垃圾回收机制](https://www.cnblogs.com/hexinwei1/p/9525737.html)

## 4. 类加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

如下图：

![类加载过程](https://gitee.com/koala010/typora/raw/master/img/20210701103844.png)

### 加载

在加载阶段，JVM主要完成下面三件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 `ZIP` 包中读取（日后出现的 `JAR`、`EAR`、`WAR` 格式的基础）、其他文件生成（典型应用就是 `JSP`）等等。

**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步可以去完成，还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

> 说明：除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。

### 连接

#### 验证

##### 1、文件格式验证

主要验证内容：

- 是否以魔数`0xCAFEBABE`开头。
- 主、次版本号是否在当前Java虚拟机接受范围之内。
- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- `CONSTANT_Utf8_info`型的常量中是否有不符合UTF-8编码的数据。
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
- ……

该验证阶段的主要目的是**保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求**。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

##### 2、元数据验证

这个阶段是**对字节码描述的信息进行语义分析**。主要验证内容：

- 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。

##### 3、字节码验证

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是**通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的**。主要验证内容：

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。
- 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

元数据验证段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。

##### 4、符号引用验证

校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。目的：**确保解析动作正确执行**。主要验证内容：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的可访问性（`private`、`protected`、`public`、`<package>`）是否可被当前类访问

#### 准备

**准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段**。这一阶段并不包括实例变量，实例变量的初始化随着对象一块分配在Java堆中。

> 从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

**这里所设置的初始值"通常情况"下是数据类型默认的零值**（如 0、0L、null、false 等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。

#### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

> 符号引用就是一组符号来描述目标，可以是任何字面量。

> **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

对类/接口、字段、方法、接口方法的解析过程，可参看《深入理解Java虚拟机（第3版）》。

### 初始化

初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

> 说明： `<clinit> ()`方法是编译之后自动生成的。

对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit> ()` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。

对于初始化阶段，虚拟机严格规范了有且只有 以下情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：

1. 当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。

   当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。

   当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。

   当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。

   当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。

2. 使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname("..."), newInstance() 等等。如果类没初始化，需要触发其初始化。

3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。

5. MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。

6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 补充：卸载

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

## 5. 类加载器和双亲委派模型

所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。

> Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。

每一个类加载器，都拥有一个独立的类名称空间比较两个类是否“相等”。只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”，包括代表类的Class对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法的返回结果，也包括了使用`instanceof`关键字做对象所属关系判定等各种情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果，

### 5.1 类加载器总结

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

### 5.2 双亲委派模型

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

#### **双亲委派模型的工作过程**

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

![双亲委派模型](https://gitee.com/koala010/typora/raw/master/img/20210701154740.png)

#### 好处

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

#### 如何破坏双亲委派模型？

自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法

#### 自定义类加载器

除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`。



## 6. JVM参数调优

查看：[JVM系列三:JVM参数设置、分析](https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)





## 参看

- [学习JVM是如何从入门到放弃的？](https://www.jianshu.com/p/904b15a8281f) （很多东西总结的还是挺全的）











