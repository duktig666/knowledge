> 作者：duktig
>
> 博客：[https://duktig.cn](https://duktig.cn)
>
> 优秀还努力。愿你付出甘之如饴，所得归于欢喜。

## 背景

`synchronized`在多线程和高并发中经常用到，尤其是`synchronized`在JDK6之后进行了优化，效率堪比Lock锁，甚至犹有过之。也是面试中的常客。

> 面试官：你平时用过多线程吗？
>
> 面试官：你怎么解决线程安全问题呢？
>
> 我：最常用的就是让多线程的操作同步处理，常用的有 `Lock` 锁和 `synchronized`
>
> 面试官：那你能说说`Lock` 锁和 `synchronized`的区别吗？
>
> 我：（心里想，这个比较容易）……
>
> 面试官：你能和所说`synchronized`的原理吗？
>
> 我：（这个之前刚好研究过）……
>
> 面试官：`synchronized`以前是重量级锁，之后有了很多优化，你能说说吗？
>
> 我：`synchronized`在JDK6有了很多优化，最重要的有个锁升级的过程，提高了获得锁和释放锁的过程。
>
> 面试官：那你能说说`synchronized`锁升级的过程吗？以及它是怎么进行标识的？
>
> 我：（GG，这个之前看了很多次，但是都没理清楚）…… （说的一塌糊涂）

本篇文章就以清晰的流程来阐述`synchronized`的锁升级过程，以及是怎么进行标识的。

## synchronized与对象头

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。

Java对象头的长度：

![Java对象头的长度](https://cos.duktig.cn/typora/202110011130581.png)

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。

Java对象头的存储结构：

![Java对象头的存储结构](https://cos.duktig.cn/typora/202110011131420.png)

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：

32位Mark Word的状态变化：

![32位Mark Word的状态变化](https://cos.duktig.cn/typora/202110011132836.png)

在64位虚拟机下，Mark Word是64bit大小的，其存储结构如表：

![64位 Mark Word的存储结构](https://cos.duktig.cn/typora/202110011133698.png)

## synchronized的锁升级过程

锁升级过程依次为：无锁状态、偏向锁、轻量级锁、重量级锁。

synchronized可以进行锁升级，但是不能降级，目的是**为了提高获得锁和释放锁的效率**。

### 偏向锁

> HotSpot作者发现，大多数情况下，**锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁**。

**对象头**：

- 23bit的线程ID；
- 1bit是否为偏向锁值为1说明是偏向锁状态；
- 无锁和偏向锁2bit的锁标志位都是01

**偏向锁加锁过程**：

1. 检查对象头和栈帧中的锁记录是否存储了当前线程的线程ID  
   1. 即简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁即可
   2. *（为了保证当前线程每次进入和退出同步块时不需要CAS操作加锁和解锁）*
2. 测试成功表示获得了锁
3. 测试失败再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）
   1. 如果没有设置，则使用CAS竞争锁
   2. 如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

**偏向锁撤销过程**：

偏向锁使用了一种**等到竞争出现才释放锁**的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

1. 前提条件：等待全局安全点（在这个时间点上没有正在执行的字节码）
2. 暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着
3. 如果线程不处于活动状态，则将对象头设置成无锁状态
4. 如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁
5. 最后唤醒暂停的线程

**偏向锁获得和撤销锁的过程：**

![偏向锁获得和撤销锁的过程](https://cos.duktig.cn/typora/202110011056649.png)

**偏向锁的升级：**

**只要存在两个线程的并发竞争，偏向锁升级为轻量级锁**。



### 轻量级锁

**轻量级锁加锁过程：**

1. 线程在执行同步块前，JVM在当前线程栈帧中分配空间，并将对象头中的Mark Word复制到锁记录中（官方称为Displaced Mark Word）
2. CAS将对象头中的Mark Word替换为指向锁记录的指针
3. 如果成功，当前线程获得锁
4. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

**轻量级锁撤销过程：**

1. CAS操作将Displaced Mark Word替换回到对象头
2. 如果成功，则表示没有竞争发生
3. 如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

**轻量级锁膨胀的流程图**：

![轻量级锁膨胀的流程图](https://cos.duktig.cn/typora/202110011116663.png)

### 重量级锁

因为**自旋会消耗CPU**，为了**避免无用的自旋**（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。

**当锁处于重量级锁状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争**。

## 锁的优缺点对比

![synchronized锁的优缺点对比](https://cos.duktig.cn/typora/202110011118990.png)

## 参看：

- 《Java并发编程的艺术》
- 《Java多线程编程核心技术》
- [曾经总结的多线程相关的笔记](https://github.com/duktig666/knowledge/tree/main/java/thread)