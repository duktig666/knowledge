# 多线程

## 什么是线程安全问题？

线程安全指的是多线程不管以何种方式访问某个类，都能表现正确的行为。

非线程安全指的是多线程对同一个对象的实例变量并发访问时，可能出现值被更改、值不同步的情况。

## 如何解决线程安全问题？

1. 方法中的变量是线程安全的

## synchronized

### 原理

**同步语句块**

1. `synchronized` 同步语句块`monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置；
2. 当执行 `monitorenter` 指令时，线程试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权。
3. 在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。.
4. 在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。

**同步方法**

JVM 通过 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### **重点注意事项**

1. 关键字`synchronized`获取的锁是**对象锁**。
2. 只有**共享资源**的读写访问才需要加锁。
3. 支持**继承**效果的**可重入锁**
4. 出现异常，锁自动释放
5. 加锁访问时的注意事项
   1. 对象锁`synchronized`方法同步等待，可异步访问非`synchronized`方法
   2. 如果使用同步代码块非`this`对象，则`synchronized(非this)`与同步方法是异步的（因为有两把锁）
   3. `synchronized`作用在`static`方法上，相当于使用当前静态方法所在类对应的Class类的单例对象加锁
   4. `synchronized`修饰静态方法和`synchronized(class)`对类的所有实例对象起作用
   5. `synchronized(String)`要注意常量池带来的影响
6. `println()`方法是同步的，加入了`synchronized`代码块。

## 多线程的死锁问题？

### 什么是死锁？

> 不同的线程都在等待根本不可能被释放的锁，从而导致所有的任务都无法继续完成。

### Java中如何解决？

1. `jps`命令查询线程id
2. `jstack -l 线程id` 进行死锁检测

设计程序时要避免双方互相持有对方的锁，只要相互等待对方释放锁，就有可能出现死锁。

