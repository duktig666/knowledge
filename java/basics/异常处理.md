

# 异常概述

## 为什么会出现异常？

在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避
免的，比如： 客户输入数据的格式， 读取文件是否存在， 网络是否始终保持通畅等等。



> 异常：在Java语言中， 将程序执行中发生的不正常情况称为“异常” 。(开发过程中的语法错误和逻辑错误不是异常)



## 异常分类

- Throwable

  所有异常的父类(都继承java.lang.Throwable)

  - Error
    Java应用程序语法恢复的严重异常，不需要捕获和处理；发生时，一般通知用户并终止程序执行（如： JVM系统内部错误、 资源耗尽等严重情况。 比如： StackOverflowError）

  - Exception

    Java应用程序抛出和处理的非严重错误，称为异常。是所有Java异常的父类。（因编程错误或偶然的外在因素导致的一般性问题， 可以使用针对性的代码进行处理）

    - RuntimeExceotion
      运行时异常，编程时不处理，也可以编译通过(例如，数组下标越界)

    - CheckedException
      非运行时异常，必须编译时处理，否则不通过(例如，类找不到)

## 异常处理的一般思路

一般有两种解决方法：

1. 遇到错误就终止程序的运行。 
2. 由程序员在编写程序时， 就考虑到错误的检测、 错误消息的提示， 以及错误的处理。

## 运行时异常与编译时异常

捕获错误最理想的是在编译期间， 但有的错误只有在运行时才会发生。比如： 除数为0， 数组下标越界等

### 运行时异常（RuntimeExceotion）

1. 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。 `java.lang.RuntimeException`类及它的子
   类都是运行时异常。
2. 对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。

## 编译时异常

1. 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。 编译器要求Java程序必须捕获或声明所有编译时异常。
2. 对于这类异常，如果程序不处理，可能会带来意想不到的结果。

## 异常对象e，两个常用方法

- `printStackTrace()`：用于输出异常的堆栈信息包括程序运行到当前类的执行流程，显示方法调用序列（获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。）
- `getMessage()`：返回异常信息的字符串

## 常见异常

- NullPointerException空指针异常
  属于运行时异常，调用了未经初始化的对象或不存在的对象，或是访问或修改null对象的属性或方法(例如，数组初始化和数组元素初始化混淆)

- ClassNotFoundException类没能找到的异常
  原因①的确不存在该类
  ②环境进行了调整(目录结构发生变化，编译、运行路径发生变化)​
  ③修改类名时没有修改调用该类的其他类​

- IllegalArgumentException表明向方法传递了一个不合法或不正确的参数

- InputMismatchException由Scanner抛出
  表明Scanner获取内容与期望类型的模式不匹配，或该内容超出期望类型范围

- IllegalAccessException
  应用程序试图创建一个实例、设置或获取一个属性，或者调用一个方法，但当前正在执行的方法无法访问指定类、属性、方法或构造方法定义时，抛出

- ClassCastException试图将对象强制转换为不是实例的子类时抛出异常

- SQLException提供关于数据库访问错误或其他信息的异常

- IOException是失败或中断的I/O操作生成的异常的通用类



# 异常处理

## 异常处理机制

### 为什么采用异常处理机制？

在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。 **过多的if-else分支会导致程序的代码加长、臃肿，可读性差**。因此采用异常处理机制。

### 异常处理的好处？

Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅， 并易于维护。

### 异常处理机制概述

> Java提供的是异常处理的抓抛模型

> 抛出异常：Java程序的执行过程中如出现异常， 会生成一个异常类对象，该异常对象将被提交给Java运行时系统， 这个过程称为抛出(throw)异常。

> 捕获异常：如果一个方法内抛出异常， 该异常对象会被抛给调用者方法中处理。 如果异常没有在调用者方法中处理， 它继续被抛给这个调用方法的上层方法。 这个过程将一直继续下去， 直到异常被处理。这一过程称为捕获(catch)异常。

#### 抓抛模型

过程一："抛"：

程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。

关于异常对象的产生：① 系统自动生成的异常对象 ② 手动的生成一个异常对象，并抛出（throw）

过程二："抓"：

可以理解为异常的处理方式：① try-catch-finally  ② throws

#### 异常对象如何生成？

1. 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出
2. 由开发人员手动创建： `Exception exception = new ClassCastException();`——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样

### 捕获异常

1. 如果一个方法内抛出异常， 该异常对象会被抛给调用者方法中处理。 如果异常没有在调用者方法中处理， 它继续被抛给这个调用方法的上层方法。 这个过程将一直继续下去， 直到异常被处理。这一过程称为捕获(catch)异常。
2. 如果一个异常回到main()方法， 并且main()也不处理， 则程序运行终止。
3. 程序员通常只能处理Exception， 而对Error无能为力。



### 异常处理的方式

#### 1.try-catch-finally

##### try

捕获异常的第一步是用try{…}语句块选定捕获异常的范围， 将可能出现异常的代码放在try语句块中。

##### catch (Exceptiontype e)

在catch语句块中是对异常对象进行处理的代码。 每个try语句块可以伴随一个或多个catch语句， 用于处理可能产生的不同类型的异常对象。

如果明确知道产生的是何种异常， 可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。
比 如 ： 可 以 用 ArithmeticException 类 作 为 参 数 的 地 方 ， 就 可 以 用RuntimeException类作为参数， 或者用所有异常的父类Exception类作为参数。
但不能是与ArithmeticException类无关的异常， 如NullPointerException（catch中的语句将不会执行） 。

##### finally

1. 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。
2. **不论在try代码块中是否发生了异常事件， catch语句是否执行， catch语句是否有异常， catch语句中是否有return，finally块中的语句都会被执行。**
3. finally语句和catch语句是任选的
4. 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。
5. finally唯一不执行的情况——catch语句中出现System.exit(1)，直接退出JVM



##### 使用

```java
  try{
 		//可能出现异常的代码
  
  }catch(异常类型1 变量名1){
  		//处理异常的方式1
  }catch(异常类型2 变量名2){
  		//处理异常的方式2
  }catch(异常类型3 变量名3){
  		//处理异常的方式3
  }
  ....
  finally{
  		//一定会执行的代码
  }
```

##### 注意事项

1. try是必须的，catch和finally可选，但至少要有一个。
2. try和catch的异常类型必须一致，或是其父类
2. 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配

3. 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码

4. catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错

5. 常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()

6. 在try结构中声明的变量，再出了try结构以后，就不能再被调用

7. try-catch-finally结构可以嵌套
8. 多个catch，应按照“从小到大”的顺序捕获，避免对父类大的异常进行捕获
9. 有return时，先执行try和catch的，然后在执行finally的；即使try和catch有return,finally代码仍会执行

##### 体会

体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。

体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。

##### 示例

```java
public class IndexOutExp {
    public static void main(String[] args) {
        String friends[] = { "lisa", "bily", "kessy" };
        try {
            for (int i = 0; i < 5; i++) {
            	System.out.println(friends[i]);
            }
        } catch (ArrayIndexOutOfBoundsException e) {
        	System.out.println("index err");
        }
        System.out.println("\nthis is the end");
    }
}
```

结果：

```
程序IndexOutExp.java运行结果： java IndexOutExp
lisa
bily
kessy
index err
this is the end
```



#### 2.throws（声明抛出异常）

1. 如果一个方法(中的语句执行时)可能生成某种异常， 但是并不能确定如何处理这种异常， 则此方法应显示地声明抛出异常， 表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。
2. 在方法声明中用throws语句可以声明抛出异常的列表， throws后面的异常类型可以是方法中产生的异常类型， 也可以是它的父类。
3. "throws + 异常类型"写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！

##### 示例

```java
public void readFile(String file) throws FileNotFoundException {
    // 读文件的操作可能产生FileNotFoundException类型的异常
    FileInputStream fis = new FileInputStream(file);
}
```

##### 图解抛出异常过程

<img src="https://gitee.com/koala010/typora/raw/master/img/20200726214312.png" alt="image-20200606105606533" style="zoom:50%;" />

##### 重写方法声明抛出异常的原则

1.  在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。
2. 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

##### 体会

体会1：`try-catch-finally`:真正的将异常给处理掉了。`throws`的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。  

### 手动抛出异常（throw）

Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出， 也可根据需要使用人工创建并抛出。

#### 使用

1. 首先要生成异常类对象， 然后通过throw语句实现抛出操作(提交给Java运行环境)。

   ```java
   IOException e = new IOException();
   throw e;
   ```

2. 可以抛出的异常必须是Throwable或其子类的实例。 下面的语句在编译时将会产生语法错误：
   `throw new String("want to throw");`



## 开发中如何选择使用try-catch-finally 还是使用throws？

1. 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。

2. 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。

## 自定义异常

### 如何自定义异常类？

1. 继承于现有的异常结构：RuntimeException 、Exception

2. 提供全局常量：serialVersionUID

3. 提供重载的构造器

### 注意事项

1. 一般地，用户自定义异常类都是RuntimeException的子类。
2. 自定义异常类通常需要编写几个重载的构造器。
3. 自定义异常需要提供serialVersionUID

4. 自定义的异常通过throw抛出。
5. 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。

### 示例

```java
public class MyException extends Exception{
   
   static final long serialVersionUID = -7034897193246939L;
   
   public MyException(){
      
   }
   
   public MyException(String msg){
      super(msg);
   }
}
```

#### 抛出自定义异常

`throw new MyException("出现了自定义异常");`



## 小结

<img src="https://gitee.com/koala010/typora/raw/master/img/20200726214319.png" alt="image-20200606111634945" style="zoom:50%;" />