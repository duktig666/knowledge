# MySQL的锁

本篇文章提到的锁，如果没有特别说明，默认指InnoDB的锁。

## MySQL加锁的目的是什么？

数据库的锁是为了解决事务的隔离性问题，为了让事务之间相互不影响，每个事务进行操作的时候都会对数据加上一把特有的锁，防止其他事务同时操作数据。

## MySQL的锁是基于什么实现的？

数据库里面的锁是基于索引实现的，在Innodb中我们的锁都是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）。

## 解决并发事务问题的方式

### 写写情况

任何一种隔离级别都不允许出现脏写现象，是通过加锁来实现的。锁结构两个比较重要的属性：

- trx信息：表示锁结构与哪个事务有关。
- is_waiting：表示当前事务是否在等待。

锁获取的状态：

- 获取锁成功：内存中生成了对应的锁结构，而且is_waiting的值为false。（除了隐式锁）
- 获取锁失败：内存中生成了对应的锁结构，而且is_waiting的值为true，事务需要等待。
- 不加锁：内存中没有生成锁结构，可以直接操作。（不包括隐式锁）

释放锁：释放锁，发现还有事务等待锁，修改对应锁结构is_waiting的值为true。

### 读写或写读情况

**方案1：读操作使用MVCC，写操作加锁**

MVCC通过ReadView找到符合条件的记录版本，**查询语句只能读到在生成ReadView之前已经提交的事务所做的更改**，在生成ReadView之前未提交或者之后才开启的事务所做的修改操作是看不到的。

写操作针对最新版本的记录，读记录的历史版本和改动记录的最新版本是不冲突的。

方案2：读写操作都加锁

### 一致性读

事务利用MVCC方式，读写操作不冲突称之为一致性读。

一致性读并不会对表中的任何记录进行加锁，其他事务可以自由对表中的记录进行改动。

### 锁定读

对记录加S锁：`SELECT ……  LOCK IN SHARE MODE`

对记录加X锁：`SELECT …… FOR UPDATE`

### 写操作

#### DELETE

1. 先在B+树中定位到记录，然后获取X锁，最后执行 delete mark 操作（添加删除标记）

#### UPDATE

- **未修改主键值，并且被更新的列所占用的存储空间未改变**：定位到B+树的记录位置，获取X锁，修改值。
- **未修改主键值，并且被更新的列至少有一个所占用的存储空间改变**：定位到B+树的记录位置，获取X锁，彻底删除记录（而不是delete mark），然后再新增记录。
- **修改记录的键值**：定位到B+树的记录位置，获取X锁，执行DELETE操作，然后再执行INSERT操作。

#### INSERT

一般情况下，新插入记录受隐式锁保护，不生成对应的锁结构。

## 锁的内存结构

### 基本介绍

“锁”本质上是内存中的结构，在事务执行之前是没有锁的（也就是说一开始是没有锁结构与记录进行关联的）。

当一个事务相对这条记录进行改动时，首先会看内存中有没有与这条记录相关联的锁结构；如果没有，就在内存中生成一个锁结构与记录相关联。

锁结构有很多信息，**比较重要的属性如下**：

- `trx`信息：表示这个锁结构与哪个事务相关联。
- `is_waiting`：表示当前事务是否在等待。
- `type`：表示锁的类型。

### **锁结构的变化：**

1. 事务T1修改记录前，生成锁结构（因为之前没有别的事务为这条记录加锁）：`trx:T1  is_waiting:false`。称这个操作为加锁成功。
2. 事务T1提交前，事务T2也想修改这条记录。在内存中发现有一个锁记录，T2也生成一个所记录`trx:T2  is_waiting:true`，表示需要等待，称为加锁失败。
3. 事务T1提交后，就会把它生成的锁机构释放掉，然后检测一次是否还有与这条记录相关联的锁结构。发现事务T2在等待获取锁，所以把事务T2的 `is_waiting:true` 改为 `false`，然后把该事物对应的线程唤醒，让T2继续执行。此时T2就获取到锁了。

### 哪些记录可以放在一个锁结构中？

上文提到：对一条记录加锁的本质是在内存中创建一个锁结构与之关联（隐式锁除外）。

但是一个事务对多条记录加锁，是不是要创建多个锁结构？如果加锁记录太多，岂不是造成了内存占用太大。

所以，如果符合以下条件，这些记录的锁可以放到一个锁结构中：

1. 在同一个事务中进行加锁操作
2. 被加锁的记录在同一个页面中
3. 加锁的类型是一样的
4. 等待状态是一样的

### 锁结构详解

<img src="https://cos.duktig.cn/typora/202203022325296.jpg" alt="271a340123d72197fd99faa32c1190b" style="zoom:67%;" />

- 锁所在事务信息和索引信息 在内存结构中是一个指针，不会占用太大空间
- 表锁/行锁信息：
  - 表锁记载着这是对哪个表加的锁
  - 行锁记载下面3个重要信息：
    - Space ID：记录所在的表空间
    - Page Number：记录所在的页号
    - n_bits：对于行锁来说，一条记录对用一个比特。用以区分哪些记录被加了行锁，n_bits为了让页面插入新记录时不至于重新分配锁结构，一般来说会比页面记录多一些。
- type_mode：是一个32比特的数，分为 lock_mode、lock_type、rec_lock_type 三部分。![91bb6399110c93e44260472028a69fc](https://cos.duktig.cn/typora/202203022332392.jpg)
  - lock_mode（锁模式）占用4比特，具体如下：
    - LOCK_IS（十进制0）
    - LOCK_IX（十进制1）
    - LOCK_S（十进制2）
    - LOCK_X（十进制3）
    - LOCK_AUTO_INC（十进制4）
  - lock_type（锁类型）占5~8位，现阶段只用了第5位和第6位
    - LOCK_TABLE（十进制16）：第5位为1，表级锁
    - LOCK_REC（十进制32）：第6位为1，行级锁
  - rec_lock_type（行锁的具体类型），只有在lock_type值为LOCK_REC时，才会细分更多的类型
    - LOCK_ORDINARY（十进制0）：表示next-key锁（临键锁）
    - LOCK_GAP（十进制512）：第10比特位为1，表示gap（间隙）锁
    - LOCK_REC_NOT_GAP（十进制1024）：第11比特位为1，表示记录锁
    - LOCK_INSERT_INTENTION（十进制2048）：第12比特位为1，表示插入意向锁
    - 其他类型
    - LOCK_WAIT（十进制256）：第9比特位为1，is_waiting表示为true。
  - 一堆比特位：每个比特位，表示锁结构对应一条记录。



## 锁的分类

基于锁的属性分类：共享锁、排他锁。

基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁、自增锁。

基于锁的状态分类：意向共享锁、意向排它锁。

基于加锁的态度分类：悲观锁、乐观锁。

## 共享锁和排它锁（读写锁）

### 共享锁

**共享锁**又称读锁，简称S锁；当一个事务为数据加上读锁之后，**其他事务只能对该数据加读锁，而不能对数据加写锁**，直到所有的读锁释放之后其他事务才能对其进行加持写锁。

共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。

![共享锁](https://cos.duktig.cn/typora/202111051714836.png)

### 排它锁

排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。

排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。

![排它锁](https://cos.duktig.cn/typora/202111051729003.png)

## 读写意向锁

意向锁也是表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。分为如下情况：

- 某条记录加S锁时，需要先在表级别加IS锁。
- 某条记录加X锁时，需要先在表级别加IX锁。
- 加表级别S锁时，此表不能加有IX锁。
- 加表级别X锁时，此表不能加有IS、IX锁。

意向锁是为了，在加表级别S、X锁时，快速判断表中记录是否被上锁，避免遍历该表的所有记录。

## 表锁

### 什么是表锁？

**表锁**是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；

表锁由 MySQL Server 实现，一般在执行 DDL 语句时会对整个表进行加锁，比如说 ALTER TABLE 等操作。

表锁的特点： **粒度大，加锁简单，容易冲突**。

### 显式加表锁

在执行 SQL 语句时，也可以明确指定对某个表进行加锁：

```sql
# 分为读锁和写锁
lock table user read(write); 
# 成功
select * from user where id = 100;
# 失败，未提前获取该 role的读表锁
select * from role where id = 100; 
# 失败，未提前获得user的写表锁
update user  set name = 'Tom' where id = 100; 
# 显示释放表锁
unlock tables; 
```

表锁使用的是一次性锁技术，也就是说，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。

### **什么时候释放表锁**？

- 使用 `unlock tables` 显示释放锁
- 会话持有其他表锁时执行 `lock table` 语句会释放会话之前持有的锁
- 会话持有其他表锁时执行 `start transaction` 或者 `begin` 开启事务时，也会释放之前持有的锁。

### 表级别的S锁、X锁

表级别的锁一般用在执行 `ALTER TABLE` 或 `DROP TABLE`的DDL语句时，然后再执行增删改查时会阻塞。

### 表级别的IS锁、IX锁

参看上述的读写意向锁

### 表级别的AUTO-INC锁

AUTO-INC 锁又叫自增锁（一般简写成 AI 锁），是一种表锁，当表中有自增列（AUTO_INCREMENT）时出现。

主要实现方式有两种：

1. **采用AUTO-INC锁**。执行插入语句时，加一个表级别的AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT列分配递增的值，插入执行完毕，锁释放。
2. **采用一种轻量级的锁**（mutex，MySQL 从 5.1.22 版本开始引入）。生成自增值后释放，而不是要等插入完成才释放锁。

`innodb_autoinc_lock_mode`来控制使用哪种锁：

- 值为0，一律使用AUTO-INC锁
- 值为1，插入数量确定使用轻量级锁，不确定使用AUTO-INC锁
- 值为2，一律使用轻量级锁（不同事务自增列值交叉，主从复制不安全）

**注意事项：**

当插入表中有自增列时，数据库需要自动生成自增值，它会**先为该表加 AUTOINC 表锁，阻塞其他事务的插入操作，这样保证生成的自增值肯定是唯一的**。

AUTOINC 锁具有如下特点：

- AUTO_INC 锁互不兼容，也就是说同一张表同时只允许有一个自增锁；
- 自增值一旦分配了就会 +1，如果**事务回滚，自增值也不会减回去**，所以自增值可能会出现中断的情况。

## 行锁

### 什么是行锁？

行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；

不同存储引擎的行锁实现不同。

特点：**粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高**；

### 行锁的原理

行锁的原理和索引有关。

InnoDB 是聚簇索引，也就是 B+树的叶节点既存储了主键索引也存储了数据行。而 InnoDB 的二级索引的叶节点存储的则是主键值，所以通过二级索引查询数据时，还需要拿对应的主键去聚簇索引中再次进行查询。

**单行记录行锁原理**

下面以两条 SQL 的执行为例，讲解一下 InnoDB 对于单行数据的加锁原理。

```sql
# 聚簇索引执行修改
update user set age = 10 where id = 49;
# 二级索引执行修改
update user set age = 10 where name = 'Tom';
```

第一条 SQL 使用主键索引来查询，则只需要在 id = 49 这个主键索引上加上写锁；

第二条 SQL 则使用二级索引来查询，则首先在 name = Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id = 49 这个主键索引上加写锁。

**多行记录行锁原理**

```sql
update user set age = 10 where id > 49;
```

MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新改行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止。

当然这中间还有很多的优化，就不细细阐述了。

### 行锁的类型

根据锁的粒度可以把锁细分为表锁和行锁，行锁根据场景的不同又可以进一步细分，依次为 Next-Key Lock，Gap Lock 间隙锁，Record Lock 记录锁和插入意向 GAP 锁。

不同的锁锁定的位置是不同的，比如说记录锁只锁住对应的记录，而间隙锁锁住记录和记录之间的间隔，Next-Key Lock 则所属记录和记录之前的间隙。

![行锁的范围](https://cos.duktig.cn/typora/202111051714635.png)

### 记录锁（Record Lock）

**记录锁**：事务在加锁后锁住的只是表的某一条记录。(官方命名LOCK_REC_NOT_GAP)

**触发条件：**

- 精准条件命中，并且命中的条件字段是唯一索引。
  - **例如：**`update user_info set name=’张三’ where id=1`	 ，这里的id是唯一索引。
- 当 SQL 语句无法使用索引时，会进行全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁，再由 MySQL Server 层进行过滤。但是，在 MySQL Server 层进行过滤的时候，如果发现不满足 WHERE 条件，会释放对应记录的锁。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。

所以更新操作必须要根据索引进行操作，没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，还会极大的降低了数据库的并发性能。

**记录锁的作用：**加了记录锁之后数据可以**避免数据在查询的时候被修改的重复读问题**，**也避免了在修改的事务未提交前被其他事务读取的脏读问题**。

### **间隙锁（Gap Lock）**

**间隙锁**：在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循**左开右闭**原则。

比如下面的表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）

![间隙锁](https://cos.duktig.cn/typora/202111051721479.png)

**触发条件：**范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。

**例如**：对应上图的表执行 `select * from user_info where id>1 and id<4` (这里的id是唯一索引) ，这个SQL查询不到对应的记录，那么此时会使用间隙锁。

注意事项：

- `Infimum`：表示页面最小记录
- `Supremum`：表示页面最大记录

**间隙锁作用**：**防止幻读问题**。

### **临键锁(Next-Key Lock)**

临键锁：**是INNODB的行锁默认算法**，总结来说它就是记录锁和间隙锁的组合，**临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住**。

**例如：**下面表的数据执行 `select * from user_info where id>1 and id<=13 for update ;`

会锁住ID为 1,5,10的记录；同时会锁住，1至5,5至10,10至15的区间。



![img](https://pic1.zhimg.com/80/v2-8c9555f753fbab98c71760ddba9e5068_720w.png)



**触发条件：**范围查询并命中，查询命中了索引。

**临键锁的作用：**结合记录锁和间隙锁的特性，**临键锁避免了在范围查询时出现脏读、重复读、幻读问题**。加了临键锁之后，在范围区间内数据不允许被修改和插入。

### 插入意向锁（LOCK_INSERT_INTENTION）

插入意向锁是一种特殊的间隙锁（Insert Intention Lock）表示插入的意向，只有在 INSERT 的时候才会有这个锁。

一个事务插入一条记录，需要判断插入位置是否被别的事务加了gap锁（包含next-key锁）。如果有的话，插入操作需要等待，直到加gap锁的事务提交。

### 隐式锁

一般执行Insert不需要在内存中生成锁结构（当然如果插入的间隙被其他事务加了gap锁，那么本次Insert操作会阻塞，当前事务会在间隙插入意向锁）。

但这样可能会出现问题。举例，先插入一条记录（无关联锁结构），然后如下情况：

- 立即使用`SELECT ……  LOCK IN SHARE MODE` 或 `SELECT …… FOR UPDATE`，进行锁定读，获取锁。如果允许，那么出现脏读怎么办？
- 立即修改这条记录（获取锁），怎么办？

这些情况下，事务id要起作用了

- 对于聚簇索引：trx_id是一个隐藏列，记录最后改动的事务id。新插入记录，trx_id为当前事务的id，如果想加锁，会看trx_id是否是活跃事务。如果不是，正常获取；如果是，帮助当前事务建立X锁的锁结构，is_writing为false。然后自己也创建一个锁结构，is_writing为true，进入等待状态。
- 对于二级索引： 二级索引页面的Page Header的PAGE_MAX_TRX_ID记录改动最大的事务id。如果PAGE_MAX_TRX_ID小于当前最小活跃事务id，表明已提交，否则需要定位的聚簇索引，然后执行上述的操作。

所以，一个事务新插入记录可以不显示加锁，这个事务id相当于加了一个隐式锁。别的事务加锁，由于隐式锁存在，会给当前事务生成一个锁结构，然后给自己也生成锁结构，并且进入等待状态。

**隐式锁作用：延迟生成锁结构。如果事务执行不需要获取与该隐式锁相冲突的锁，可以避免建立锁结构。**

特殊情况：

1. 插入时遇到重复键会报错，但在报错前会加锁
   1. 主键（聚簇索引）重复，读提交下加记录锁，可重复读下加临键锁
   2. 二级唯一索引重复，加临键锁。
2. 外键检查
   1. 待查记录在外键表中可以找到，父表给该记录加记录锁
   2. 找不到时，读提交不加锁，可重复读加gap锁。



## 死锁问题

T1和T2都在等待对方先释放掉与自己需要的锁相冲突的锁，因此T1和T2都不能继续执行，此时就称发生了死锁。

例子：

| 发生时间编号 | T1                                                           | T2                                                           |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1            | BEGIN;                                                       |                                                              |
| 2            |                                                              | BEGIN;                                                       |
| 3            | SELECT * FROM hero WHERE number=1 FOR UPDATE;                |                                                              |
| 4            |                                                              | SELECT * FROM hero WHERE number=3 FOR UPDATE;                |
| 5            | SELECT * FROM hero WHERE number=3 FOR UPDATE; <br />（此操作阻塞） |                                                              |
| 6            |                                                              | SELECT * FROM hero WHERE number=1 FOR UPDATE; <br />（死锁发生，记录日志，服务器回滚一个事务） |
|              |                                                              |                                                              |

**死锁检测机制：**检测死锁，会选择一个较小的事务（增删改记录条数较少），并向客户端发送一条报错信息。

可通过语句 `SELECT ENGINE INNODB STATUS` 查看最近一次死锁发生的信息。

## 参看：

- 《MySQL是怎样运行的》
- [把MySQL中的各种锁及其原理都画出来](https://zhuanlan.zhihu.com/p/149228460)
- [Mysql里的锁(排它锁、共享锁、行锁、表锁、间隙锁、临键锁、意向锁)](https://zhuanlan.zhihu.com/p/213814000)
- [什么是悲观锁和乐观锁](https://zhuanlan.zhihu.com/p/31537871)
- [MySQL锁总结](https://zhuanlan.zhihu.com/p/29150809)