

# 二叉树

二叉树节点的定义：

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 二叉树的重要性

先刷⼆叉树的题⽬，先刷⼆叉树的题⽬，先刷⼆叉树的题⽬，因为很多经典算法，以及我们前⽂讲过的所有**回溯、动归、分治**算法，其实都是树的问题，⽽树的问题就永远逃不开树的递归遍历框架这⼏⾏破代码：

```java
/* ⼆叉树遍历框架 */
void traverse(TreeNode root) { 
    // 前序遍历 
    traverse(root.left) 
    // 中序遍历 
    traverse(root.right) 
    // 后序遍历 
} 
```

经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？

**快速排序就是个⼆叉树的前序遍历，归并排序就是个⼆叉树的后序遍历**。

快速排序的逻辑是，若要对 nums[lo..hi] 进⾏排序，我们先找⼀个分界点 p，通过交换元素使得nums[lo..p-1] 都⼩于等于 nums[p]，且 nums[p+1..hi] 都⼤于nums[p]，然后递归地去nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。

快速排序的代码框架如下：

```java
void sort(int[] nums, int lo, int hi) { 
    /****** 前序遍历位置 ******/ 
    // 通过交换元素构建分界点 p 
    int p = partition(nums, lo, hi); 
    /************************/ 
 
    sort(nums, lo, p - 1); 
    sort(nums, p + 1, hi); 
}
```

先构造分界点，然后去左右⼦数组构造分界点，你看这不就是⼀个⼆叉树的前序遍历吗？

再说说归并排序的逻辑，若要对 nums[lo..hi] 进⾏排序，我们先对nums[lo..mid] 排序，再对nums[mid+1..hi] 排序，最后把这两个有序的⼦数组合并，整个数组就排好序了。

归并排序的代码框架如下：

```java
void sort(int[] nums, int lo, int hi) { 
    int mid = (lo + hi) / 2; 
    sort(nums, lo, mid); 
    sort(nums, mid + 1, hi); 
 
    /****** 后序遍历位置 ******/ 
    // 合并两个排好序的⼦数组 
    merge(nums, lo, mid, hi); 
    /************************/ 
} 
```

先对左右⼦数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是⼆叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。

如果你⼀眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是⼿到擒来，从框架慢慢扩展就能写出算法了。

旨在说明，⼆叉树的算法思想的运⽤⼴泛，甚⾄可以说，只要涉及递归，都可以抽象成⼆叉树的问题。

## 写递归算法的秘诀

**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节**。

⽤⼀个具体的例⼦来说，⽐如说让你计算⼀棵⼆叉树共有⼏个节点：

```java
// 定义：count(root) 返回以 root 为根的树有多少节点
int count(TreeNode root) { 
    // base case 
    if (root == null) return 0; 
    // ⾃⼰加上⼦树的节点数就是整棵树的节点数 
    return 1 + count(root.left) + count(root.right); 
} 
```

这个问题⾮常简单，⼤家应该都会写这段代码，root 本身就是⼀个节点，加上左右⼦树的节点数就是以root 为根的树的节点总数。

左右⼦树的节点数怎么算？其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义，递归调⽤ count 函数即可算出来。

**写树相关的算法，简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调⽤⼦节点**，递归调⽤会让孩⼦节点做相同的事情。

所谓「该做什么」就是让你想清楚写什么代码能够实现题⽬想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。

## 翻转二叉树

```
翻转前：
     4 
   /   \ 
  2     7 
 / \   / \ 
1   3 6   9
翻转后（镜像翻转）：
     4 
   /   \ 
  7     2 
 / \   / \ 
9   6 3   1

```

通过观察，**我们发现只要把⼆叉树上的每⼀个节点的左右⼦节点进⾏交换，最后的结果就是完全翻转之后的⼆叉树**。

```java
// 将整棵树的节点翻转
TreeNode invertTree(TreeNode root) { 
    // base case 
    if (root == null) { 
        return null; 
    } 
 
    /**** 前序遍历位置 ****/ 
    // root 节点需要交换它的左右⼦节点 
    TreeNode tmp = root.left; 
    root.left = root.right; 
    root.right = tmp; 
 
    // 让左右⼦节点继续翻转它们的⼦节点 
    invertTree(root.left); 
    invertTree(root.right); 
     
    return root; 
} 
```

这道题⽬⽐较简单，关键思路在于我们发现翻转整棵树就是交换每个节点的左右⼦节点，于是我们把交换左右⼦节点的代码放在了前序遍历的位置。

值得⼀提的是，如果把交换左右⼦节点的代码复制粘贴到后序遍历的位置也是可以的，但是直接放到中序遍历的位置是不⾏的，请你想⼀想为什么？这个应该不难想到，我会把答案置顶在公众号留⾔区。

⾸先讲这道题⽬是想告诉你，**⼆叉树题⽬的⼀个难点就是，如何把题⽬的要求细化成每个节点需要做的事情**。

## 填充每个节点的下一个右侧节点指针

> [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)
>
> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> ```java
> struct Node {
> int val;
> Node *left;
> Node *right;
> Node *next;
> }
> ```
>
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。

题⽬的意思就是把⼆叉树的每⼀层节点都⽤ next 指针连接起来：

![image-20211208174402701](https://cos.duktig.cn/typora/202112081744230.png)

⽽且题⽬说了，输⼊是⼀棵「完美⼆叉树」，形象地说整棵⼆叉树是⼀个正三⻆形，除了最右侧的节点 next指针会指向 null，其他节点的右侧⼀定有相邻的节点。

我们可以模仿上⼀道题，写出如下代码：

```java
Node connect(Node root) { 
    if (root == null || root.left == null) { 
        return root; 
    } 
 
    root.left.next = root.right; 
 
    connect(root.left); 
    connect(root.right); 
 
    return root; 
} 
```

这样其实有很⼤问题：节点 5 和节点 6 不属于同⼀个⽗节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。

回想刚才说的，**⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情**，但是如果只依赖⼀个节点的话，肯定是没办法连接「跨⽗节点」的两个相邻节点的。

那么，我们的做法就是增加函数参数，⼀个节点做不到，我们就给他安排两个节点，「将每⼀层⼆叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」。

```java
// 主函数
Node connect(Node root) { 
    if (root == null) return null; 
    connectTwoNode(root.left, root.right); 
    return root; 
}

// 辅助函数
void connectTwoNode(Node node1, Node node2) { 
    if (node1 == null || node2 == null) { 
        return; 
    } 
    /* 前序遍历位置 */ 
    // 将传⼊的两个节点连接 
    node1.next = node2; 
     
    // 连接相同⽗节点的两个⼦节点 
    connectTwoNode(node1.left, node1.right); 
    connectTwoNode(node2.left, node2.right); 
    // 连接跨越⽗节点的两个⼦节点 
    connectTwoNode(node1.right, node2.left); 
} 
```

这样，connectTwoNode 函数不断递归，可以⽆死⻆覆盖整棵⼆叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，这道题就解决了。

## 将⼆叉树展开为链表

> [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给 flatten 函数输⼊⼀个节点 root，那么以 root 为根的⼆叉树就会被拉平为⼀条链表。

我们再梳理⼀下，如何按题⽬要求把⼀棵树拉平成⼀条链表？很简单，以下流程：

1、将 root 的左⼦树和右⼦树拉平。

2、将 root 的右⼦树接到左⼦树下⽅，然后将整个左⼦树作为右⼦树。

![image-20211208204424271](https://cos.duktig.cn/typora/202112082044859.png)

上⾯三步看起来最难的应该是第⼀步对吧，如何把 root 的左右⼦树拉平？其实很简单，按照 flatten 函数的定义，对 root 的左右⼦树递归调⽤ flatten 函数即可：

```java
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) { 
    // base case 
    if (root == null) return; 
     
    flatten(root.left); 
    flatten(root.right); 
 
    /* 后序遍历位置 */ 
    // 1、左右⼦树已经被拉平成⼀条链表 
    TreeNode left = root.left; 
    TreeNode right = root.right; 
     
    // 2、将左⼦树作为右⼦树 
    root.left = null; 
    root.right = left; 
 
    // 3、将原先的右⼦树接到当前右⼦树的末端 
    TreeNode p = root; 
    while (p.right != null) { 
        p = p.right; 
    } 
    p.right = right; 
}   
```

## 最大二叉树

**把题⽬的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就⾏了**，我们千万不要跳进递归的细节⾥。

> [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)
>
> 给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：
>
> 1. 二叉树的根是数组 nums 中的最大元素。
> 2. 左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
> 3. 右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
>
> 返回有给定数组 nums 构建的 最大二叉树 。

按照我们刚才说的，先明确根节点做什么？**对于构造⼆叉树的问题，根节点要做的就是把想办法把⾃⼰构造出来**。

我们肯定要遍历数组把找到最⼤值 maxVal，把根节点 root 做出来，然后对 maxVal 左边的数组和右边的数组进⾏递归调⽤，作为 root 的左右⼦树。

按照题⽬给出的例⼦，输⼊的数组为 [3,2,1,6,0,5]，对于整棵树的根节点来说，其实在做这件事，伪代码如下：

```
TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) { 
    // 找到数组中的最⼤值 
    TreeNode root = new TreeNode(6); 
    // 递归调⽤构造左右⼦树 
    root.left = constructMaximumBinaryTree([3,2,1]); 
    root.right = constructMaximumBinaryTree([0,5]); 
    return root; 
} 
```

**对于每个根节点，只需要找到当前 nums 中的最⼤值和对应的索引，然后递归调⽤左右数组构造左右⼦树即可**。

```java
/**
 * 主函数
 */
public TreeNode constructMaximumBinaryTree(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

/**
 * 将 nums[low..high] 构造成符合条件的树，返回根节点
 *
 * @param nums 待构建二叉树的数组
 * @param low  子树的左端数组下标
 * @param high 子树的右端数组下标
 * @return 构造好子树的根节点
 */
private TreeNode build(int[] nums, int low, int high) {
    // 递归的终止条件
    if (low > high) {
        return null;
    }

    // 找到数组中的最大值和对应的索引
    int index = - 1, maxVal = Integer.MIN_VALUE;
    for (int i = low; i <= high; i++) {
        if (maxVal < nums[i]) {
            maxVal = nums[i];
            index = i;
        }
    }

    // 最大值构建根节点
    TreeNode root = new TreeNode(maxVal);
    // 递归构建左右子树
    root.left = build(nums, low, index - 1);
    root.right = build(nums, index + 1, high);

    return root;
}
```

## 通过前序和中序遍历结果构造二叉树

> [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
>
> 给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

 **我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右⼦树即可**。

遍历顺序差异，导致了 preorder 和 inorder 数组中的元素分布有如下特点：

![image-20211209140334133](https://cos.duktig.cn/typora/202112091403972.png)

找到根节点是很简单的，前序遍历的第⼀个值 preorder[0] 就是根节点的值，关键在于如何通过根节点的值，将 preorder 和 postorder 数组划分成两半，构造根节点的左右⼦树？

```java
/** 主函数 */
TreeNode buildTree(int[] preorder, int[] inorder) { 
    return build(preorder, 0, preorder.length - 1, 
                 inorder, 0, inorder.length - 1); 
} 
 
/**  
   若前序遍历数组为 preorder[preStart..preEnd]， 
   中序遍历数组为 inorder[inStart..inEnd]， 
   构造⼆叉树，返回该⼆叉树的根节点  
*/
TreeNode build(int[] preorder, int preStart, int preEnd,  
               int[] inorder, int inStart, int inEnd) { 
    // root 节点对应的值就是前序遍历数组的第⼀个元素 
    int rootVal = preorder[preStart]; 
    // rootVal 在中序遍历数组中的索引 
    int index = 0; 
    for (int i = inStart; i <= inEnd; i++) { 
        if (inorder[i] == rootVal) { 
            index = i; 
            break; 
        } 
    } 
 
    TreeNode root = new TreeNode(rootVal); 
    // 递归构造左右⼦树 
    root.left = build(preorder, ?, ?, inorder, ?, ?); 
 
    root.right = build(preorder, ?, ?, inorder, ?, ?);
    
    return root; 
} 
```

对于代码中的 rootVal 和 index 变量，就是下图这种情况：

![image-20211209140103381](https://cos.duktig.cn/typora/202112091401506.png)

现在我们来看图做填空题，下⾯这⼏个问号处应该填什么：

```java
root.left = build(preorder, ?, ?,inorder, ?, ?); 
root.right = build(preorder, ?, ?, inorder, ?, ?); 
```

对于左右⼦树对应的 inorder 数组的起始索引和终⽌索引⽐较容易确定：

![image-20211209140941940](https://cos.duktig.cn/typora/202112091409909.png)

对于 preorder 数组呢？如何确定左右数组对应的起始索引和终⽌索引？

这个可以通过左⼦树的节点数推导出来，假设左⼦树的节点数为 leftSize，那么 preorder 数组上的索引情况是这样的：

![image-20211209141131891](https://cos.duktig.cn/typora/202112091411900.png)

```java
int leftSize = index - inStart; 
 
root.left = build(preorder, preStart + 1, preStart + leftSize, 
                  inorder, inStart, index - 1); 
 
root.right = build(preorder, preStart + leftSize + 1, preEnd, 
                   inorder, index + 1, inEnd); 
```

完整代码如下：

```java
/**
 * 主函数
 */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

/**
 * 若前序遍历数组为 preorder[preStart..preEnd]，
 * 中序遍历数组为 inorder[inStart..inEnd]，
 * 构造⼆叉树，返回该⼆叉树的根节点
 */
private TreeNode build(int[] preorder, int preStart, int preEnd,
                       int[] inorder, int inStart, int inEnd) {
    // 递归终止条件
    if (preStart > preEnd) {
        return null;
    }

    // root 节点对应的值就是前序遍历数组的第⼀个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    // 根节点左边有几个元素
    int leftSize = index - inStart;

    // 先构造出当前根节点
    TreeNode root = new TreeNode(rootVal);

    // 递归构造左右⼦树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
            inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
            inorder, index + 1, inEnd);

    return root;
}
```



## 通过后序和中序遍历结果构造⼆叉树

>  [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
>
>  根据一棵树的中序遍历与后序遍历构造二叉树。

![image-20211209143258007](https://cos.duktig.cn/typora/202112091433423.png)

这道题和上⼀题的关键区别是，后序遍历和前序遍历相反，根节点对应的值为 postorder 的最后⼀个元素。

现在 postoder 和 inorder 对应的状态如下：

![image-20211209143400312](https://cos.duktig.cn/typora/202112091434857.png)

```java
/**
 * 主函数
 */
public TreeNode buildTree(int[] inorder, int[] postorder) {
    return build(inorder, 0, inorder.length - 1,
            postorder, 0, postorder.length - 1);
}

/**
 * 中序遍历数组为 inorder[inStart..inEnd]，
 * 后序遍历数组为 postorder[postStart..postEnd]，
 * 构造⼆叉树，返回该⼆叉树的根节点
 */
private TreeNode build(int[] inorder, int inStart, int inEnd,
                       int[] postorder, int postStart, int postEnd) {
    // 递归终止条件
    if (inStart > inEnd) {
        return null;
    }
    
    // root 节点对应的值就是后序遍历数组的最后⼀个元素
    int rootVal = postorder[postEnd];
    
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    
    // 左⼦树的节点个数
    int leftSize = index - inStart;
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右⼦树
    root.left = build(inorder, inStart, index - 1,
            postorder, postStart, postStart + leftSize - 1);

    root.right = build(inorder, index + 1, inEnd,
            postorder, postStart + leftSize, postEnd - 1);
    
    return root;
}
```

有了前⼀题的铺垫，这道题很快就解决了，⽆⾮就是 rootVal 变成了最后⼀个元素，再改改递归函数的参数⽽已，只要明⽩⼆叉树的特性，也不难写出来。

最后呼应下前⽂，**做⼆叉树的问题，关键是把题⽬的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就⾏了**。

## 寻找重复的子树

> [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)
>
> 给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。
>
> 两棵树重复是指它们具有相同的结构以及相同的结点值。
>
> 示例 1：
>
> ```
>   1
>  / \
> 2   3
> /   / \
> 4   2   4
>  /
> 4
> ```
>
> 下面是两个重复的子树：
>
> 2
> /
> 4
> 和
>
> 4
> 因此，你需要以列表的形式返回上述重复子树的根结点。

**如何判断我们应该用前序还是中序还是后序遍历的框架**？

**根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了**。

这题咋做呢？**还是老套路，先思考，对于某一个节点，它应该做什么**。

如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点**：

**1、以我为根的这棵二叉树（子树）长啥样**？

**2、以其他节点为根的子树都长啥样**？

我得知道自己长啥样，还得知道别人长啥样，然后才能知道有没有人跟我重复，对不对？

好，那我们一个一个来解决，先来思考，**我如何才能知道以自己为根的二叉树长啥样**？

其实看到这个问题，就可以判断本题要使用「后序遍历」框架来解决。

为什么？很简单呀，我要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子？

如果你还绕不过来，我再来举个非常简单的例子：计算一棵二叉树有多少个节点。这个代码应该会写吧：

```java
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 先算出左右子树有多少节点
    int left = count(root.left);
    int right = count(root.right);
    /* 后序遍历代码位置 */
    // 加上自己，就是整棵二叉树的节点数
    int res = left + right + 1;
    return res;
}
```

这不就是标准的后序遍历框架嘛，和我们本题在思路上没啥区别对吧。

现在，明确了要用后序遍历，那应该 **怎么描述一棵二叉树的模样呢**？

二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。

所以，我们可以通过拼接字符串的方式把二叉树序列化，看下代码：

```java
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + "," + right + "," + root.val;
    return subTree;
}
```

我们用非数字的特殊符`#`表示空指针，并且用字符`,`分隔每个二叉树节点值，这属于序列化二叉树的套路了。

注意我们`subTree`是按照左子树、右子树、根节点这样的顺序拼接字符串，也就是后序遍历顺序。你完全可以按照前序或者中序的顺序拼接字符串，因为这里只是为了描述一棵二叉树的样子，什么顺序不重要。

**这样，我们第一个问题就解决了，对于每个节点，递归函数中的`subTree`变量就可以描述以该节点为根的二叉树**。

**现在我们解决第二个问题，我知道了自己长啥样，怎么知道别人长啥样**？这样我才能知道有没有其他子树跟我重复对吧。

这很简单呀，我们借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了么？

初步思路可以使用`HashSet`记录子树，代码如下：

```java
// 记录所有子树
HashSet<String> memo = new HashSet<>();
// 记录重复的子树根节点
List<TreeNode> res = new LinkedList<>();

String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    if (memo.contains(subTree)) {
        // 有人和我重复，把自己加入结果列表
        res.add(root);
    } else {
        // 暂时没人跟我重复，把自己加入集合
        memo.add(subTree);
    }
    return subTree;
}
```

但是呢，这有个问题，如果出现多棵重复的子树，结果集`res`中必然出现重复，而题目要求不希望出现重复。

为了解决这个问题，可以把`HashSet`升级成`HashMap`，额外记录每棵子树的出现次数：

```java
// 记录所有子树以及出现的次数
HashMap<String, Integer> memo = new HashMap<>();
// 记录重复的子树根节点
List<TreeNode> res = new LinkedList<>();

/* 主函数 */
List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    return res;
}

/* 辅助函数 */
String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    int freq = memo.getOrDefault(subTree, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加一
    memo.put(subTree, freq + 1);
    return subTree;
}
```

## 二叉树的序列化与反序列化

> 给你输入一棵二叉树的根节点 `root`，要求你实现如下一个类：
>
> ```java
> public class Codec {
> 
>  // 把一棵二叉树序列化成字符串
>  public String serialize(TreeNode root) {}
> 
>  // 把字符串反序列化成二叉树
>  public TreeNode deserialize(String data) {}
> }
> ```
>
> 我们可以用 `serialize` 方法将二叉树序列化成字符串，用 `deserialize` 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。

比如说输入如下这样一棵二叉树：

<img src="https://cos.duktig.cn/typora/202112161122197.png" alt="image-20211216112236780" style="zoom:50%;" />

`serialize` 方法也许会把它序列化成字符串 `2,1,#,6,3,#,#`，其中 `#` 表示 `null` 指针，那么把这个字符串再输入 `deserialize` 方法，依然可以还原出这棵二叉树。也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。

想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。**所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式**。

### 前序遍历

前序遍历 元素的顺序是怎样的？比如如下二叉树（`#` 代表空指针 null），可以直观看出前序遍历做的事情： 

![image-20211216112447460](https://cos.duktig.cn/typora/202112161124494.png)

至此，我们已经可以写出序列化函数 `serialize` 的代码了：

```java
String SEP = ",";
String NULL = "#";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

现在，思考一下如何写 `deserialize` 函数，将字符串反过来构造二叉树。

首先我们可以把字符串转化成列表：

```java
String data = "1,2,#,4,#,#,3,#,#,";
String[] nodes = data.split(",");
```

这样，`nodes` 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？

*PS：一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 `node` 列表包含空指针的信息，所以只使用 `node` 列表就可以还原二叉树。*

那么，反序列化过程也是一样，**先确定根节点 `root`，然后遵循前序遍历的规则，递归生成左右子树即可**：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    // 将字符串转化成列表
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    /****** 前序遍历位置 ******/
    // 列表最左侧就是根节点
    String first = nodes.removeFirst();
    if (first.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));
    /***********************/

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}
```

我们发现，根据树的递归性质，`nodes` 列表的第一个元素就是一棵树的根节点，所以只要将列表的第一个元素取出作为根节点，剩下的交给递归函数去解决即可。

### 后序遍历

明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 `serialize` 序列化方法，只需要稍微修改辅助方法即可：

```java
/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    serialize(root.left, sb);
    serialize(root.right, sb);

    /****** 后序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/
}
```

我们把对 `StringBuilder` 的拼接操作放到了后续遍历的位置，后序遍历导致结果的顺序发生变化：

![image-20211216140728214](https://cos.duktig.cn/typora/202112161407340.png)

关键的难点在于，如何实现后序遍历的 `deserialize` 方法呢？是不是也简单地将关键代码放到后序遍历的位置就行了呢？

**没这么简单，**回想刚才我们前序遍历方法中的 `deserialize` 方法，第一件事情在做什么？

**`deserialize` 方法首先寻找 `root` 节点的值，然后递归计算左右子节点**。那么我们这里也应该顺着这个基本思路走，后续遍历中，`root` 节点的值能不能找到？

`root` 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 `root`，然后递归调用生成 `root` 的左右子树。**注意，根据上图，从后往前在 `nodes` 列表中取元素，一定要先构造 `root.right` 子树，后构造 `root.left` 子树**。

看完整代码：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;
    // 从后往前取出元素
    String last = nodes.removeLast();
    if (last.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(last));
    // 先构造右子树，后构造左子树
    root.right = deserialize(nodes);
    root.left = deserialize(nodes);

    return root;
}
```

至此，后续遍历实现的序列化、反序列化方法也都实现了。

### 中序遍历

**中序遍历不能实现。只能完成序列化，不能完成反序列化，因为反序列化时需要先找到 root 节点，而中序遍历的 root节点在中间，无法直接确定。**

### 层序遍历

首先，先写出层级遍历二叉树的代码框架：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        System.out.println(root.val);
        /*****************/

        if (cur.left != null) {
            q.offer(cur.left);
        }

        if (cur.right != null) {
            q.offer(cur.right);
        }
    }
}
```

**上述代码是标准的二叉树层级遍历框架**，从上到下，从左到右打印每一层二叉树节点的值，可以看到，队列 `q` 中不会存在 null 指针。

不过我们在反序列化的过程中是需要记录空指针 null 的，所以可以把标准的层级遍历框架略作修改：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        if (cur == null) continue;
        System.out.println(root.val);
        /*****************/

        q.offer(cur.left);
        q.offer(cur.right);
    }
}
```

这样也可以完成层级遍历，只不过我们把对空指针的检验从「将元素加入队列」的时候改成了「从队列取出元素」的时候。

那么我们完全仿照这个框架即可写出序列化方法：

```java
String SEP = ",";
String NULL = "#";

/* 将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    if (root == null) return "";
    StringBuilder sb = new StringBuilder();
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        if (cur == null) {
            sb.append(NULL).append(SEP);
            continue;
        }
        sb.append(cur.val).append(SEP);
        /*****************/

        q.offer(cur.left);
        q.offer(cur.right);
    }

    return sb.toString();
}
```

层级遍历序列化得出的结果如下图：

![image-20211216141528085](https://cos.duktig.cn/typora/202112161415987.png)

可以看到，每一个非空节点都会对应两个子节点，**那么反序列化的思路也是用队列进行层级遍历，同时用索引 `i` 记录对应子节点的位置**：

```java
/* 将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    if (data.isEmpty()) return null;
    String[] nodes = data.split(SEP);
    // 第一个元素就是 root 的值
    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

    // 队列 q 记录父节点，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    for (int i = 1; i < nodes.length; ) {
        // 队列中存的都是父节点
        TreeNode parent = q.poll();
        // 父节点对应的左侧子节点的值
        String left = nodes[i++];
        if (!left.equals(NULL)) {
            parent.left = new TreeNode(Integer.parseInt(left));
            q.offer(parent.left);
        } else {
            parent.left = null;
        }
        // 父节点对应的右侧子节点的值
        String right = nodes[i++];
        if (!right.equals(NULL)) {
            parent.right = new TreeNode(Integer.parseInt(right));
            q.offer(parent.right);
        } else {
            parent.right = null;
        }
    }
    return root;
}
```

这段代码可以考验一下你的框架思维。仔细看一看 for 循环部分的代码，发现这不就是标准层级遍历的代码衍生出来的嘛：

```java
while (!q.isEmpty()) {
    TreeNode cur = q.poll();

    if (cur.left != null) {
        q.offer(cur.left);
    }

    if (cur.right != null) {
        q.offer(cur.right);
    }
}
```

只不过，标准的层级遍历在操作二叉树节点 `TreeNode`，而我们的函数在操作 `nodes[i]`，这也恰恰是反序列化的目的嘛。

### 完整代码

```java
/**
 * 前序遍历
 */
public static class preOrder {

    /** 元素分隔符 */
    final String SEP = ",";
    /** 空节点 */
    final String NULL = "#";

    /** 主函数，将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /** 辅助函数，将二叉树存入 StringBuilder */
    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        /* 前序遍历位置 */
        sb.append(root.val).append(SEP);

        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    /* 主函数，将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        // 将字符串转化成列表
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /* 辅助函数，通过 nodes 列表构造二叉树 */
    private TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }

        /* 前序遍历位置 */
        // 列表最左侧就是根节点
        String first = nodes.removeFirst();
        if (first.equals(NULL)) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(first));

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }

}


/**
 * 后序遍历
 */
public static class postOrder {

    /** 元素分隔符 */
    final String SEP = ",";
    /** 空节点 */
    final String NULL = "#";

    /** 主函数，将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /** 辅助函数，将二叉树存入 StringBuilder */
    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        serialize(root.left, sb);
        serialize(root.right, sb);

        /* 后序遍历位置 */
        sb.append(root.val).append(SEP);
    }

    /** 主函数，将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /** 辅助函数，通过 nodes 列表构造二叉树 */
    private TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        // 从后往前取出元素
        String last = nodes.removeLast();
        if (last.equals(NULL)) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(last));
        // 先构造右子树，后构造左子树
        root.right = deserialize(nodes);
        root.left = deserialize(nodes);

        return root;
    }

}


/**
 * 层序遍历
 */
public static class levelOrder {

    /** 元素分隔符 */
    final String SEP = ",";
    /** 空节点 */
    final String NULL = "#";


    /* 将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        // 初始化队列，将 root 加入队列
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (! q.isEmpty()) {
            TreeNode cur = q.poll();

            /* 层级遍历代码位置 */
            if (cur == null) {
                sb.append(NULL).append(SEP);
                continue;
            }
            sb.append(cur.val).append(SEP);

            q.offer(cur.left);
            q.offer(cur.right);
        }

        return sb.toString();
    }

    /* 将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        String[] nodes = data.split(SEP);
        // 第一个元素就是 root 的值
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

        // 队列 q 记录父节点，将 root 加入队列
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        for (int i = 1; i < nodes.length; ) {
            // 队列中存的都是父节点
            TreeNode parent = q.poll();
            // 父节点对应的左侧子节点的值
            String left = nodes[i++];
            if (! left.equals(NULL)) {
                Objects.requireNonNull(parent).left = new TreeNode(Integer.parseInt(left));
                q.offer(parent.left);
            } else {
                Objects.requireNonNull(parent).left = null;
            }
            // 父节点对应的右侧子节点的值
            String right = nodes[i++];
            if (! right.equals(NULL)) {
                parent.right = new TreeNode(Integer.parseInt(right));
                q.offer(parent.right);
            } else {
                parent.right = null;
            }
        }
        return root;
    }

}
```

## ⼆叉搜索⼦树的最⼤键值和（困难）

> [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)
>
> 题目会给你输入一棵二叉树，这棵二叉树的子树中可能包含**二叉搜索树**对吧，请你找到**节点之和最大的**那棵二叉搜索树，返回它的节点值之和。

对于有的题⽬，不同的遍历顺序时间复杂度不同。

⼆叉树相关题⽬最核⼼的思路是**明确当前节点需要做的事情是什么**。

我们再看看后序遍历的代码框架：

```java
void traverse(TreeNode root) { 
    traverse(root.left); 
    traverse(root.right); 
    /* 后序遍历代码的位置 */ 
    /* 在这⾥处理当前节点 */ 
} 
```

看这个代码框架，你说后序遍历什么时候出现呢？

**如果当前节点要做的事情需要通过左右⼦树的计算结果推导出来，就要⽤到后序遍历**。

很多时候，后序遍历⽤得好，可以⼤幅提升算法效率。

二叉搜索树（简写作 BST）的性质不用我多介绍了吧，简单说就是「左小右大」，对于每个节点，整棵左子树都比该节点的值小，整棵右子树都比该节点的值大。

比如题目给了这个例子：

![img](https://cos.duktig.cn/typora/202112171035586.png)

如果输入这棵二叉树，算法应该返回 20，也就是图中绿圈的那棵子树的节点值之和，因为它是一棵 BST，且节点之和最大。

那有的读者可能会问，根据 BST 的定义，有没有可能一棵二叉树中不存在 BST？

不会的，因为按照 BST 的定义，任何一个单独的节点肯定是 BST，也就是说，再不济，二叉树最下面的叶子节点肯定是 BST。

比如说如果输入下面这棵二叉树：

![img](https://cos.duktig.cn/typora/202112171037282.png)

两个叶子节点 `1` 和 `2` 就是 BST，比较一下节点之和，算法应该返回 2。

刚才说了，**二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么**。

**那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢**？

1、我肯定得知道左右子树是不是合法的 BST，如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。

2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。

3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。

**根据以上三点，站在当前节点的视角，需要知道以下具体信息**：

1、左右子树是否是 BST。

2、左子树的最大值和右子树的最小值。

3、左右子树的节点值之和。

只有知道了这几个值，我们才能满足题目的要求，后面我们会想方设法计算这些值。

可以先写出 **伪代码** 如下：

```java
// 全局变量，记录 BST 最大节点之和
int maxSum = 0;

/* 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

/* 遍历二叉树 */
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    /******* 前序遍历位置 *******/
    // 判断左右子树是不是 BST
    if (!isBST(root.left) || !isBST(root.right)) {
        goto next;
    }
    // 计算左子树的最大值和右子树的最小值
    int leftMax = findMax(root.left);
    int rightMin = findMin(root.right);
    // 判断以 root 节点为根的树是不是 BST
    if (root.val <= leftMax || root.val >= rightMin) {
        goto next;
    }
    // 如果条件都符合，计算当前 BST 的节点之和
    int leftSum = findSum(root.left);
    int rightSum = findSum(root.right);
    int rootSum = leftSum + rightSum + root.val;
    // 计算 BST 节点的最大和
    this.maxSum = Math.max(maxSum, rootSum);
    /**************************/

    // 递归左右子树
    next:
    traverse(root.left);
    traverse(root.right);
}

/* 计算以 root 为根的二叉树的最大值 */
int findMax(TreeNode root) {}

/* 计算以 root 为根的二叉树的最小值 */
int findMin(TreeNode root) {}

/* 计算以 root 为根的二叉树的节点和 */
int findSum(TreeNode root) {}

/* 判断以 root 为根的二叉树是否是 BST */
boolean isBST(TreeNode root) {}
```

这个代码逻辑应该是不难理解的，代码在前序遍历的位置把之前的分析都实现了一遍。

**稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 `traverse` 函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的**。

但是根据刚才的分析，像 `leftMax`、`rootSum` 这些变量又都得算出来，否则无法完成题目的要求。

我们希望既算出这些变量，又避免辅助函数带来的额外复杂度，鱼和熊掌全都要！

其实是可以的，**只要把前序遍历变成后序遍历，让 `traverse` 函数把辅助函数做的事情顺便做掉**。

其他代码不变，我们让 `traverse` 函数做一些计算任务，返回一个数组：

```java
// 全局变量，记录 BST 最大节点之和
int maxSum = 0;

/* 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

// 函数返回 int[]{ isBST, min, max, sum}
int[] traverse(TreeNode root) {

    int[] left = traverse(root.left);
    int[] right = traverse(root.right);

    /******* 后序遍历位置 *******/
    // 通过 left 和 right 推导返回值
    // 并且正确更新 maxSum 变量
    /**************************/
}
```

`traverse(root)` 返回一个大小为 4 的 int 数组，我们暂且称它为 `res`，其中：

`res[0]` 记录以 `root` 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；

`res[1]` 记录以 `root` 为根的二叉树所有节点中的最小值；

`res[2]` 记录以 `root` 为根的二叉树所有节点中的最大值；

`res[3]` 记录以 `root` 为根的二叉树所有节点值之和。

其实这就是把之前分析中说到的几个值放到了 `res` 数组中，**最重要的是，我们要试图通过 `left` 和 `right` 正确推导出 `res` 数组**。

```java
/** 全局变量，记录 BST 最大节点之和 */
int maxSum = 0;

/** 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

/**
 * 递归计算
 *
 * @param root /
 * @return int[]{ isBST, min, max, sum}
 */
private int[] traverse(TreeNode root) {
    // base case
    if (root == null) {
        return new int[] {
                1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0
        };
    }

    // 递归计算左右子树
    int[] left = traverse(root.left);
    int[] right = traverse(root.right);

    /*  后序遍历位置  */
    int[] res = new int[4];
    // 这个 if 在判断以 root 为根的二叉树是不是 BST
    if (left[0] == 1 && right[0] == 1 &&
            root.val > left[2] && root.val < right[1]) {
        // 以 root 为根的二叉树是 BST
        res[0] = 1;
        // 计算以 root 为根的这棵 BST 的最小值
        res[1] = Math.min(left[1], root.val);
        // 计算以 root 为根的这棵 BST 的最大值
        res[2] = Math.max(right[2], root.val);
        // 计算以 root 为根的这棵 BST 所有节点之和
        res[3] = left[3] + right[3] + root.val;
        // 更新全局变量
        maxSum = Math.max(maxSum, res[3]);
    } else {
        // 以 root 为根的二叉树不是 BST
        res[0] = 0;
        // 其他的值都没必要计算了，因为用不到
    }
    return res;
}
```

这样，这道题就解决了，`traverse` 函数在遍历二叉树的同时顺便把之前辅助函数做的事情都做了，避免了在递归函数中调用递归函数，时间复杂度只有 O(N)。

你看，这就是后序遍历的妙用，相对前序遍历的解法，现在的解法不仅效率高，而且代码量少，比较优美。

**后序遍历这么好，是不是就应该尽可能多用后序遍历**？

其实也不是，主要是看题目，就好比 BST 的中序遍历是有序的一样。

这道题为什么用后序遍历呢，因为我们需要的这些变量都是可以通过后序遍历得到的。

你计算以 `root` 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 `root.val` 计算出来？

你计算以 `root` 为根的二叉树的最大值/最小值，是不是可以通过左右子树的最大值/最小值和 `root.val` 比较出来？

你判断以 `root` 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？

文章开头说过，**如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历**。

## 二叉树的最近公共祖先

Git 的`rebase`工作方式引出一个经典的算法问题：**最近公共祖先**（Lowest Common Ancestor，简称 LCA）。

比如`git pull`这个命令，我们经常会用，它默认是使用`merge`方式将远端别人的修改拉到本地；如果带上上参数`git pull -r`，就会使用`rebase`的方式将远端修改拉到本地。

这二者最直观的区别就是：`merge`方式合并的分支会有很多「分叉」，而`rebase`方式合并的分支就是一条直线。

**对于多人协作，`merge`方式并不好**。

那么问题来了，`rebase`是如何将两条不同的分支合并到同一条分支的呢：

![image-20211220094646114](https://cos.duktig.cn/typora/202112200947816.png)

**首先，找到这两条分支的最近公共祖先`LCA`，然后从`master`节点开始，重演`LCA`到`dev`几个`commit`的修改**，如果这些修改和`LCA`到`master`的`commit`有冲突，就会提示你手动解决冲突，最后的结果就是把`dev`的分支完全接到`master`上面。

Git 是如何找到两条不同分支的最近公共祖先的呢？这就是一个经典的算法问题了。

> [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
>
> `root`节点确定了一棵二叉树，`p`和`q`是这这棵二叉树上的两个节点，让你返回`p`节点和`q`节点的最近公共祖先节点。
>
> **一个节点也可以是它自己的祖先**

我们前文 [学习数据结构和算法的框架思维](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&chksm=9bd7fbbcaca072aa75e2a241064a403fde1e579d57ab846cd8537a54253ceb2c8b93cc3bf38e&scene=21#wechat_redirect) 就说过了，所有二叉树的套路都是一样的：

```java
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

所以，只要看到二叉树的问题，先把这个框架写出来准没问题：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
}
```

现在我们思考如何添加一些细节，把框架改造成解法。

**遇到任何递归型的问题，无非就是灵魂三问**：

**1、这个函数是干嘛的**？

**2、这个函数参数中的变量是什么的是什么**？

**3、得到函数的递归结果，你应该干什么**？

**首先看第一个问题，这个函数是干嘛的**？或者说，你给我描述一下`lowestCommonAncestor`这个函数的「定义」吧。

描述：给该函数输入三个参数`root`，`p`，`q`，它会返回一个节点。

情况 1，如果`p`和`q`都在以`root`为根的树中，函数返回的即使`p`和`q`的最近公共祖先节点。

情况 2，那如果`p`和`q`都不在以`root`为根的树中怎么办呢？函数理所当然地返回`null`呗。

情况 3，那如果`p`和`q`只有一个存在于`root`为根的树中呢？函数就会返回那个节点。

题目说了输入的`p`和`q`一定存在于以`root`为根的树中，但是递归过程中，以上三种情况都有可能发生，所以说这里要定义清楚，后续这些定义都会在代码中体现。

**然后来看第二个问题，这个函数的参数中，变量是什么**？或者说，你描述一个这个函数的「状态」吧。

描述：函数参数中的变量是`root`，因为根据框架，`lowestCommonAncestor(root)`会递归调用`root.left`和`root.right`；至于`p`和`q`，我们要求它俩的公共祖先，它俩肯定不会变化的。

第二个问题也解决了，你也可以理解这是「状态转移」，每次递归在做什么？不就是在把「以`root`为根」转移成「以`root`的子节点为根」，不断缩小问题规模嘛？

**最后来看第三个问题，得到函数的递归结果，你该干嘛**？或者说，得到递归调用的结果后，你做什么「选择」？

这就像动态规划系列问题，怎么做选择，需要观察问题的性质，找规律。那么我们就得分析这个「最近公共祖先节点」有什么特点呢？刚才说了函数中的变量是`root`参数，所以这里都要围绕`root`节点的情况来展开讨论。

先想 base case，如果`root`为空，肯定得返回`null`。如果`root`本身就是`p`或者`q`，比如说`root`就是`p`节点吧，如果`q`存在于以`root`为根的树中，显然`root`就是最近公共祖先；即使`q`不存在于以`root`为根的树中，按照情况 3 的定义，也应该返回`root`节点。

以上两种情况的 base case 就可以把框架代码填充一点了：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // 两种情况的 base case
    if (root == null) return null;
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
}
```

现在就要面临真正的挑战了，用递归调用的结果`left`和`right`来搞点事情。根据刚才第一个问题中对函数的定义，我们继续分情况讨论：

情况 1，如果`p`和`q`都在以`root`为根的树中，那么`left`和`right`一定分别是`p`和`q`（从 base case 看出来的）。

情况 2，如果`p`和`q`都不在以`root`为根的树中，直接返回`null`。

情况 3，如果`p`和`q`只有一个存在于`root`为根的树中，函数返回该节点。

明白了上面三点，可以直接看解法代码了：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // base case
    if (root == null) return null;
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    // 情况 1
    if (left != null && right != null) {
        return root;
    }
    // 情况 2
    if (left == null && right == null) {
        return null;
    }
    // 情况 3
    return left == null ? right : left;
}
```

对于情况 1，你肯定有疑问，`left`和`right`非空，分别是`p`和`q`，可以说明`root`是它们的公共祖先，但能确定`root`就是「最近」公共祖先吗？

这就是一个巧妙的地方了，**因为这里是二叉树的后序遍历啊**！前序遍历可以理解为是从上往下，而后序遍历是从下往上，就好比从`p`和`q`出发往上走，第一次相交的节点就是这个`root`，你说这是不是最近公共祖先呢？

综上，二叉树的最近公共祖先就计算出来了。



# 二叉搜索树

BST 是⼀种特殊的⼆叉树，你只要记住它的两个主要特点：

1、左⼩右⼤，即每个节点的左⼦树都⽐当前节点的值⼩，右⼦树都⽐当前节点的值⼤。

2、中序遍历结果是有序的。

 除了它的定义，还有⼀个重要的性质：**BST 的中序遍历结果是有序的（升序）**。

另外，对于 BST 相关的问题，你可能会经常看到类似下面这样的代码逻辑：

```java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。

## 二叉搜索树中第K小的元素

> [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```java
/** 记录结果 */
int res = 0;
/** 记录当前元素的排名 */
int rank = 0;

public int kthSmallest(TreeNode root, int k) {
    // 利用 BST 的中序遍历特性
    traverse(root, k);
    return res;
}

/**
 * 中序遍历 寻找第 K 小的元素
 */
private void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    /* 中序遍历代码位置 */
    rank++;
    if (k == rank) {
        // 找到第 k 小的元素
        res = root.val;
        return;
    }
    traverse(root.right, k);
}
```

这个解法并不是最高效的解法，而是仅仅适用于这道题。

> 如果让你实现一个在二叉搜索树中通过排名计算对应元素的方法 `select(int k)`，你会怎么设计？

如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第 `k` 小的元素都要中序遍历一次，最坏的时间复杂度是 `O(N)`，`N` 是 BST 的节点个数。

要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 `O(logN)` 的复杂度，让你算一个第 `k` 小元素，时间复杂度竟然要 `O(N)`，有点低效了。

所以说，计算第 `k` 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。

我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。

那么回到这个问题，想找到第 `k` 小的元素，或者说找到排名为 `k` 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。

比如说你让我查找排名为 `k` 的元素，当前节点知道自己排名第 `m`，那么我可以比较 `m` 和 `k` 的大小：

1、如果 `m == k`，显然就是找到了第 `k` 个元素，返回当前节点就行了。

2、如果 `k < m`，那说明排名第 `k` 的元素在左子树，所以可以去左子树搜索第 `k` 个元素。

3、如果 `k > m`，那说明排名第 `k` 的元素在右子树，所以可以去右子树搜索第 `k - m - 1` 个元素。

这样就可以将时间复杂度降到 `O(logN)` 了。

那么，如何让每一个节点知道自己的排名呢？

这就是我们之前说的，需要在二叉树节点中维护额外信息。**每个节点需要记录，以自己为根的这棵二叉树有多少个节点**。

也就是说，我们 `TreeNode` 中的字段应该如下：

```java
class TreeNode {
    int val;
    // 以该节点为根的树的节点总数
    int size;
    TreeNode left;
    TreeNode right;
}
```

有了 `size` 字段，外加 BST 节点左小右大的性质，对于每个节点 `node` 就可以通过 `node.left` 推导出 `node` 的排名，从而做到我们刚才说到的对数级算法。

当然，`size` 字段需要在增删元素的时候需要被正确维护，力扣提供的 `TreeNode` 是没有 `size` 这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。

## 把二叉搜索树转换为累加树

> [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)
>
> 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
>
> 比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8=26。

按照二叉树的通用思路，需要思考每个节点应该做什么，但是这道题上很难想到什么思路。

BST 的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？

这是不行的。对于一个节点来说，确实右子树都是比它大的元素，但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。

**其实，正确的解法很简单，还是利用 BST 的中序遍历特性**。

BST 的中序遍历代码可以升序打印节点的值：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    // 中序遍历代码位置
    print(root.val);
    traverse(root.right);
}
```

那如果我想降序打印节点的值怎么办？

很简单，只要把递归顺序改一下就行了：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 先递归遍历右子树
    traverse(root.right);
    // 中序遍历代码位置
    print(root.val);
    // 后递归遍历左子树
    traverse(root.left);
}
```

**这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 `sum`，然后把 `sum` 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗**？

```java
public TreeNode convertBST(TreeNode root) {
    traverse(root);
    return root;
}

/** 记录累加和 */
int sum = 0;

/**
 * 中序遍历
 * 先执行 right，再执行 left，逆序遍历
 * 计算逆序和，并赋值
 *
 * @param root
 */
private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.right);
    // 维护累加和
    sum += root.val;
    // 将 BST 转化成累加树
    root.val = sum;
    traverse(root.left);
}
```

这道题就解决了，核心还是 BST 的中序遍历特性，只不过我们修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。

简单总结下吧，BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求。

## 验证二叉搜索树

>  [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
>
> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：

```java
boolean isValidBST(TreeNode root) {
    if (root == null) return true;
    if (root.left != null && root.val <= root.left.val)
        return false;
    if (root.right != null && root.val >= root.right.val)
        return false;

    return isValidBST(root.left)
        && isValidBST(root.right);
}
```

但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，因为节点 10 的右子树中有一个节点 6，但是我们的算法会把它判定为合法 BST：

![img](https://cos.duktig.cn/typora/202201031539436.png)

**出现问题的原因在于，对于每一个节点 `root`，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，`root` 的整个左子树都要小于 `root.val`，整个右子树都要大于 `root.val`**。

问题是，对于某一个节点 `root`，他只能管得了自己的左右子节点，怎么把 `root` 的约束传递给左右子树呢？

```java
public boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/**
 * 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val
 */
private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) {
        return true;
    }
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) {
        return false;
    }
    if (max != null && root.val >= max.val) {
        return false;
    }
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) 
            && isValidBST(root.right, root, max);
}
```

**我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧**。

## 二叉搜索树中的搜索

> [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)
>
> 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

如果是在一棵普通的二叉树中寻找，可以这样写代码：

```java
TreeNode searchBST(TreeNode root, int target){
    if (root == null) return null;
    if (root.val == target) return root;
    // 当前节点没找到就递归地去左右子树寻找
    TreeNode left = searchBST(root.left, target);
    TreeNode right = searchBST(root.right, target);

    return left != null ? left : right;
}
```

这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有普通二叉树。那么应该如何充分利用信息，把 BST 这个「左小右大」的特性用上？

很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 `target` 和 `root.val` 的大小比较，就能排除一边。我们把上面的思路稍稍改动：

```java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 去左子树搜索
    if (root.val > val) {
        return searchBST(root.left, val);
    }
    // 去右子树搜索
    if (root.val < val) {
        return searchBST(root.right, val);
    }
    return root;
}
```

## 二叉搜索树中的插入操作

> [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)
>
> 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
>
> **注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

插入一个数，就是先找到插入位置，然后进行插入操作。

上一个问题，我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。**一旦涉及「改」，函数就要返回 `TreeNode` 类型，并且对递归调用的返回值进行接收**。

```java
/**
 * 在 BST 中插入一个元素
 * 先找到插入的位置，然后插入元素即可
 */
public TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) {
        return new TreeNode(val);
    }
    // if (root.val == val)
    //     BST 中一般不会插入已存在元素
    if (root.val < val) {
        root.right = insertIntoBST(root.right, val);
    }
    if (root.val > val) {
        root.left = insertIntoBST(root.left, val);
    }
    return root;
}
```

## 删除二叉搜索树中的节点

> [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
>
> 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

这个问题稍微复杂，跟插入操作类似，先「找」再「改」，先把框架写出来再说：

```java
TreeNode deleteNode(TreeNode root, int key) {
    if (root.val == key) {
        // 找到啦，进行删除
    } else if (root.val > key) {
        // 去左子树找
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        // 去右子树找
        root.right = deleteNode(root.right, key);
    }
    return root;
}
```

找到目标节点了，比方说是节点 `A`，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。

**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。

![img](https://cos.duktig.cn/typora/202201031615034.png)

```java
if (root.left == null && root.right == null)
    return null;
```

**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。

![img](https://cos.duktig.cn/typora/202201031618150.png)

```java
// 排除了情况 1 之后
if (root.left == null) return root.right;
if (root.right == null) return root.left;
```

**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。

![img](https://cos.duktig.cn/typora/202201031626347.png)

```java
if (root.left != null && root.right != null) {
    // 找到右子树的最小节点
    TreeNode minNode = getMin(root.right);
    // 把 root 改成 minNode
    root.val = minNode.val;
    // 转而去删除 minNode
    root.right = deleteNode(root.right, minNode.val);
}
```

三种情况分析完毕，填入框架，简化一下代码：

```java
public TreeNode deleteNode(TreeNode root, int key) {
    // base case
    if (root == null) {
        return null;
    }
    // 找到待删除的元素节点
    if (root.val == key) {
        // 这两个 if 把情况 1 和 2 都正确处理了
        if (root.left == null) {
            return root.right;
        }
        if (root.right == null) {
            return root.left;
        }
        // 处理情况 3
        // 获得右子树最小的节点
        TreeNode minNode = getMin(root.right);
        // 删除右子树最小的节点
        root.right = deleteNode(root.right, minNode.val);
        // 用右子树最小的节点替换 root 节点
        minNode.left = root.left;
        minNode.right = root.right;
        root = minNode;
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

/**
 * 在二叉搜索树中寻找最小节点
 */
private TreeNode getMin(TreeNode node) {
    // BST 最左边的就是最小的
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

这样，删除操作就完成了。

注意一下，上述代码在处理情况 3 时通过一系列略微复杂的链表操作交换 `root` 和 `minNode` 两个节点：

```java
// 处理情况 3
// 获得右子树最小的节点
TreeNode minNode = getMin(root.right);
// 删除右子树最小的节点
root.right = deleteNode(root.right, minNode.val);
// 用右子树最小的节点替换 root 节点
minNode.left = root.left;
minNode.right = root.right;
root = minNode;
```

有的读者可能会疑惑，替换 `root` 节点为什么这么麻烦，直接改 `val` 字段不就行了？看起来还更简洁易懂：

```java
// 处理情况 3
// 获得右子树最小的节点
TreeNode minNode = getMin(root.right);
// 删除右子树最小的节点
root.right = deleteNode(root.right, minNode.val);
// 用右子树最小的节点替换 root 节点
root.val = minNode.val;
```

仅对于这道算法题来说是可以的，但这样操作并不完美，我们一般不会通过修改节点内部的值来交换节点。

因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。

## 不同的二叉搜索树

> [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)
>
> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

比如说输入 `n = 3`，算法返回 5，因为共有如下 5 种不同的 BST 结构存储 `{1,2,3}`：

![img](https://cos.duktig.cn/typora/202201031646268.jpeg)

这就是一个正宗的穷举问题，那么什么方式能够正确地穷举合法 BST 的数量呢？

二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。

比如说我们固定`3`作为根节点，这个前提下能有几种不同的 BST 呢？

根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。

所以如果固定`3`作为根节点，左子树节点就是`{1,2}`的组合，右子树就是`{4,5}`的组合。

**左子树的组合数和右子树的组合数乘积**就是`3`作为根节点时的 BST 个数。

![image-20220103165129735](https://cos.duktig.cn/typora/202201031651335.png)

可以写出代码：

```java
/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi) return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}
```

注意 base case，显然当`lo > hi`闭区间`[lo, hi]`肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。

这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。

前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：

```java
/** 备忘录 */
private int[][] memo;

/**
 * 96题
 */
public int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/** 计算闭区间 [lo, hi] 组成的 BST 个数 */
private int count(int lo, int hi) {
    // base case 空节点，也是一种情况，返回 1
    if (lo > hi) {
        return 1;
    }

    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    // 将结果存入备忘录
    memo[lo][hi] = res;

    return res;
}
```

### 进阶——构建出所有合法的 BST

比如说输入`n = 3`，算法返回一个列表，列表中存储着五棵 BST 的根节点。

**明白了上道题构造合法 BST 的方法，这道题的思路也是一样的**：

1、穷举`root`节点的所有可能。

2、递归构造出左右子树的所有合法 BST。

3、给`root`节点穷举所有左右子树的组合。

我们可以直接看代码：

```java
/**
 * 95题
 */
public List<TreeNode> generateTrees(int n) {
    if (n == 0) {
        return new LinkedList<>();
    }
    // 构造闭区间 [1, n] 组成的 BST
    return build(1, n);
}

/** 构造闭区间 [lo, hi] 组成的 BST */
private List<TreeNode> build(int lo, int hi) {
    List<TreeNode> res = new LinkedList<>();
    // base case
    if (lo > hi) {
        res.add(null);
        return res;
    }

    // 1、穷举 root 节点的所有可能。
    for (int i = lo; i <= hi; i++) {
        // 2、递归构造出左右子树的所有合法 BST。
        List<TreeNode> leftTree = build(lo, i - 1);
        List<TreeNode> rightTree = build(i + 1, hi);
        // 3、给 root 节点穷举所有左右子树的组合。
        for (TreeNode left : leftTree) {
            for (TreeNode right : rightTree) {
                // i 作为根节点 root 的值
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }

    return res;
}
```



