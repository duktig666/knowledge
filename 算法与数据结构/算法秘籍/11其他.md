# 算法策略——最⼤化「优势」

田忌赛马的故事告诉我们：**打得过就打，打不过就拿⾃⼰的垃圾和对⽅的精锐互换**。

> 给你输⼊两个⻓度相等的数组 nums1 和 nums2，请你重新组织 nums1 中元素的位置，使得 nums1 的「优势」最⼤化。
> 如果 nums1[i] > nums2[i]，就是说 nums1 在索引 i 上对 nums2[i] 有「优势」。优势最⼤化也就是说让你重新组织 nums1，尽可能多的让 nums[i] > nums2[i]。
>
> [870. 优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle/)
>
> 这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒，你就是孙膑。

**小插曲分析：**

**将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。**

**为什么？**

我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。
如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？

显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。

但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢耶，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？

```java
public int[] advantageCount(int[] nums1, int[] nums2) {
    int n = nums1.length;
    // 从大到小排序的优先队列；数组中第一个元素代表num2中当前元素的索引，第二个元素代表其数值
    PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> b[1] - a[1]);
    for (int i = 0; i < n; i++) {
        priorityQueue.offer(new int[] {i, nums2[i]});
    }
    Arrays.sort(nums1);
    int left = 0, right = n - 1;
    int[] res = new int[n];
    // 每次去nums2中最大的
    while (! priorityQueue.isEmpty()) {
        int[] curs = priorityQueue.poll();
        // index为当前最大值的索引
        int index = curs[0], maxValue = curs[1];
        // nums1大于最大值，选取nums1当前的值
        if (nums1[right] > maxValue) {
            res[index] = nums1[right];
            right--;
        } else {
            // nums1小于等于时，选取最差的数
            res[index] = nums1[left];
            left++;
        }
    }
    return res;
}
```

