# 链表常见算法题总结

默认的链表节点类如下：

```java
public class ListNode {
     int val;
     ListNode next;
     ListNode(int x) { val = x; }
}
```



## 一、 反转链表

[https://leetcode-cn.com/problems/reverse-linked-list/](https://leetcode-cn.com/problems/reverse-linked-list/)

反转链表的思路比较简单，无非**遍历一遍元素，然后反转指针**即可。

因为要将下一个节点的指针指向当前节点，反转指针后怎么找到下一个节点是个问题，所以需要提前保存下一个节点：` temp = head.next`

实现链表反转有两种方式：**迭代**和**递归**，详情可参看代码注释。

### 迭代实现反转链表

```java
public ListNode reverseList(ListNode head) {
    //临时保存上一节点
    ListNode pre = null;
    while (head != null) {
        //临时节点，用于存储下一个节点，当指针反转后，还能指向写一个节点
        ListNode temp = head.next;
        // 反转指针
        head.next = pre;

        // pre移动到当前节点，用于下一个循环进行比对
        pre = head;
        //头结点指向下一个节点，并进入下一个循环
        head = temp;
    }
    return pre;
}
```

### 递归实现反转链表

```java
public ListNode reverse(ListNode head) {
    //当前节点为null，或者写一个节点为null，结束递归（递归过程需要判断下一个节点，所以也要判断）
    if (head == null || head.next == null) {
        return head;
    }
    /*
        临时节点，用于存储下一个节点，当指针反转后，还能指向写一个节点
        此时head=3结点，temp=3结点.next(实际上是4结点)
        执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点
     */
    ListNode temp = head.next;
    //进入递归，返回值相当于当前节点
    ListNode newNode = reverse(head.next);
    /*
       弹栈过程:
        程序继续执行 temp.next = head就相当于4->3 （temp相当于下一个节点，temp.next相当于下一个节点的指针；即下一个节点指向当前节点，实现反转）
        head.next = null 即把3结点指向4结点的指针断掉
        返回新链表的头结点newHead
     */
    temp.next = head;
    head.next = null;
    return newNode;
}
```

## 二、寻找链表中点

[https://leetcode-cn.com/problems/middle-of-the-linked-list/](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

> 如果节点个数为偶数，两个中点，返回第二个

寻找链表的重点有三个思路

1. 利用辅助数组存储链表节点，arr[N/2]即为链表中点。
   1. 需要额外的数组空间
   2. 链表节点数量不确定，需要申请足够数量的空间，造成浪费
2. 单指针扫描。第一次扫描统计元素个数N，第二次扫描到N/2即为中点
3. 快慢指针。快指针走两步，慢指针走一步，当快指针为null或者快指针的下一个节点为null时，慢指针指向的节点即为中点。

### 辅助数组实现

```java
/**
     * 辅助数组实现： 中点即为 N / 2
     * 缺点：需要利用辅助空间，不确定节点数量，根据题意申请固定的100个空间有些浪费
     */
public ListNode middleNode2(ListNode head) {
    ListNode[] nodes = new ListNode[100];
    int t = 0;
    while (head != null) {
        nodes[t++] = head;
        head = head.next;
    }
    return nodes[t / 2];
}
```

### 快慢指针

```java
/**
 * 快慢指针寻找链表中点
 * 快指针是慢指针的2倍，快指针为空或者快指针的下一个节点为空，证明慢指针找到了链表的中点
 * (两个中点的情况，选取第二个)
 * <p>
 * 另一种思路：单指针扫描（不如快慢指针）
 * 单指针扫描第一次统计有N个节点
 * 第二次扫描到N/2时返回中点
 */
public ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```











