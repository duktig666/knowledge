# 链表常见算法题总结

默认的链表节点类如下：

```java
public class ListNode {
     int val;
     ListNode next;
     ListNode(int x) { val = x; }
}
```

## 一、 反转链表

[https://leetcode-cn.com/problems/reverse-linked-list/](https://leetcode-cn.com/problems/reverse-linked-list/)

反转链表的思路比较简单，无非**遍历一遍元素，然后反转指针**即可。

因为要将下一个节点的指针指向当前节点，反转指针后怎么找到下一个节点是个问题，所以需要提前保存下一个节点：` temp = head.next`

实现链表反转有两种方式：**迭代**和**递归**，详情可参看代码注释。

### 迭代实现反转链表

```java
public ListNode reverseList(ListNode head) {
    //临时保存上一节点
    ListNode pre = null;
    while (head != null) {
        //临时节点，用于存储下一个节点，当指针反转后，还能指向写一个节点
        ListNode temp = head.next;
        // 反转指针
        head.next = pre;

        // pre移动到当前节点，用于下一个循环进行比对
        pre = head;
        //头结点指向下一个节点，并进入下一个循环
        head = temp;
    }
    return pre;
}
```

### 递归实现反转链表

```java
public ListNode reverse(ListNode head) {
    //当前节点为null，或者写一个节点为null，结束递归（递归过程需要判断下一个节点，所以也要判断）
    if (head == null || head.next == null) {
        return head;
    }
    /*
        临时节点，用于存储下一个节点，当指针反转后，还能指向写一个节点
        此时head=3结点，temp=3结点.next(实际上是4结点)
        执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点
     */
    ListNode temp = head.next;
    //进入递归，返回值相当于当前节点
    ListNode newNode = reverse(head.next);
    /*
       弹栈过程:
        程序继续执行 temp.next = head就相当于4->3 （temp相当于下一个节点，temp.next相当于下一个节点的指针；即下一个节点指向当前节点，实现反转）
        head.next = null 即把3结点指向4结点的指针断掉
        返回新链表的头结点newHead
     */
    temp.next = head;
    head.next = null;
    return newNode;
}
```

## 二、寻找链表中点

[https://leetcode-cn.com/problems/middle-of-the-linked-list/](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

> 如果节点个数为偶数，两个中点，返回第二个

寻找链表的重点有三个思路

1. 利用辅助数组存储链表节点，arr[N/2]即为链表中点。
   1. 需要额外的数组空间
   2. 链表节点数量不确定，需要申请足够数量的空间，造成浪费
2. 单指针扫描。第一次扫描统计元素个数N，第二次扫描到N/2即为中点
3. 快慢指针。快指针走两步，慢指针走一步，当快指针为null或者快指针的下一个节点为null时，慢指针指向的节点即为中点。

### 辅助数组实现

```java
/**
     * 辅助数组实现： 中点即为 N / 2
     * 缺点：需要利用辅助空间，不确定节点数量，根据题意申请固定的100个空间有些浪费
     */
public ListNode middleNode2(ListNode head) {
    ListNode[] nodes = new ListNode[100];
    int t = 0;
    while (head != null) {
        nodes[t++] = head;
        head = head.next;
    }
    return nodes[t / 2];
}
```

### 快慢指针

```java
/**
 * 快慢指针寻找链表中点
 * 快指针是慢指针的2倍，快指针为空或者快指针的下一个节点为空，证明慢指针找到了链表的中点
 * (两个中点的情况，选取第二个)
 * <p>
 * 另一种思路：单指针扫描（不如快慢指针）
 * 单指针扫描第一次统计有N个节点
 * 第二次扫描到N/2时返回中点
 */
public ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```

## 三、回文链表

[https://leetcode-cn.com/problems/palindrome-linked-list/](https://leetcode-cn.com/problems/palindrome-linked-list/)

过程：

1. 寻找链表中点（如果是奇数，第二个节点为目标节点）
2. 反转前边的链表
3. 如果后半部分的链表是奇数（去掉后半部分的第一个节点）
4. 依次对比元素，判断是否为回文链表

```java
private static class ListNode {
    int val;
    ListNode next;

    ListNode() {}

    ListNode(int val) { this.val = val; }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}


/**
 * 判断链表是否为回文链表
 * 1. 寻找链表中点（如果是奇数，第二个节点为目标节点）
 * 2. 反转前边的链表
 * 3. 如果后半部分的链表是奇数（去掉后半部分的第一个节点）
 * 4. 依次对比元素，判断是否为回文链表
 */
public boolean isPalindrome(ListNode head) {
    // 如果链表为空 或者 只有一个元素，证明是回文链表
    if (head == null || head.next == null) {
        return true;
    }
    ListNode slow = head;
    ListNode fast = head;

    //寻找链表中点
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    //反转链表
    //pre用来保存先前结点
    ListNode pre = null;
    //next用来做临时变量
    ListNode temp = null;
    while (head != slow) {
        temp = head.next;
        head.next = pre;
        pre = head;
        head = temp;
    }

    //如果是奇数节点，则去掉后半部分的第一个节点
    if (fast != null) {
        slow = slow.next;
    }
    //一次判断
    while (pre != null) {
        if (pre.val != slow.val) {
            return false;
        }
        pre = pre.next;
        slow = slow.next;
    }
    return true;
}
```

## 四、判断单链表是否成环

[https://leetcode-cn.com/problems/linked-list-cycle/](https://leetcode-cn.com/problems/linked-list-cycle/)

解题思路：

 1. 思路一：每遍历一个新的节点，就从头结点重新遍历之前的节点，判断是否存在相同的节点ID，若遍历两次相同的节点ID，则证明有环
 2. 思路二：利用HashSet，遍历存储节点ID，存储重复时，证明有环
 3. 思路三：快慢指针。相交则说明链表成环

![单链表成环](https://cos.duktig.cn/typora/202109062136574.gif)

### 快慢指针解题

```java
/**
 * 快慢指针判断链表是否成环
 */
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
```





