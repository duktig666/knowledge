# 数组

数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。

此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 前缀和

前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。

### 数组中的前缀和

[303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

求一个数字区间内的数字之和。

正常题解：

```java
class NumArray { 
 
    private int[] nums; 
 
    public NumArray(int[] nums) { 
        this.nums = nums; 
    } 
     
    public int sumRange(int left, int right) { 
        int res = 0; 
        for (int i = left; i <= right; i++) { 
            res += nums[i]; 
        } 
        return res; 
    } 
} 
```

前缀和：

```java
class NumArray { 
    // 前缀和数组 
    private int[] preSum; 
 
    /* 输⼊⼀个数组，构造前缀和 */ 
    public NumArray(int[] nums) { 
        // preSum[0] = 0，便于计算累加和 
        preSum = new int[nums.length + 1]; 
        // 计算 nums 的累加和 
        for (int i = 1; i < preSum.length; i++) { 
            preSum[i] = preSum[i - 1] + nums[i - 1]; 
        } 
    } 
     
    /* 查询闭区间 [left, right] 的累加和 */ 
    public int sumRange(int left, int right) { 
        return preSum[right + 1] - preSum[left]; 
    } 
} 
```

使用前缀和避免每次都进行O(n)的计算，而降为O(1)。

实际场景中的例子：输⼊任意⼀个分数段，返回有多少同学的成绩在这个分数段内。

```java
int[] scores; // 存储着所有同学的分数
// 试卷满分 100 分
int[] count = new int[100 + 1] 
// 记录每个分数有⼏个同学
for (int score : scores) 
    count[score]++ 
// 构造前缀和
for (int i = 1; i < count.length; i++) 
    count[i] = count[i] + count[i-1]; 
 
// 利⽤ count 这个前缀和数组进⾏分数段查询
```

### 矩阵中的前缀和

[304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

## 差分数组

差分数组的主要适⽤场景是 **频繁对原始数组的某个区间的元素进⾏增减**。

⽐如说，我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给...⼀通操作猛如⻁，然后问你，最后 nums 数组的值是什么？

对 nums 数组构造⼀个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差。

这样构造差分数组 diff，就可以快速进⾏区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可。

```java
public class Difference {

    /** 差分数组 */
    private int[] diff;

    /**
     * 输⼊⼀个初始数组，区间操作将在这个数组上进⾏
     */
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /**
     * 给闭区间 [i,j] 增加 val（可以是负数）
     */
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    /**
     * 返回结果数组
     */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
    
}
```

## 二分查找

⼆分查找：思路很简单，细节是魔⻤。⼆分查找真正的坑根本就不是那个细节问题，⽽是在于**到底要给 mid 加⼀还是减⼀，while ⾥到底⽤ <= 还是 <**。

⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。

**二分查找框架**：

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2 ;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

分析⼆分查找的⼀个技巧是：**不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节**。

其中 ... 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。

另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 `left + (right - left) / 2 `就和 `(left +right) / 2` 的结果相同，但是**有效防⽌了 left 和 right 太⼤直接相加导致溢出**。

### 寻找⼀个数（基本的⼆分搜索）

即搜索⼀个数，如果存在，返回其索引，否则返回 -1。

```java
int binarySearch(int[] nums, int target) { 
    int left = 0;  
    int right = nums.length - 1; // 注意 

    while(left <= right) { 
        int mid = left + (right - left) / 2; 
        if(nums[mid] == target) 
            return mid;  
        else if (nums[mid] < target) 
            left = mid + 1; // 注意 
        else if (nums[mid] > target) 
            right = mid - 1; // 注意 
    } 
    return -1; 
} 
```

#### **1、为什么 while 循环的条件中是 <=，⽽不是 <？**

答：因为初始化 right 的赋值是 nums.length - 1，即最后⼀个元素的索引，⽽不是 nums.length。

这⼆者可能出现在不同功能的⼆分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引⼤⼩为 `nums.length` 是越界的。

我们这个算法中使⽤的是前者 [left, right] 两端都闭的区间。**这个区间其实就是每次进⾏搜索的区间**。

**那 while 循环什么时候应该终⽌？**搜索区间为空的时候应该终⽌。

`while(left <= right)` 的终⽌条件是 `left == right + 1`，写成区间的形式就是 `[right + 1,right]`，或者带个具体的数字进去 [3, 2]，可⻅这时候区间为空，因为没有数字既⼤于等于 3 ⼜⼩于等于2 的吧。所以这时候 while 循环终⽌是正确的，直接返回 -1 即可。

`while(left < right)` 的终⽌条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 [2, 2]，这时候区间⾮空，还有⼀个数 2，但此时 while 循环终⽌了。也就是说这区间[2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你⾮要⽤ while(left < right) 也可以，我们已经知道了出错的原因，就打个补丁好了：

```java
//... 
while(left < right) { 
    // ... 
} 
return nums[left] == target ? left : -1; 
```

#### **2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？**

答：这也是⼆分查找的⼀个难点，不过只要你能理解前⾯的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，⽽且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下⼀步应该去搜索哪⾥呢？

当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。

#### **3、此算法有什么缺陷？**

答：⾄此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

⽐如说给你有序数组 `nums = [1,2,2,2,3]`，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是⽆法处理的。

这样的需求很常⻅，你也许会说，找到⼀个 target，然后向左或向右线性搜索不⾏吗？可以，但是不好，因为这样难以保证⼆分查找对数级的复杂度了。

我们后续的算法就来讨论这两种⼆分查找的算法。

### 寻找左侧边界的⼆分搜索

```java
int leftBound(int[] nums, int target) { 
    int left = 0, right = nums.length - 1; 
    while (left <= right) { 
        int mid = left + (right - left) / 2; 
        if (nums[mid] < target) { 
            left = mid + 1; 
        } else if (nums[mid] > target) { 
            right = mid - 1; 
        } else if (nums[mid] == target) { 
            // 别返回，锁定左侧边界 
            right = mid - 1; 
        } 
    } 
    // 最后要检查 left 越界的情况 
    if (left >= nums.length || nums[left] != target) 
        return -1; 
    return left;
} 
```

### 寻找右侧边界的二分搜索

```java
int rightBound(int[] nums, int target) { 
    int left = 0, right = nums.length - 1; 
    while (left <= right) { 
        int mid = left + (right - left) / 2; 
        if (nums[mid] < target) { 
            left = mid + 1; 
        } else if (nums[mid] > target) { 
            right = mid - 1; 
        } else if (nums[mid] == target) { 
            // 别返回，锁定右侧边界 
            left = mid + 1; 
        } 
    } 
    // 最后要检查 right 越界的情况 
    if (right < 0 || nums[right] != target) 
        return -1; 
    return right; 
} 
```



### ⼆分搜索问题的泛化

什么问题可以运⽤⼆分搜索算法技巧？

⾸先，**你要从题⽬中抽象出⼀个⾃变量 x，⼀个关于 x 的函数 f(x)，以及⼀个⽬标值 target**。同时，x, f(x), target 还要满⾜以下条件：

1、**f(x) 必须是在 x 上的单调函数（单调增单调减都可以）**。

2、**题⽬是让你计算满⾜约束条件 f(x) == target 时的 x 的值**。

举个具体的例⼦：

给你⼀个升序排列的有序数组 nums 以及⼀个⽬标元素 target，请你计算 target 在数组中的索引位置，如果有多个⽬标元素，返回最⼩的索引。

这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这⾥⾯ x, f(x), target 分别是什么呢？
我们可以把数组中元素的索引认为是⾃变量 x，函数关系 f(x) 就可以这样设定：

```java
// 函数 f(x) 是关于⾃变量 x 的单调递增函数
// ⼊参 nums 是不会改变的，所以可以忽略，不算⾃变量
int f(int x, int[] nums) { 
    return nums[x]; 
} 
```

其实这个函数 f 就是在访问数组 nums，因为题⽬给我们的数组 nums 是升序排列的，所以函数 f(x) 就是在x 上单调递增的函数。

### 运⽤⼆分搜索的套路框架

想要运⽤⼆分搜索解决具体的算法问题，可以从以下代码框架着⼿思考：

```java
// 函数 f 是关于⾃变量 x 的单调函数
int f(int x) { 
    // ... 
} 

// 主函数，在 f(x) == target 的约束下求 x 的最值
int solution(int[] nums, int target) { 
    if (nums.length == 0) return -1; 
    // 问⾃⼰：⾃变量 x 的最⼩值是多少？ 
    int left = ...; 
    // 问⾃⼰：⾃变量 x 的最⼤值是多少？ 
    int right = ... + 1; 

    while (left < right) { 
        int mid = left + (right - left) / 2; 
        if (f(mid) == target) { 
            // 问⾃⼰：题⽬是求左边界还是右边界？ 
            // ... 
        } else if (f(mid) < target) { 
            // 问⾃⼰：怎么让 f(x) ⼤⼀点？ 
            // ... 
        } else if (f(mid) > target) { 
            // 问⾃⼰：怎么让 f(x) ⼩⼀点？ 
            // ... 
        } 
    } 
    return left; 
} 
```
## 原地修改数组

对于数组来说，在尾部插⼊、删除元素是⽐较⾼效的，时间复杂度是 O(1)，但是如果在中间或者开头插⼊、删除元素，就会涉及数据的搬移，时间复杂度为O(N)，效率较低。

**把待删除元素交换到最后⼀个，然后再删除，可以避免数据搬移**。

### 有序数组/链表去重

即有序数组/链表，返回其不重复的数组/链表。

最常用的解法即 **快慢指针** 的元素覆盖。

针对于数组，快指针fast指向的元素与慢指针slow不同时，`arr[slow]=arr[fast]`.

针对于链表，快指针fast指向的元素与慢指针slow不同时，`slow.next=fast`，最后断掉slow之后的元素，即`slow.next=null`。

# 链表

单链表结构如下：

```java
public class ListNode {
    int val;
    ListNode next;

    ListNode() {}

    ListNode(int val) { this.val = val; }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```



## 合并两个有序链表

> [21.合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
>
> 给你输⼊两个有序链表，请你把他俩合并成⼀个新的有序链表。
>

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    // 虚拟头结点作用：并不知道谁的节点小，方便计算
    ListNode dummy = new ListNode(- 1), p = dummy;
    ListNode p1 = list1, p2 = list2;
    while (p1 != null && p2 != null) {
        // 谁的元素小，p指向谁，保持有序
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p不断前进
        p = p.next;
    }
    // 另一条链可能还存在节点
    if (p1 != null) {
        p.next = p1;
    }
    if (p2 != null) {
        p.next = p2;
    }
    // 去掉虚拟头结点
    return dummy.next;
}
```

这道题算是比较简单的，重点思路在：

1. **比较两条链表的当前节点，谁的节点小就将其接到最终链表上，然后修改链表的指针**。
2. **当其中一条链的节点为null时，结束比较，直接将另一条节点续接在结果链表的尾端即可。**

这里有一个小技巧：因为初始时，你的结果链表的第一个节点不知道该选择两条链表的哪一个节点，为了方便写代码，借助虚拟头结点的思想，最终合并完时，返回 `dummy.next`。



## 合并K个升序链表

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。
>
> [23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) {
        return null;
    }
    ListNode dummy = new ListNode(- 1);
    // 在使用一个变量，用来进行链表向后遍历的操作，dummy方便最后结果的返回
    ListNode res = dummy;
    PriorityQueue<ListNode> priorityQueue = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);
    // 利用优先队列，维护一个二叉堆（堆排），计算时每次取出最小的节点
    for (ListNode head : lists) {
        // 当前链表头结点不为null，加入优先队列当中
        if (head != null) {
            priorityQueue.add(head);
        }
    }
    // 每次将最小节点添加到 res 的末尾
    while (! priorityQueue.isEmpty()) {
        ListNode minNode = priorityQueue.poll();
        res.next = minNode;
        // 当前最小元素节点 下一个元素 不为null时，继续向优先队列添加
        if (minNode.next != null) {
            priorityQueue.add(minNode.next);
        }
        // 结果链表，后移
        res = res.next;
    }
    return dummy.next;
}
```

这道题算是 合并2个升序链表的进阶版，主体的思路还是不变，但是 **怎么从所有链表中选取最小的头结点** 这是一个问题？

数量固定，动态排序，最直观的想法就是堆排。所以我们选用 `PriorityQueue`  来解决问题，其底层实现是 二叉堆。

## 删除单链表的倒数第 k 个节点

从前往后寻找单链表的第 k 个节点很简单，⼀个 for 循环遍历过去就找到了，但是 **如何寻找从后往前数的第k 个节点呢**？

那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k 个节点，不也是⼀个 for 循环的事⼉吗？

是的，但是算法题⼀般只给你⼀个 ListNode 头结点代表⼀条单链表，你不能直接得出这条链表的⻓度 n，⽽需要先遍历⼀遍链表算出 n 的值，然后再遍历链表计算第 n - k 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点。

那么，我们能不能 **只遍历⼀次链表，就算出倒数第 k 个节点**？

这个解法就⽐较巧妙了，假设 k = 2，思路如下：

⾸先，我们先让⼀个指针 p1 指向链表的头节点 head，然后⾛ k 步：

![image-20211129171930518](https://cos.duktig.cn/typora/202111291719252.png)

现在的 p1，只要再⾛ n - k 步，就能⾛到链表末尾的空指针了对吧？

趁这个时候，再⽤⼀个指针 p2 指向链表头节点 head：

![image-20211129172052893](https://cos.duktig.cn/typora/202111291720146.png)

接下来就很显然了，让 p1 和 p2 同时向前⾛，p1 ⾛到链表末尾的空指针时⾛了 n - k 步，p2 也⾛了 n -k 步，也就是链表的倒数第 k 个节点：

![image-20211129172209983](https://cos.duktig.cn/typora/202111291722623.png)

这样，只遍历了⼀次链表，就获得了倒数第 k 个节点 p2。

代码如下：

```java
/**
 * 寻找链表倒数第 N 个节点
 */
public ListNode findNthFromEnd(ListNode head, int n) {
    ListNode p1 = head, p2 = head;
    for (int i = 0; i < n; i++) {
        p1 = p1.next;
    }
    while (p1 != null) {
        p1 = p1.next;
        p2 = p2.next;
    }
    return p2;
}
```

至于删除倒数第N个链表节点，需要借助下虚拟头结点，毕竟还需要返回头结点。另一个作用，是为了解决空指针的问题。

比如：说链表总共有 5 个节点，题⽬就让你删除倒数第 5 个节点，也就是第⼀个节点，那按照算法逻辑，应该⾸先找到倒数第 6 个节点。但第⼀个节点前⾯已经没有节点了，这就会出错。

代码入下：

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(- 1);
    dummy.next = head;
    ListNode pre = findNthFromEnd(dummy, n + 1);
    pre.next = pre.next.next;
    return dummy.next;
}
```

## 链表的中间节点

[https://leetcode-cn.com/problems/middle-of-the-linked-list/](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

> 如果节点个数为偶数，两个中点，返回第二个

寻找链表的重点有三个思路

1. 利用辅助数组存储链表节点，arr[N/2]即为链表中点。
   1. 需要额外的数组空间
   2. 链表节点数量不确定，需要申请足够数量的空间，造成浪费
2. 单指针扫描。第一次扫描统计元素个数N，第二次扫描到N/2即为中点
3. 快慢指针。快指针走两步，慢指针走一步，当快指针为null或者快指针的下一个节点为null时，慢指针指向的节点即为中点。

辅助数组实现

```java
/**
   * 辅助数组实现： 中点即为 N / 2
     * 缺点：需要利用辅助空间，不确定节点数量，根据题意申请固定的100个空间有些浪费
     */
public ListNode middleNode2(ListNode head) {
    ListNode[] nodes = new ListNode[100];
    int t = 0;
    while (head != null) {
        nodes[t++] = head;
        head = head.next;
    }
    return nodes[t / 2];
}
```

快慢指针

```java
/**
 * 快慢指针寻找链表中点
 * 快指针是慢指针的2倍，快指针为空或者快指针的下一个节点为空，证明慢指针找到了链表的中点
 * (两个中点的情况，选取第二个)
 * <p>
 * 另一种思路：单指针扫描（不如快慢指针）
 * 单指针扫描第一次统计有N个节点
 * 第二次扫描到N/2时返回中点
 */
public ListNode middleNode(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```

## 判断单链表是否有环

[https://leetcode-cn.com/problems/linked-list-cycle/](https://leetcode-cn.com/problems/linked-list-cycle/)

判断链表是否包含环属于经典问题了，解决⽅案也是⽤快慢指针：

每当慢指针 slow 前进⼀步，快指针 fast 就前进两步。

如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了slow ⼀圈，说明链表中含有环。

![单链表成环](https://cos.duktig.cn/typora/202109062136574.gif)

**思路**：

（1）定义两个指针分别为 slow，fast，并且将指针均指向链表头节点。
（2）规定，slow 指针每次前进 1 个节点，fast 指针每次前进两个节点。
（3）当 slow 与 fast 相等，且二者均不为空，则链表存在环。

只需要把寻找链表中点的代码稍加修改就⾏了：

```java
/**
 * 快慢指针判断链表是否成环
 */
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
```

## 链表中环的入口

如果链表中含有环，如何计算这个环的起点？

本题算是“判断链表是否有环”的进阶题。

> 给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。
>
> 题目详情参看：[链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)

思路：**当快慢指针相遇时，让其中任⼀个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。**

我们假设快慢指针相遇时，慢指针 slow ⾛了 k 步，那么快指针 fast ⼀定⾛了 2k 步：

![image-20211129194031537](https://cos.duktig.cn/typora/202111291940177.png)

fast ⼀定⽐ slow 多⾛了 k 步，这多⾛的 k 步其实就是 fast 指针在环⾥转圈圈，所以 k 的值就是环⻓度的「整数倍」。

假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k -m，也就是说如果从 head 前进 k - m 步就能到达环起点。

巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始⾛k步可以转回到相遇点，那⾛ k - m 步肯定就⾛到环起点了：

![image-20211129194348546](https://cos.duktig.cn/typora/202111291943431.png)

所以，只要我们把快慢指针中的任⼀个重新指向 head，然后两个指针同速前进，k - m 步后⼀定会相遇，相遇之处就是环的起点了。

**代码实现**：

```java
/**
 * 找到环的入口节点
 */
public ListNode detectCycle(ListNode head) {
    // 先找出环中的相遇节点
    ListNode meetingNode = getMeetingNode(head);
    // 没有环，返回null
    if (meetingNode == null) {
        return null;
    }
    // p1 指向快慢指针相遇的节点
    ListNode p1 = meetingNode;
    // p2 指向头节点
    ListNode p2 = head;
    // p1和p2以相同的速度向前移动，当p2指向环的入口节点时，p1已经围绕着环走了n圈又回到了入口节点。
    while (p1 != p2) {
        p1 = p1.next;
        p2 = p2.next;
    }
    //返回入口节点
    return p1;
}

/**
 * 找到环中相遇的节点，不存在环返回null
 */
private ListNode getMeetingNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            return slow;
        }
    }
    return null;
}
```

## 链表是否相交

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
>
> ![链表相交](https://cos.duktig.cn/typora/202109171631046.png)
>
> **注意：**
>
> - 如果两个链表没有交点，返回 null。
> - 在返回结果后，两个链表仍须保持原有的结构。
> - 可假定整个链表结构中没有循环。
> - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
>
> 题目详细信息参看：[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**借助辅助空间（Set）解题**

**思路**：

1. 扫描链表A，将所有节点添加到`HashSet`中;
2. 扫描链表B，判断没有节点是否存在在集合中，如果存在，表示两个链表相交，返回此节点；
3. 扫描完B，都不存在，说明未相交，返回`null`。

**时间复杂度**：O(n)  **空间复杂度**：O(n)

**代码实现**：

```java
public ListNode getIntersectionNodeByHashSet(ListNode headA, ListNode headB) {
    // 边界判断
    if (headA == null || headB == null) {
        return null;
    }
    Set<ListNode> set = new HashSet<>();
    while (headA != null) {
        set.add(headA);
        headA = headA.next;
    }
    // 存在A相同的节点，即说明相交
    while (headB != null) {
        if (set.contains(headB)) {
            return headB;
        }
        headB = headB.next;
    }
    return null;
}
```

**快慢指针**

难点在于，由于两条链表的⻓度可能不同，两条链表之间的节点⽆法对应：

![image-20211129200123732](https://cos.duktig.cn/typora/202111292001140.png)

如果⽤两个指针 p1 和 p2 分别在两条链表上前进，并不能同时⾛到公共节点，也就⽆法得到相交节点 c1。

所以，**解决这个问题的关键是，通过某些⽅式，让 p1 和 p2 能够同时到达相交节点 c1**。

所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了⼀起。

如果这样进⾏拼接，就可以让 p1 和 p2 同时进⼊公共部分，也就是同时到达相交节点 c1：

![image-20211129200245331](https://cos.duktig.cn/typora/202111292002414.png)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。

```java
/**
 * 得到链表相交的起点节点，若未相交返回null
 * 思路二：双指针
 * 时间复杂度：O(a+b) 空间复杂度：O(1)
 * <p>
 * 循环中的代码可以写为：
 * // p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表
 * if (p1 == null) {
 * p1 = headB;
 * } else {
 * p1 = p1.next;
 * }
 * // p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表
 * if (p2 == null) {
 * p2 = headA;
 * } else {
 * p2 = p2.next;
 * }
 */
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // p1 指向 A 链表头结点，p2 指向 B 链表头结点
    ListNode p1 = headA, p2 = headB;
    while (p1 != p2) {
        p1 = p1 == null ? headB : p1.next;
        p2 = p2 == null ? headA : p2.next;
    }
    return p1;
}
```

## 反转链表

### 递归反转链表

```java
/**
 * 实现链表的反转（递归法）
 * 递归实质上就是系统帮你压栈的过程，系统在压栈的时候会保留现场
 *
 * @param head 链表
 * @return 反转后的链表
 */
public Node<E> reverse(Node<E> head) {
    //当前节点为null，或者前一个节点为null，结束递归（递归过程需要判断下一个节点，所以也要判断）
    if (head == null || head.next == null) {
        return head;
    }
    //进入递归，返回值相当于当前节点
    Node<E> last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```

![image-20211201155512063](https://cos.duktig.cn/typora/202112011555802.png)

![image-20211201155530724](https://cos.duktig.cn/typora/202112011555130.png)

![image-20211201155544828](https://cos.duktig.cn/typora/202112011555247.png)

![image-20211201155557103](https://cos.duktig.cn/typora/202112011555156.png)

![image-20211201155620715](https://cos.duktig.cn/typora/202112011556206.png)

### 反转链表的前N个节点

```java
/**
 * 将链表的前 n 个节点反转（n <= 链表⻓度）
 */
public ListNode reverseN(ListNode head, int n) {
    if (n == 1) {
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后⾯的节点连起来
    head.next = successor;
    return last;
}
```

![image-20211201160338637](https://cos.duktig.cn/typora/202112011603984.png)

![image-20211201160352866](https://cos.duktig.cn/typora/202112011603148.png)

### 反转链表的一部分

```java
/**
 * 给⼀个索引区间 [m,n]（索引从 1 开始），仅仅反转区间中的链表元素
 */
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}
```

### K个一组翻转链表

> [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

链表是一种兼具递归和迭代性质的数据结构，认真思考一下可以发现**这个问题具有递归性质**。

什么叫递归性质？直接上图理解，比如说我们对这个链表调用 `reverseKGroup(head, 2)`，即以 2 个节点为一组反转链表：

![image-20211225102206892](https://cos.duktig.cn/typora/202112251022930.png)

如果我设法把前 2 个节点反转，那么后面的那些节点怎么处理？后面的这些节点也是一条链表，而且规模（长度）比原来这条链表小，这就叫**子问题**。

![image-20211225102234945](https://cos.duktig.cn/typora/202112251022175.png)

我们可以直接递归调用 `reverseKGroup(cur, 2)`，因为子问题和原问题的结构完全相同，这就是所谓的递归性质。

大致的算法流程：

**1、先反转以 `head` 开头的 `k` 个元素**。

![image-20211225102408182](https://cos.duktig.cn/typora/202112251024980.png)

**2、将第 `k + 1` 个元素作为 `head` 递归调用 `reverseKGroup` 函数**。

![image-20211225102436491](https://cos.duktig.cn/typora/202112251024137.png)

**3、将上述两个过程的结果连接起来**。

![image-20211225102514999](https://cos.duktig.cn/typora/202112251025505.png)

整体思路就是这样了，最后一点值得注意的是，递归函数都有个 base case，对于这个问题是什么呢？

题目说了，如果最后的元素不足 `k` 个，就保持不变。这就是 base case，待会会在代码里体现。

```java
/**
 * 思路：
 * 1. 根据 k 找到 b节点
 * 2. 翻转 [a,b) 的节点
 * 3. 递归翻转后将链表连接起来
 */
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null) {
        return null;
    }
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode a, b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) {
            return head;
        }
        b = b.next;
    }
    // 反转前 k 个元素
    ListNode newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
}

/**
 * 迭代实现反转链表（翻转 head，b）
 */
public ListNode reverse(ListNode head, ListNode b) {
    //临时保存上一节点
    ListNode pre = null, cur = head;
    while (cur != b) {
        //临时节点，用于存储下一个节点，当指针反转后，还能指向写一个节点
        ListNode temp = cur.next;
        // 反转指针
        cur.next = pre;

        // pre移动到当前节点，用于下一个循环进行比对
        pre = cur;
        //头结点指向下一个节点，并进入下一个循环
        cur = temp;
    }
    return pre;
}
```







# 队列和栈

用队列实现栈，用栈实现队列。之前总结过，略。

## 判断合法括号串

> [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
>
> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> - 左括号必须用相同类型的右括号闭合。
> - 左括号必须以正确的顺序闭合。

思考⼀下，**如果只有⼀种括号 ()**，应该如何判断字符串组成的括号是否合法呢？

假设字符串中只有圆括号，如果想让括号字符串合法，那么必须做到：

每个右括号 ) 的左边必须有⼀个左括号 ( 和它匹配。⽐如说字符串 ()))(( 中，中间的两个右括号左边就没有左括号匹配，所以这个括号组合是不合法的。

那么根据这个思路，我们可以写出算法：

```c++
bool isValid(string str) { 
    // 待匹配的左括号数量 
    int left = 0; 
    for (int i = 0; i < str.size(); i++) { 
        if (s[i] == '(') { 
            left++; 
        } else { 
            // 遇到右括号 
            left--; 
        } 
        // 右括号太多 
        if (left == -1) 
            return false; 
    } 
    // 是否所有的左括号都被匹配了 
    return left == 0; 
} 
```

如果只有圆括号，这样就能正确判断合法性。对于三种括号的情况，我⼀开始想模仿这个思路，定义三个变量 left1，left2，left3 分别处理每种括号，虽然要多写不少 if else 分⽀，但是似乎可以解决问题。

但实际上直接照搬这种思路是不⾏的，⽐如说只有⼀个括号的情况下 (()) 是合法的，但是多种括号的情况下， [(]) 显然是不合法的。

我们这道题就⽤⼀个名为 left 的栈代替之前思路中的 left 变量，遇到左括号就⼊栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配：

```java
public boolean isValid(String s) {
    Stack<Character> left = new Stack<>();
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            left.push(c);
        } else { // 字符 c 是右括号
            if (! left.empty() && leftOf(c) == left.peek()) {
                left.pop();
            } else {
                // 和最近的左括号不匹配
                return false;
            }
        }
    }
    // 是否所有的左括号都被匹配了
    return left.empty();
}

char leftOf(char c) {
    if (c == '}') {
        return '{';
    }
    if (c == ')') {
        return '(';
    }
    return '[';
}
```



## 平衡括号串（一）

> [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)
>
> 给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。
>
> 从形式上讲，只有满足下面几点之一，括号字符串才是有效的：
>
> - 它是一个空字符串，或者
> - 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
>   它可以被写作 (A)，其中 A 是有效字符串。
> - 给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。

```java
public int minAddToMakeValid(String s) {
    // res 记录需要左括号的插⼊次数
    int res = 0;
    // need 变量记录右括号的需求量
    int need = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            // 对右括号的需求 + 1
            need++;
        }

        if (s.charAt(i) == ')') {
            // 对右括号的需求 - 1
            need--;
            if (need == - 1) {
                need = 0;
                // 需插⼊⼀个左括号
                res++;
            }
        }
    }
    return res + need;
}
```

核⼼思路是**以左括号为基准，通过维护对右括号的需求数 need，来计算最⼩的插⼊**
**次数**。需要注意两个地⽅：

**1、当 need == -1 的时候意味着什么？**

因为只有遇到右括号 ) 的时候才会 need--，need == -1 意味着右括号太多了，所以需要插⼊左括号。

**2、算法为什么返回 `res + need`？**

因为 res 记录的左括号的插⼊次数，need 记录了右括号的需求，当 for 循环结束后，若 need 不为 0，那么还需要插入左括号。

## 平衡括号串（二）

>  [1541. 平衡括号字符串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/)
>
> 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
>
> - 任何左括号 '(' 必须对应两个连续的右括号 '))' 。
> - 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
>
> 比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。
>
> 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
>
> 请你返回让 s 平衡的最少插入次数。

```java
public int minInsertions(String s) {
    // need 记录需右括号的需求量，res为插入括号的数量
    int res = 0, need = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            // ⼀个左括号对应两个右括号
            need += 2;
            // 遇到左括号，如果右括号的需求为奇数
            if (need % 2 == 1) {
                // 插入一个右括号
                res++;
                // 有括号的需求-1
                need--;
            }
        }
        if (s.charAt(i) == ')') {
            need--;
            // 说明右括号太多了
            if (need == - 1) {
                // 插入一个左括号
                res++;
                // 同时需要再插入一个右括号（一个左括号对应两个右括号）
                need = 1;
            }
        }
    }
    return res + need;
}
```

## 单调栈

单调栈实际上就是栈，只是利⽤了⼀些巧妙的逻辑，使得每次新元素⼊栈后，栈内的元素都保持有序（单调递增或单调递减）。

听起来有点像堆（heap）？不是的，单调栈⽤途不太⼴泛，只处理⼀种典型的问题，叫做 Next GreaterElement。

### 下一个更大元素 I

> [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
>
> 给你⼀个数组 nums，请你返回⼀个等⻓的结果数组，结果数组中对应索引存储着下⼀个更⼤元素，如果没有更⼤的元素，就存 -1。
>
> ⽐如说，输⼊⼀个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。
>
> 解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。

这道题的暴⼒解法很好想到，就是对每个元素后⾯都进⾏扫描，找到第⼀个更⼤的元素就⾏了。但是暴⼒解法的时间复杂度是 O(n^2)。

这个问题可以这样抽象思考：把数组的元素想象成并列站⽴的⼈，元素⼤⼩想象成⼈的身⾼。这些⼈⾯对你站成⼀列，如何求元素「2」的 Next Greater Number 呢？

很简单，如果能够看到元素「2」，那么他后⾯可⻅的第⼀个⼈就是「2」的 Next Greater Number，因为⽐「2」⼩的元素身⾼不够，都被「2」挡住了，第⼀个露出来的就是答案。

![image-20211201210506687](https://cos.duktig.cn/typora/202112012105272.png)

单调栈模板：

```java
/**
  * 单调栈模板
  */
public int[] nextGreaterElement(int[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack<>();
    // 倒着往栈⾥放
    for (int i = nums.length - 1; i >= 0; i--) {
        // 判定个⼦⾼矮
        while (! stack.empty() && stack.peek() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            stack.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = stack.empty() ? - 1 : stack.peek();
        stack.push(nums[i]);
    }
    return res;
}
```

496. 下一个更大元素 I：

```java
/**
 * 496. 下一个更大元素 I
 * https://leetcode-cn.com/problems/next-greater-element-i/
 */
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Map<Integer, Integer> map = new HashMap<>();
    Stack<Integer> stack = new Stack<>();
    // 倒着往栈⾥放
    for (int i = nums2.length - 1; i >= 0; i--) {
        // 判定个⼦⾼矮
        while (! stack.empty() && stack.peek() <= nums2[i]) {
            // 矮个起开，反正也被挡着了。。。
            stack.pop();
        }
        map.put(nums2[i], stack.isEmpty() ? - 1 : stack.peek());
        stack.push(nums2[i]);
    }
    int[] res = new int[nums1.length];
    for (int i = 0; i < nums1.length; ++ i) {
        res[i] = map.get(nums1[i]);
    }
    return res;
}
```

### 每日温度

> **[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)** 
>
> 请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
>
> ⽐如说给你输⼊ T = [73,74,75,71,69,76]，你返回 [1,1,3,2,1,0]。
>
> 解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天，只要等⼀天就能等到⼀个更暖和的⽓温，后⾯的同理。

这个问题本质上也是找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多少，⽽是问你当前距离 Next Greater Number 的距离⽽已。

相同的思路，直接调⽤单调栈的算法模板，稍作改动就可以，直接上代码吧：

```java
public int[] dailyTemperatures(int[] temperatures) {
    int[] res = new int[temperatures.length];
    Deque<Integer> stack = new LinkedList<>();
    for (int i = temperatures.length - 1; i >= 0; i--) {
        // 构造单调栈
        while (! stack.isEmpty() && temperatures[stack.peek()] <= temperatures[i]) {
            stack.pop();
        }
        // 得到索引间距
        res[i] = stack.isEmpty() ? 0 : (stack.peek() - i);
        // 将索引⼊栈，⽽不是元素
        stack.push(i);
    }
    return res;
}
```

### 下一个更大元素 II（环形数组）

同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？

> [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
>
> ⽐如输⼊⼀个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后⼀个元素 3 绕了⼀圈后找到了⽐⾃⼰⼤的元素 4。

⼀般是通过 % 运算符求模（余数），来获得环形特效：

```java
int[] arr = {1,2,3,4,5}; 
int n = arr.length, index = 0; 
while (true) { 
    print(arr[index % n]); 
    index++; 
} 
```

这个问题肯定还是要⽤单调栈的解题模板，但难点在于，⽐如输⼊是 [2,1,2,4,3]，对于最后⼀个元素 3，如何找到元素 4 作为 Next Greater Number?

**对于这种需求，常⽤套路就是将数组⻓度翻倍：**

![image-20211201214910152](https://cos.duktig.cn/typora/202112012149264.png)

这样，元素 3 就可以找到元素 4 作为 Next Greater Number 了，⽽且其他的元素都可以被正确地计算。

```java
public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] res = new int[nums.length];
    Deque<Integer> stack = new LinkedList<>();
    // 假装这个数组⻓度翻倍了
    for (int i = 2 * n - 1; i >= 0; i--) {
        // 索引要求模，其他的和模板⼀样
        while (! stack.isEmpty() && stack.peek() <= nums[i % n]) {
            stack.pop();
        }
        res[i % n] = stack.isEmpty() ? - 1 : stack.peek();
        stack.push(nums[i % n]);
    }
    return res;
}
```

## 单调队列

单调队列就是⼀个「队列」，只是使⽤了⼀点巧妙的⽅法，使得队列中的元素全都是单调递增（或递减）的。

「单调队列」这个数据结构可以解决 **滑动窗⼝** 相关的问题。

### 滑动窗口最大值

> [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
>
> 给你输⼊⼀个数组 nums 和⼀个正整数 k，有⼀个⼤⼩为 k 的窗⼝在 nums 上从左⾄右滑动，请你输出每次窗⼝中 k 个元素的最⼤值。
>
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]

这道题不复杂，难点在于如何在 `O(1)` 时间算出每个「窗⼝」中的最⼤值，使得整个算法在线性时间完成。

这种问题的⼀个特殊点在于，「窗⼝」是不断滑动的，也就是你得动态地计算窗⼝中的最⼤值。

对于这种动态的场景，很容易得到⼀个结论：

**在⼀堆数字中，已知最值为 A，如果给这堆数添加⼀个数 B，那么⽐较⼀下 A 和 B 就可以⽴即算出新的最值；但如果减少⼀个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历所有数重新找新的最值**。

每个窗⼝前进的时候，要添加⼀个数同时减少⼀个数，所以想在 O(1) 的时间得出新的最值，不是那么容易的，需要**「单调队列」**这种特殊的数据结构来辅助。

⼀个「单调队列」的操作：

```java
interface MonotonicQueue { 
    // 在队尾添加元素 n 
    void push(int n); 
    // 返回当前队列中的最⼤值 
    int max(); 
    // 队头元素如果是 n，删除它 
    void pop(int n); 
}
```

这⼏个操作的时间复杂度都是 O(1)。

这道「滑动窗⼝」问题的解答框架：

```java
public int[] maxSlidingWindow(int[] nums, int k) { 
    MonotonicQueue window = new MonotonicQueue(); 
    List<Integer> res = new ArrayList<>(); 

    for (int i = 0; i < nums.length; i++) { 
        if (i < k - 1) { 
            //先把窗⼝的前 k - 1 填满 
            window.push(nums[i]); 
        } else { 
            // 窗⼝开始向前滑动，移⼊新元素 
            window.push(nums[i]); 
            // 将当前窗⼝中的最⼤元素记⼊结果 
            res.add(window.max()); 
            // 移出最后的元素 
            window.pop(nums[i - k + 1]); 
        } 
    } 
    // 将 List 类型转化成 int[] 数组作为返回值 
    int[] arr = new int[res.size()]; 
    for (int i = 0; i < res.size(); i++) { 
        arr[i] = res.get(i); 
    } 
    return arr; 
} 
```

![image-20211202100046677](https://cos.duktig.cn/typora/202112021000097.png)

**实现单调队列数据结构**

```java
/**
 * 单调队列的实现
 */
class MonotonicQueue {

    // 双链表，⽀持头部和尾部增删元素
    private Deque<Integer> q = new LinkedList<>();

    /**
     * 单调队列新增元素：
     * 新增前删除前面比当前元素小的元素，保证队列单调递减
     * 出队时，队首即最大值
     */
    public void push(int n) {
        // 将前⾯⼩于⾃⼰的元素都删除
        while (! q.isEmpty() && q.getLast() < n) {
            q.pollLast();
        }
        q.addLast(n);
    }

    /**
     * 队头的元素肯定是最⼤的
     */
    public int max() {
        return q.getFirst();
    }

    /**
     * 在队头删除元素 n
     */
    public void pop(int n) {
        if (n == q.getFirst()) {
            q.pollFirst();
        }
    }

}
```

有⼀点细节问题不要忽略，在实现 MonotonicQueue 时，我们使⽤了 Java 的 LinkedList，因为链表结构⽀持在头部和尾部快速增删元素；⽽在解法代码中的 res 则使⽤的 ArrayList 结构，因为后续会按照索引取元素，所以数组结构更合适。

**算法复杂度分析**

可能疑惑，push 操作中含有 while 循环，时间复杂度应该不是 O(1) 呀，那么本算法的时间复杂度应该不是线性时间吧？

单独看 push 操作的复杂度确实不是 O(1)，但是算法整体的复杂度依然是 O(N) 线性时间。要这样想，nums 中的每个元素最多被 push 和 pop ⼀次，没有任何多余操作，所以整体的复杂度还是 O(N)。空间复杂度就很简单了，就是窗⼝的⼤⼩ O(k)。



# 字符串

## 滑动窗口

**滑动窗⼝算法的思路是这样：**

1、我们在字符串 S 中使⽤双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间[left, right) 称为⼀个「窗⼝」。

2、我们先不断地增加 right 指针扩⼤窗⼝ [left, right)，直到窗⼝中的字符串符合要求（包含了 T 中的所有字符）。

3、此时，我们停⽌增加 right，转⽽不断增加 left 指针缩⼩窗⼝ [left, right)，直到窗⼝中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新⼀轮结果。

4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

**思考以下四个问题：**

1、当移动 right 扩⼤窗⼝，即加⼊字符时，应该更新哪些数据？

2、什么条件下，窗⼝应该暂停扩⼤，开始移动 left 缩⼩窗⼝？

3、当移动 left 缩⼩窗⼝，即移出字符时，应该更新哪些数据？

4、我们要的结果应该在扩⼤窗⼝时还是缩⼩窗⼝时进⾏更新？

```java
/**
 * 滑动窗⼝算法框架
 */
public void slidingWindow(String s, String t) {
    // needs代表t中字符出现次数，window代表窗口中相应字符出现的次数
    Map<Character, Integer> need = new HashMap<>(), window = new HashMap<>();
    // 将t对应字符及次数存储到map
    for (char c : t.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }
    // 左右指针
    int left = 0, right = 0;
    // valid 变量表示窗⼝中满⾜ need 条件的字符个数；如果 valid 和 need.size 的⼤⼩相同，则说明窗⼝已满⾜条件，已经完全覆盖了串 T
    int valid = 0;
    while (right < s.length()) {
        // c 是将移⼊窗⼝的字符
        char c = s.charAt(right);
        // 右移窗⼝
        right++;
        // 进⾏窗⼝内数据的⼀系列更新

        /* debug 输出的位置 */
        System.out.printf("window: [%d, %d)\n", left, right);

        // 判断左侧窗⼝是否要收缩（条件根据具体题意判断）
        while (left <= right) {
            // d 是将移出窗⼝的字符
            char d = s.charAt(left);
            // 左移窗⼝
            left++;
            // 进⾏窗⼝内数据的⼀系列更新

        }
    }
}
```

## 去除重复字母

>  [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)
>
> 这道题和第 1081 题「不同字符的最小子序列」的解法是完全相同的
>
> 要求一、**要去重**。
>
> 要求二、去重字符串中的字符顺序**不能打乱`s`中字符出现的相对顺序**。
>
> 要求三、在所有符合上一条要求的去重字符串中，**字典序最小**的作为最终结果。
>
> 上述三条要求中，要求三可能有点难理解，举个例子。
>
> 比如说输入字符串`s = "babc"`，去重且符合相对位置的字符串有两个，分别是`"bac"`和`"abc"`，但是我们的算法得返回`"abc"`，因为它的字典序更小。

按理说，如果我们想要有序的结果，那就得对原字符串排序对吧，但是排序后就不能保证符合`s`中字符出现顺序了，这似乎是矛盾的。

「单调栈」的思路可以解此题。

**我们先暂时忽略要求三，用「栈」来实现一下要求一和要求二**。

```java
/**
 * 用栈实现 要求一和要求二
 */
public String removeDuplicateLettersTemp(String s) {
    // 存放去重的结果
    Deque<Character> stk = new LinkedList<>();
    // 布尔数组初始值为 false，记录栈中是否存在某个字符
    // 输入字符均为 ASCII 字符，所以大小 256 够用了
    boolean[] inStack = new boolean[256];

    for (char c : s.toCharArray()) {
        // 如果字符 c 存在栈中，直接跳过
        if (inStack[c]) {
            continue;
        }
        // 若不存在，则插入栈顶并标记为存在
        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (! stk.isEmpty()) {
        sb.append(stk.pop());
    }
    // 栈中元素插入顺序是反的，需要 reverse 一下
    return sb.reverse().toString();
}
```

这段代码的逻辑很简单吧，就是用布尔数组`inStack`记录栈中元素，达到去重的目的，**此时栈中的元素都是没有重复的**。

如果输入`s = "bcabc"`，这个算法会返回`"bca"`，已经符合要求一和要求二了，但是题目希望要的答案是`"abc"`对吧。

那我们想一想，如果想满足要求三，保证字典序，需要做些什么修改？

在向栈`stk`中插入字符`'a'`的这一刻，我们的算法需要知道，字符`'a'`的字典序和之前的两个字符`'b'`和`'c'`相比，谁大谁小？

**如果当前字符`'a'`比之前的字符字典序小，就有可能需要把前面的字符 pop 出栈，让`'a'`排在前面，对吧**？

那么，我们先改一版代码：

```java
/**
 * 保证"bcabc"，去重后为"abc"，而不是"bca"。满足要求三
 * 但是存在问题，如果是"bcac"，这个解法会有问题
 */
private String removeDuplicateLetters2(String s) {
    Deque<Character> stk = new LinkedList<>();
    boolean[] inStack = new boolean[256];

    for (char c : s.toCharArray()) {
        if (inStack[c]) {
            continue;
        }

        // 插入之前，和之前的元素比较一下大小
        // 如果字典序比前面的小，pop 前面的元素
        while (! stk.isEmpty() && stk.peek() > c) {
            // 弹出栈顶元素，并把该元素标记为不在栈中
            inStack[stk.pop()] = false;
        }

        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (! stk.isEmpty()) {
        sb.append(stk.pop());
    }
    return sb.reverse().toString();
}
```

这段代码也好理解，就是插入了一个 while 循环，连续 pop 出比当前字符小的栈顶字符，直到栈顶元素比当前元素的字典序还小为止。只是不是有点「单调栈」的意思了？

这样，对于输入`s = "bcabc"`，我们可以得出正确结果`"abc"`了。

但是，如果我改一下输入，假设`s = "bcac"`，按照刚才的算法逻辑，返回的结果是`"ac"`，而正确答案应该是`"bac"`，分析一下这是怎么回事？

很容易发现，因为`s`中只有唯一一个`'b'`，即便字符`'a'`的字典序比字符`'b'`要小，字符`'b'`也不应该被 pop 出去。

那问题出在哪里？

**我们的算法在`stk.peek() > c`时才会 pop 元素，其实这时候应该分两种情况**：

情况一、如果`stk.peek()`这个字符之后还会出现，那么可以把它 pop 出去，反正后面还有嘛，后面再 push 到栈里，刚好符合字典序的要求。

情况二、如果`stk.peek()`这个字符之后不会出现了，前面也说了栈中不会存在重复的元素，那么就不能把它 pop 出去，否则你就永远失去了这个字符。

回到`s = "bcac"`的例子，插入字符`'a'`的时候，发现前面的字符`'c'`的字典序比`'a'`大，且在`'a'`之后还存在字符`'c'`，那么栈顶的这个`'c'`就会被 pop 掉。

while 循环继续判断，发现前面的字符`'b'`的字典序还是比`'a'`大，但是在`'a'`之后再没有字符`'b'`了，所以不应该把`'b'`pop 出去。

**那么关键就在于，如何让算法知道字符`'a'`之后有几个`'b'`有几个`'c'`呢**？

也不难，只要再改一版代码：

```java
/**
 * 满足所有要求的答案
 */
public String removeDuplicateLetters(String s) {
    Deque<Character> stk = new LinkedList<>();

    // 维护一个计数器记录字符串中字符的数量，因为输入为 ASCII 字符，大小 256 够用了
    int[] count = new int[256];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i)]++;
    }

    boolean[] inStack = new boolean[256];
    for (char c : s.toCharArray()) {
        // 每遍历过一个字符，都将对应的计数减一
        count[c]--;

        if (inStack[c]) {
            continue;
        }

        while (! stk.isEmpty() && stk.peek() > c) {
            // 若之后不存在栈顶元素了，则停止 pop
            if (count[stk.peek()] == 0) {
                break;
            }
            // 若之后还有，则可以 pop
            inStack[stk.pop()] = false;
        }
        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (! stk.isEmpty()) {
        sb.append(stk.pop());
    }
    return sb.reverse().toString();
}
```

我们用了一个计数器`count`，当字典序较小的字符试图「挤掉」栈顶元素的时候，在`count`中检查栈顶元素是否是唯一的，只有当后面还存在栈顶元素的时候才能挤掉，否则不能挤掉。

至此，这个算法就结束了，时间空间复杂度都是 O(N)。

**你还记得我们开头提到的三个要求吗？我们是怎么达成这三个要求的**？

要求一、通过`inStack`这个布尔数组做到栈`stk`中不存在重复元素。

要求二、我们顺序遍历字符串`s`，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和`s`中出现的顺序一致。

这里也可以想到为什么要用「栈」这种数据结构，因为先进后出的结构允许我们立即操作刚插入的字符，如果用「队列」的话肯定是做不到的。

要求三、我们用类似单调栈的思路，配合计数器`count`不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小。

当然，由于栈的结构特点，我们最后需要把栈中元素取出后再反转一次才是最终结果。

# 二叉树

二叉树节点的定义：

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 二叉树的重要性

先刷⼆叉树的题⽬，先刷⼆叉树的题⽬，先刷⼆叉树的题⽬，因为很多经典算法，以及我们前⽂讲过的所有**回溯、动归、分治**算法，其实都是树的问题，⽽树的问题就永远逃不开树的递归遍历框架这⼏⾏破代码：

```java
/* ⼆叉树遍历框架 */
void traverse(TreeNode root) { 
    // 前序遍历 
    traverse(root.left) 
    // 中序遍历 
    traverse(root.right) 
    // 后序遍历 
} 
```

经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？

**快速排序就是个⼆叉树的前序遍历，归并排序就是个⼆叉树的后序遍历**。

快速排序的逻辑是，若要对 nums[lo..hi] 进⾏排序，我们先找⼀个分界点 p，通过交换元素使得nums[lo..p-1] 都⼩于等于 nums[p]，且 nums[p+1..hi] 都⼤于nums[p]，然后递归地去nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。

快速排序的代码框架如下：

```java
void sort(int[] nums, int lo, int hi) { 
    /****** 前序遍历位置 ******/ 
    // 通过交换元素构建分界点 p 
    int p = partition(nums, lo, hi); 
    /************************/ 
 
    sort(nums, lo, p - 1); 
    sort(nums, p + 1, hi); 
}
```

先构造分界点，然后去左右⼦数组构造分界点，你看这不就是⼀个⼆叉树的前序遍历吗？

再说说归并排序的逻辑，若要对 nums[lo..hi] 进⾏排序，我们先对nums[lo..mid] 排序，再对nums[mid+1..hi] 排序，最后把这两个有序的⼦数组合并，整个数组就排好序了。

归并排序的代码框架如下：

```java
void sort(int[] nums, int lo, int hi) { 
    int mid = (lo + hi) / 2; 
    sort(nums, lo, mid); 
    sort(nums, mid + 1, hi); 
 
    /****** 后序遍历位置 ******/ 
    // 合并两个排好序的⼦数组 
    merge(nums, lo, mid, hi); 
    /************************/ 
} 
```

先对左右⼦数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是⼆叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。

如果你⼀眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是⼿到擒来，从框架慢慢扩展就能写出算法了。

旨在说明，⼆叉树的算法思想的运⽤⼴泛，甚⾄可以说，只要涉及递归，都可以抽象成⼆叉树的问题。

## 写递归算法的秘诀

**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节**。

⽤⼀个具体的例⼦来说，⽐如说让你计算⼀棵⼆叉树共有⼏个节点：

```java
// 定义：count(root) 返回以 root 为根的树有多少节点
int count(TreeNode root) { 
    // base case 
    if (root == null) return 0; 
    // ⾃⼰加上⼦树的节点数就是整棵树的节点数 
    return 1 + count(root.left) + count(root.right); 
} 
```

这个问题⾮常简单，⼤家应该都会写这段代码，root 本身就是⼀个节点，加上左右⼦树的节点数就是以root 为根的树的节点总数。

左右⼦树的节点数怎么算？其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义，递归调⽤ count 函数即可算出来。

**写树相关的算法，简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调⽤⼦节点**，递归调⽤会让孩⼦节点做相同的事情。

所谓「该做什么」就是让你想清楚写什么代码能够实现题⽬想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。

## 翻转二叉树

```
翻转前：
     4 
   /   \ 
  2     7 
 / \   / \ 
1   3 6   9
翻转后（镜像翻转）：
     4 
   /   \ 
  7     2 
 / \   / \ 
9   6 3   1

```

通过观察，**我们发现只要把⼆叉树上的每⼀个节点的左右⼦节点进⾏交换，最后的结果就是完全翻转之后的⼆叉树**。

```java
// 将整棵树的节点翻转
TreeNode invertTree(TreeNode root) { 
    // base case 
    if (root == null) { 
        return null; 
    } 
 
    /**** 前序遍历位置 ****/ 
    // root 节点需要交换它的左右⼦节点 
    TreeNode tmp = root.left; 
    root.left = root.right; 
    root.right = tmp; 
 
    // 让左右⼦节点继续翻转它们的⼦节点 
    invertTree(root.left); 
    invertTree(root.right); 
     
    return root; 
} 
```

这道题⽬⽐较简单，关键思路在于我们发现翻转整棵树就是交换每个节点的左右⼦节点，于是我们把交换左右⼦节点的代码放在了前序遍历的位置。

值得⼀提的是，如果把交换左右⼦节点的代码复制粘贴到后序遍历的位置也是可以的，但是直接放到中序遍历的位置是不⾏的，请你想⼀想为什么？这个应该不难想到，我会把答案置顶在公众号留⾔区。

⾸先讲这道题⽬是想告诉你，**⼆叉树题⽬的⼀个难点就是，如何把题⽬的要求细化成每个节点需要做的事情**。

## 填充每个节点的下一个右侧节点指针

> [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)
>
> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> ```java
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> ```
>
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。
>

题⽬的意思就是把⼆叉树的每⼀层节点都⽤ next 指针连接起来：

![image-20211208174402701](https://cos.duktig.cn/typora/202112081744230.png)

⽽且题⽬说了，输⼊是⼀棵「完美⼆叉树」，形象地说整棵⼆叉树是⼀个正三⻆形，除了最右侧的节点 next指针会指向 null，其他节点的右侧⼀定有相邻的节点。

我们可以模仿上⼀道题，写出如下代码：

```java
Node connect(Node root) { 
    if (root == null || root.left == null) { 
        return root; 
    } 
 
    root.left.next = root.right; 
 
    connect(root.left); 
    connect(root.right); 
 
    return root; 
} 
```

这样其实有很⼤问题：节点 5 和节点 6 不属于同⼀个⽗节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。

回想刚才说的，**⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情**，但是如果只依赖⼀个节点的话，肯定是没办法连接「跨⽗节点」的两个相邻节点的。

那么，我们的做法就是增加函数参数，⼀个节点做不到，我们就给他安排两个节点，「将每⼀层⼆叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」。

```java
// 主函数
Node connect(Node root) { 
    if (root == null) return null; 
    connectTwoNode(root.left, root.right); 
    return root; 
}

// 辅助函数
void connectTwoNode(Node node1, Node node2) { 
    if (node1 == null || node2 == null) { 
        return; 
    } 
    /* 前序遍历位置 */ 
    // 将传⼊的两个节点连接 
    node1.next = node2; 
     
    // 连接相同⽗节点的两个⼦节点 
    connectTwoNode(node1.left, node1.right); 
    connectTwoNode(node2.left, node2.right); 
    // 连接跨越⽗节点的两个⼦节点 
    connectTwoNode(node1.right, node2.left); 
} 
```

这样，connectTwoNode 函数不断递归，可以⽆死⻆覆盖整棵⼆叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，这道题就解决了。

## 将⼆叉树展开为链表

> [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给 flatten 函数输⼊⼀个节点 root，那么以 root 为根的⼆叉树就会被拉平为⼀条链表。

我们再梳理⼀下，如何按题⽬要求把⼀棵树拉平成⼀条链表？很简单，以下流程：

1、将 root 的左⼦树和右⼦树拉平。

2、将 root 的右⼦树接到左⼦树下⽅，然后将整个左⼦树作为右⼦树。

![image-20211208204424271](https://cos.duktig.cn/typora/202112082044859.png)

上⾯三步看起来最难的应该是第⼀步对吧，如何把 root 的左右⼦树拉平？其实很简单，按照 flatten 函数的定义，对 root 的左右⼦树递归调⽤ flatten 函数即可：

```java
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) { 
    // base case 
    if (root == null) return; 
     
    flatten(root.left); 
    flatten(root.right); 
 
    /* 后序遍历位置 */ 
    // 1、左右⼦树已经被拉平成⼀条链表 
    TreeNode left = root.left; 
    TreeNode right = root.right; 
     
    // 2、将左⼦树作为右⼦树 
    root.left = null; 
    root.right = left; 
 
    // 3、将原先的右⼦树接到当前右⼦树的末端 
    TreeNode p = root; 
    while (p.right != null) { 
        p = p.right; 
    } 
    p.right = right; 
}   
```

## 最大二叉树

**把题⽬的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就⾏了**，我们千万不要跳进递归的细节⾥。

> [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)
>
> 给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：
>
> 1. 二叉树的根是数组 nums 中的最大元素。
> 2. 左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
> 3. 右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
>
> 返回有给定数组 nums 构建的 最大二叉树 。

按照我们刚才说的，先明确根节点做什么？**对于构造⼆叉树的问题，根节点要做的就是把想办法把⾃⼰构造出来**。

我们肯定要遍历数组把找到最⼤值 maxVal，把根节点 root 做出来，然后对 maxVal 左边的数组和右边的数组进⾏递归调⽤，作为 root 的左右⼦树。

按照题⽬给出的例⼦，输⼊的数组为 [3,2,1,6,0,5]，对于整棵树的根节点来说，其实在做这件事，伪代码如下：

```
TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) { 
    // 找到数组中的最⼤值 
    TreeNode root = new TreeNode(6); 
    // 递归调⽤构造左右⼦树 
    root.left = constructMaximumBinaryTree([3,2,1]); 
    root.right = constructMaximumBinaryTree([0,5]); 
    return root; 
} 
```

**对于每个根节点，只需要找到当前 nums 中的最⼤值和对应的索引，然后递归调⽤左右数组构造左右⼦树即可**。

```java
/**
 * 主函数
 */
public TreeNode constructMaximumBinaryTree(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

/**
 * 将 nums[low..high] 构造成符合条件的树，返回根节点
 *
 * @param nums 待构建二叉树的数组
 * @param low  子树的左端数组下标
 * @param high 子树的右端数组下标
 * @return 构造好子树的根节点
 */
private TreeNode build(int[] nums, int low, int high) {
    // 递归的终止条件
    if (low > high) {
        return null;
    }

    // 找到数组中的最大值和对应的索引
    int index = - 1, maxVal = Integer.MIN_VALUE;
    for (int i = low; i <= high; i++) {
        if (maxVal < nums[i]) {
            maxVal = nums[i];
            index = i;
        }
    }

    // 最大值构建根节点
    TreeNode root = new TreeNode(maxVal);
    // 递归构建左右子树
    root.left = build(nums, low, index - 1);
    root.right = build(nums, index + 1, high);

    return root;
}
```

## 通过前序和中序遍历结果构造二叉树

> [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
>
> 给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

 **我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右⼦树即可**。

遍历顺序差异，导致了 preorder 和 inorder 数组中的元素分布有如下特点：

![image-20211209140334133](https://cos.duktig.cn/typora/202112091403972.png)

找到根节点是很简单的，前序遍历的第⼀个值 preorder[0] 就是根节点的值，关键在于如何通过根节点的值，将 preorder 和 postorder 数组划分成两半，构造根节点的左右⼦树？

```java
/** 主函数 */
TreeNode buildTree(int[] preorder, int[] inorder) { 
    return build(preorder, 0, preorder.length - 1, 
                 inorder, 0, inorder.length - 1); 
} 
 
/**  
   若前序遍历数组为 preorder[preStart..preEnd]， 
   中序遍历数组为 inorder[inStart..inEnd]， 
   构造⼆叉树，返回该⼆叉树的根节点  
*/
TreeNode build(int[] preorder, int preStart, int preEnd,  
               int[] inorder, int inStart, int inEnd) { 
    // root 节点对应的值就是前序遍历数组的第⼀个元素 
    int rootVal = preorder[preStart]; 
    // rootVal 在中序遍历数组中的索引 
    int index = 0; 
    for (int i = inStart; i <= inEnd; i++) { 
        if (inorder[i] == rootVal) { 
            index = i; 
            break; 
        } 
    } 
 
    TreeNode root = new TreeNode(rootVal); 
    // 递归构造左右⼦树 
    root.left = build(preorder, ?, ?, inorder, ?, ?); 
 
    root.right = build(preorder, ?, ?, inorder, ?, ?);
    
    return root; 
} 
```

对于代码中的 rootVal 和 index 变量，就是下图这种情况：

![image-20211209140103381](https://cos.duktig.cn/typora/202112091401506.png)

现在我们来看图做填空题，下⾯这⼏个问号处应该填什么：

```java
root.left = build(preorder, ?, ?,inorder, ?, ?); 
root.right = build(preorder, ?, ?, inorder, ?, ?); 
```

对于左右⼦树对应的 inorder 数组的起始索引和终⽌索引⽐较容易确定：

![image-20211209140941940](https://cos.duktig.cn/typora/202112091409909.png)

对于 preorder 数组呢？如何确定左右数组对应的起始索引和终⽌索引？

这个可以通过左⼦树的节点数推导出来，假设左⼦树的节点数为 leftSize，那么 preorder 数组上的索引情况是这样的：

![image-20211209141131891](https://cos.duktig.cn/typora/202112091411900.png)

```java
int leftSize = index - inStart; 
 
root.left = build(preorder, preStart + 1, preStart + leftSize, 
                  inorder, inStart, index - 1); 
 
root.right = build(preorder, preStart + leftSize + 1, preEnd, 
                   inorder, index + 1, inEnd); 
```

完整代码如下：

```java
/**
 * 主函数
 */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

/**
 * 若前序遍历数组为 preorder[preStart..preEnd]，
 * 中序遍历数组为 inorder[inStart..inEnd]，
 * 构造⼆叉树，返回该⼆叉树的根节点
 */
private TreeNode build(int[] preorder, int preStart, int preEnd,
                       int[] inorder, int inStart, int inEnd) {
    // 递归终止条件
    if (preStart > preEnd) {
        return null;
    }

    // root 节点对应的值就是前序遍历数组的第⼀个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    // 根节点左边有几个元素
    int leftSize = index - inStart;

    // 先构造出当前根节点
    TreeNode root = new TreeNode(rootVal);

    // 递归构造左右⼦树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
            inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
            inorder, index + 1, inEnd);

    return root;
}
```



## 通过后序和中序遍历结果构造⼆叉树

>  [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
>
> 根据一棵树的中序遍历与后序遍历构造二叉树。

![image-20211209143258007](https://cos.duktig.cn/typora/202112091433423.png)

这道题和上⼀题的关键区别是，后序遍历和前序遍历相反，根节点对应的值为 postorder 的最后⼀个元素。

现在 postoder 和 inorder 对应的状态如下：

![image-20211209143400312](https://cos.duktig.cn/typora/202112091434857.png)

```java
/**
 * 主函数
 */
public TreeNode buildTree(int[] inorder, int[] postorder) {
    return build(inorder, 0, inorder.length - 1,
            postorder, 0, postorder.length - 1);
}

/**
 * 中序遍历数组为 inorder[inStart..inEnd]，
 * 后序遍历数组为 postorder[postStart..postEnd]，
 * 构造⼆叉树，返回该⼆叉树的根节点
 */
private TreeNode build(int[] inorder, int inStart, int inEnd,
                       int[] postorder, int postStart, int postEnd) {
    // 递归终止条件
    if (inStart > inEnd) {
        return null;
    }
    
    // root 节点对应的值就是后序遍历数组的最后⼀个元素
    int rootVal = postorder[postEnd];
    
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    
    // 左⼦树的节点个数
    int leftSize = index - inStart;
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右⼦树
    root.left = build(inorder, inStart, index - 1,
            postorder, postStart, postStart + leftSize - 1);

    root.right = build(inorder, index + 1, inEnd,
            postorder, postStart + leftSize, postEnd - 1);
    
    return root;
}
```

有了前⼀题的铺垫，这道题很快就解决了，⽆⾮就是 rootVal 变成了最后⼀个元素，再改改递归函数的参数⽽已，只要明⽩⼆叉树的特性，也不难写出来。

最后呼应下前⽂，**做⼆叉树的问题，关键是把题⽬的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就⾏了**。

## 寻找重复的子树

> [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)
>
> 给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。
>
> 两棵树重复是指它们具有相同的结构以及相同的结点值。
>
> 示例 1：
>
> ```
> 
>      1
>     / \
>    2   3
>   /   / \
>  4   2   4
>     /
>    4
> ```
>
> 下面是两个重复的子树：
>
>    2
>   /
>  4
> 和
>
>  4
> 因此，你需要以列表的形式返回上述重复子树的根结点。

**如何判断我们应该用前序还是中序还是后序遍历的框架**？

**根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了**。

这题咋做呢？**还是老套路，先思考，对于某一个节点，它应该做什么**。

如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点**：

**1、以我为根的这棵二叉树（子树）长啥样**？

**2、以其他节点为根的子树都长啥样**？

我得知道自己长啥样，还得知道别人长啥样，然后才能知道有没有人跟我重复，对不对？

好，那我们一个一个来解决，先来思考，**我如何才能知道以自己为根的二叉树长啥样**？

其实看到这个问题，就可以判断本题要使用「后序遍历」框架来解决。

为什么？很简单呀，我要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子？

如果你还绕不过来，我再来举个非常简单的例子：计算一棵二叉树有多少个节点。这个代码应该会写吧：

```java
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 先算出左右子树有多少节点
    int left = count(root.left);
    int right = count(root.right);
    /* 后序遍历代码位置 */
    // 加上自己，就是整棵二叉树的节点数
    int res = left + right + 1;
    return res;
}
```

这不就是标准的后序遍历框架嘛，和我们本题在思路上没啥区别对吧。

现在，明确了要用后序遍历，那应该 **怎么描述一棵二叉树的模样呢**？

二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。

所以，我们可以通过拼接字符串的方式把二叉树序列化，看下代码：

```java
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + "," + right + "," + root.val;
    return subTree;
}
```

我们用非数字的特殊符`#`表示空指针，并且用字符`,`分隔每个二叉树节点值，这属于序列化二叉树的套路了。

注意我们`subTree`是按照左子树、右子树、根节点这样的顺序拼接字符串，也就是后序遍历顺序。你完全可以按照前序或者中序的顺序拼接字符串，因为这里只是为了描述一棵二叉树的样子，什么顺序不重要。

**这样，我们第一个问题就解决了，对于每个节点，递归函数中的`subTree`变量就可以描述以该节点为根的二叉树**。

**现在我们解决第二个问题，我知道了自己长啥样，怎么知道别人长啥样**？这样我才能知道有没有其他子树跟我重复对吧。

这很简单呀，我们借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了么？

初步思路可以使用`HashSet`记录子树，代码如下：

```java
// 记录所有子树
HashSet<String> memo = new HashSet<>();
// 记录重复的子树根节点
List<TreeNode> res = new LinkedList<>();

String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    if (memo.contains(subTree)) {
        // 有人和我重复，把自己加入结果列表
        res.add(root);
    } else {
        // 暂时没人跟我重复，把自己加入集合
        memo.add(subTree);
    }
    return subTree;
}
```

但是呢，这有个问题，如果出现多棵重复的子树，结果集`res`中必然出现重复，而题目要求不希望出现重复。

为了解决这个问题，可以把`HashSet`升级成`HashMap`，额外记录每棵子树的出现次数：

```java
// 记录所有子树以及出现的次数
HashMap<String, Integer> memo = new HashMap<>();
// 记录重复的子树根节点
List<TreeNode> res = new LinkedList<>();

/* 主函数 */
List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    return res;
}

/* 辅助函数 */
String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    int freq = memo.getOrDefault(subTree, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加一
    memo.put(subTree, freq + 1);
    return subTree;
}
```

## 二叉树的序列化与反序列化

> 给你输入一棵二叉树的根节点 `root`，要求你实现如下一个类：
>
> ```java
> public class Codec {
> 
>     // 把一棵二叉树序列化成字符串
>     public String serialize(TreeNode root) {}
> 
>     // 把字符串反序列化成二叉树
>     public TreeNode deserialize(String data) {}
> }
> ```
>
> 我们可以用 `serialize` 方法将二叉树序列化成字符串，用 `deserialize` 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。

比如说输入如下这样一棵二叉树：

<img src="https://cos.duktig.cn/typora/202112161122197.png" alt="image-20211216112236780" style="zoom:50%;" />

`serialize` 方法也许会把它序列化成字符串 `2,1,#,6,3,#,#`，其中 `#` 表示 `null` 指针，那么把这个字符串再输入 `deserialize` 方法，依然可以还原出这棵二叉树。也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。

想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。**所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式**。

### 前序遍历

前序遍历 元素的顺序是怎样的？比如如下二叉树（`#` 代表空指针 null），可以直观看出前序遍历做的事情： 

![image-20211216112447460](https://cos.duktig.cn/typora/202112161124494.png)

至此，我们已经可以写出序列化函数 `serialize` 的代码了：

```java
String SEP = ",";
String NULL = "#";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

现在，思考一下如何写 `deserialize` 函数，将字符串反过来构造二叉树。

首先我们可以把字符串转化成列表：

```java
String data = "1,2,#,4,#,#,3,#,#,";
String[] nodes = data.split(",");
```

这样，`nodes` 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？

*PS：一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 `node` 列表包含空指针的信息，所以只使用 `node` 列表就可以还原二叉树。*

那么，反序列化过程也是一样，**先确定根节点 `root`，然后遵循前序遍历的规则，递归生成左右子树即可**：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    // 将字符串转化成列表
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    /****** 前序遍历位置 ******/
    // 列表最左侧就是根节点
    String first = nodes.removeFirst();
    if (first.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));
    /***********************/

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}
```

我们发现，根据树的递归性质，`nodes` 列表的第一个元素就是一棵树的根节点，所以只要将列表的第一个元素取出作为根节点，剩下的交给递归函数去解决即可。

### 后序遍历

明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 `serialize` 序列化方法，只需要稍微修改辅助方法即可：

```java
/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    serialize(root.left, sb);
    serialize(root.right, sb);

    /****** 后序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/
}
```

我们把对 `StringBuilder` 的拼接操作放到了后续遍历的位置，后序遍历导致结果的顺序发生变化：

![image-20211216140728214](https://cos.duktig.cn/typora/202112161407340.png)

关键的难点在于，如何实现后序遍历的 `deserialize` 方法呢？是不是也简单地将关键代码放到后序遍历的位置就行了呢？

**没这么简单，**回想刚才我们前序遍历方法中的 `deserialize` 方法，第一件事情在做什么？

**`deserialize` 方法首先寻找 `root` 节点的值，然后递归计算左右子节点**。那么我们这里也应该顺着这个基本思路走，后续遍历中，`root` 节点的值能不能找到？

`root` 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 `root`，然后递归调用生成 `root` 的左右子树。**注意，根据上图，从后往前在 `nodes` 列表中取元素，一定要先构造 `root.right` 子树，后构造 `root.left` 子树**。

看完整代码：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;
    // 从后往前取出元素
    String last = nodes.removeLast();
    if (last.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(last));
    // 先构造右子树，后构造左子树
    root.right = deserialize(nodes);
    root.left = deserialize(nodes);

    return root;
}
```

至此，后续遍历实现的序列化、反序列化方法也都实现了。

### 中序遍历

**中序遍历不能实现。只能完成序列化，不能完成反序列化，因为反序列化时需要先找到 root 节点，而中序遍历的 root节点在中间，无法直接确定。**

### 层序遍历

首先，先写出层级遍历二叉树的代码框架：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        System.out.println(root.val);
        /*****************/

        if (cur.left != null) {
            q.offer(cur.left);
        }

        if (cur.right != null) {
            q.offer(cur.right);
        }
    }
}
```

**上述代码是标准的二叉树层级遍历框架**，从上到下，从左到右打印每一层二叉树节点的值，可以看到，队列 `q` 中不会存在 null 指针。

不过我们在反序列化的过程中是需要记录空指针 null 的，所以可以把标准的层级遍历框架略作修改：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        if (cur == null) continue;
        System.out.println(root.val);
        /*****************/

        q.offer(cur.left);
        q.offer(cur.right);
    }
}
```

这样也可以完成层级遍历，只不过我们把对空指针的检验从「将元素加入队列」的时候改成了「从队列取出元素」的时候。

那么我们完全仿照这个框架即可写出序列化方法：

```java
String SEP = ",";
String NULL = "#";

/* 将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    if (root == null) return "";
    StringBuilder sb = new StringBuilder();
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        if (cur == null) {
            sb.append(NULL).append(SEP);
            continue;
        }
        sb.append(cur.val).append(SEP);
        /*****************/

        q.offer(cur.left);
        q.offer(cur.right);
    }

    return sb.toString();
}
```

层级遍历序列化得出的结果如下图：

![image-20211216141528085](https://cos.duktig.cn/typora/202112161415987.png)

可以看到，每一个非空节点都会对应两个子节点，**那么反序列化的思路也是用队列进行层级遍历，同时用索引 `i` 记录对应子节点的位置**：

```java
/* 将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    if (data.isEmpty()) return null;
    String[] nodes = data.split(SEP);
    // 第一个元素就是 root 的值
    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

    // 队列 q 记录父节点，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    for (int i = 1; i < nodes.length; ) {
        // 队列中存的都是父节点
        TreeNode parent = q.poll();
        // 父节点对应的左侧子节点的值
        String left = nodes[i++];
        if (!left.equals(NULL)) {
            parent.left = new TreeNode(Integer.parseInt(left));
            q.offer(parent.left);
        } else {
            parent.left = null;
        }
        // 父节点对应的右侧子节点的值
        String right = nodes[i++];
        if (!right.equals(NULL)) {
            parent.right = new TreeNode(Integer.parseInt(right));
            q.offer(parent.right);
        } else {
            parent.right = null;
        }
    }
    return root;
}
```

这段代码可以考验一下你的框架思维。仔细看一看 for 循环部分的代码，发现这不就是标准层级遍历的代码衍生出来的嘛：

```java
while (!q.isEmpty()) {
    TreeNode cur = q.poll();

    if (cur.left != null) {
        q.offer(cur.left);
    }

    if (cur.right != null) {
        q.offer(cur.right);
    }
}
```

只不过，标准的层级遍历在操作二叉树节点 `TreeNode`，而我们的函数在操作 `nodes[i]`，这也恰恰是反序列化的目的嘛。

### 完整代码

```java
/**
 * 前序遍历
 */
public static class preOrder {

    /** 元素分隔符 */
    final String SEP = ",";
    /** 空节点 */
    final String NULL = "#";

    /** 主函数，将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /** 辅助函数，将二叉树存入 StringBuilder */
    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        /* 前序遍历位置 */
        sb.append(root.val).append(SEP);

        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    /* 主函数，将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        // 将字符串转化成列表
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /* 辅助函数，通过 nodes 列表构造二叉树 */
    private TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }

        /* 前序遍历位置 */
        // 列表最左侧就是根节点
        String first = nodes.removeFirst();
        if (first.equals(NULL)) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(first));

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }

}


/**
 * 后序遍历
 */
public static class postOrder {

    /** 元素分隔符 */
    final String SEP = ",";
    /** 空节点 */
    final String NULL = "#";

    /** 主函数，将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /** 辅助函数，将二叉树存入 StringBuilder */
    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        serialize(root.left, sb);
        serialize(root.right, sb);

        /* 后序遍历位置 */
        sb.append(root.val).append(SEP);
    }

    /** 主函数，将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /** 辅助函数，通过 nodes 列表构造二叉树 */
    private TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        // 从后往前取出元素
        String last = nodes.removeLast();
        if (last.equals(NULL)) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(last));
        // 先构造右子树，后构造左子树
        root.right = deserialize(nodes);
        root.left = deserialize(nodes);

        return root;
    }

}


/**
 * 层序遍历
 */
public static class levelOrder {

    /** 元素分隔符 */
    final String SEP = ",";
    /** 空节点 */
    final String NULL = "#";


    /* 将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        // 初始化队列，将 root 加入队列
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (! q.isEmpty()) {
            TreeNode cur = q.poll();

            /* 层级遍历代码位置 */
            if (cur == null) {
                sb.append(NULL).append(SEP);
                continue;
            }
            sb.append(cur.val).append(SEP);

            q.offer(cur.left);
            q.offer(cur.right);
        }

        return sb.toString();
    }

    /* 将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        String[] nodes = data.split(SEP);
        // 第一个元素就是 root 的值
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

        // 队列 q 记录父节点，将 root 加入队列
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        for (int i = 1; i < nodes.length; ) {
            // 队列中存的都是父节点
            TreeNode parent = q.poll();
            // 父节点对应的左侧子节点的值
            String left = nodes[i++];
            if (! left.equals(NULL)) {
                Objects.requireNonNull(parent).left = new TreeNode(Integer.parseInt(left));
                q.offer(parent.left);
            } else {
                Objects.requireNonNull(parent).left = null;
            }
            // 父节点对应的右侧子节点的值
            String right = nodes[i++];
            if (! right.equals(NULL)) {
                parent.right = new TreeNode(Integer.parseInt(right));
                q.offer(parent.right);
            } else {
                parent.right = null;
            }
        }
        return root;
    }

}
```

## ⼆叉搜索⼦树的最⼤键值和（困难）

> [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)
>
> 题目会给你输入一棵二叉树，这棵二叉树的子树中可能包含**二叉搜索树**对吧，请你找到**节点之和最大的**那棵二叉搜索树，返回它的节点值之和。

对于有的题⽬，不同的遍历顺序时间复杂度不同。

⼆叉树相关题⽬最核⼼的思路是**明确当前节点需要做的事情是什么**。

我们再看看后序遍历的代码框架：

```java
void traverse(TreeNode root) { 
    traverse(root.left); 
    traverse(root.right); 
    /* 后序遍历代码的位置 */ 
    /* 在这⾥处理当前节点 */ 
} 
```

看这个代码框架，你说后序遍历什么时候出现呢？

**如果当前节点要做的事情需要通过左右⼦树的计算结果推导出来，就要⽤到后序遍历**。

很多时候，后序遍历⽤得好，可以⼤幅提升算法效率。

二叉搜索树（简写作 BST）的性质不用我多介绍了吧，简单说就是「左小右大」，对于每个节点，整棵左子树都比该节点的值小，整棵右子树都比该节点的值大。

比如题目给了这个例子：

![img](https://cos.duktig.cn/typora/202112171035586.png)

如果输入这棵二叉树，算法应该返回 20，也就是图中绿圈的那棵子树的节点值之和，因为它是一棵 BST，且节点之和最大。

那有的读者可能会问，根据 BST 的定义，有没有可能一棵二叉树中不存在 BST？

不会的，因为按照 BST 的定义，任何一个单独的节点肯定是 BST，也就是说，再不济，二叉树最下面的叶子节点肯定是 BST。

比如说如果输入下面这棵二叉树：

![img](https://cos.duktig.cn/typora/202112171037282.png)

两个叶子节点 `1` 和 `2` 就是 BST，比较一下节点之和，算法应该返回 2。

刚才说了，**二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么**。

**那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢**？

1、我肯定得知道左右子树是不是合法的 BST，如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。

2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。

3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。

**根据以上三点，站在当前节点的视角，需要知道以下具体信息**：

1、左右子树是否是 BST。

2、左子树的最大值和右子树的最小值。

3、左右子树的节点值之和。

只有知道了这几个值，我们才能满足题目的要求，后面我们会想方设法计算这些值。

可以先写出 **伪代码** 如下：

```java
// 全局变量，记录 BST 最大节点之和
int maxSum = 0;

/* 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

/* 遍历二叉树 */
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    /******* 前序遍历位置 *******/
    // 判断左右子树是不是 BST
    if (!isBST(root.left) || !isBST(root.right)) {
        goto next;
    }
    // 计算左子树的最大值和右子树的最小值
    int leftMax = findMax(root.left);
    int rightMin = findMin(root.right);
    // 判断以 root 节点为根的树是不是 BST
    if (root.val <= leftMax || root.val >= rightMin) {
        goto next;
    }
    // 如果条件都符合，计算当前 BST 的节点之和
    int leftSum = findSum(root.left);
    int rightSum = findSum(root.right);
    int rootSum = leftSum + rightSum + root.val;
    // 计算 BST 节点的最大和
    this.maxSum = Math.max(maxSum, rootSum);
    /**************************/

    // 递归左右子树
    next:
    traverse(root.left);
    traverse(root.right);
}

/* 计算以 root 为根的二叉树的最大值 */
int findMax(TreeNode root) {}

/* 计算以 root 为根的二叉树的最小值 */
int findMin(TreeNode root) {}

/* 计算以 root 为根的二叉树的节点和 */
int findSum(TreeNode root) {}

/* 判断以 root 为根的二叉树是否是 BST */
boolean isBST(TreeNode root) {}
```

这个代码逻辑应该是不难理解的，代码在前序遍历的位置把之前的分析都实现了一遍。

**稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 `traverse` 函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的**。

但是根据刚才的分析，像 `leftMax`、`rootSum` 这些变量又都得算出来，否则无法完成题目的要求。

我们希望既算出这些变量，又避免辅助函数带来的额外复杂度，鱼和熊掌全都要！

其实是可以的，**只要把前序遍历变成后序遍历，让 `traverse` 函数把辅助函数做的事情顺便做掉**。

其他代码不变，我们让 `traverse` 函数做一些计算任务，返回一个数组：

```java
// 全局变量，记录 BST 最大节点之和
int maxSum = 0;

/* 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

// 函数返回 int[]{ isBST, min, max, sum}
int[] traverse(TreeNode root) {

    int[] left = traverse(root.left);
    int[] right = traverse(root.right);

    /******* 后序遍历位置 *******/
    // 通过 left 和 right 推导返回值
    // 并且正确更新 maxSum 变量
    /**************************/
}
```

`traverse(root)` 返回一个大小为 4 的 int 数组，我们暂且称它为 `res`，其中：

`res[0]` 记录以 `root` 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；

`res[1]` 记录以 `root` 为根的二叉树所有节点中的最小值；

`res[2]` 记录以 `root` 为根的二叉树所有节点中的最大值；

`res[3]` 记录以 `root` 为根的二叉树所有节点值之和。

其实这就是把之前分析中说到的几个值放到了 `res` 数组中，**最重要的是，我们要试图通过 `left` 和 `right` 正确推导出 `res` 数组**。

```java
/** 全局变量，记录 BST 最大节点之和 */
int maxSum = 0;

/** 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

/**
 * 递归计算
 *
 * @param root /
 * @return int[]{ isBST, min, max, sum}
 */
private int[] traverse(TreeNode root) {
    // base case
    if (root == null) {
        return new int[] {
                1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0
        };
    }

    // 递归计算左右子树
    int[] left = traverse(root.left);
    int[] right = traverse(root.right);

    /*  后序遍历位置  */
    int[] res = new int[4];
    // 这个 if 在判断以 root 为根的二叉树是不是 BST
    if (left[0] == 1 && right[0] == 1 &&
            root.val > left[2] && root.val < right[1]) {
        // 以 root 为根的二叉树是 BST
        res[0] = 1;
        // 计算以 root 为根的这棵 BST 的最小值
        res[1] = Math.min(left[1], root.val);
        // 计算以 root 为根的这棵 BST 的最大值
        res[2] = Math.max(right[2], root.val);
        // 计算以 root 为根的这棵 BST 所有节点之和
        res[3] = left[3] + right[3] + root.val;
        // 更新全局变量
        maxSum = Math.max(maxSum, res[3]);
    } else {
        // 以 root 为根的二叉树不是 BST
        res[0] = 0;
        // 其他的值都没必要计算了，因为用不到
    }
    return res;
}
```

这样，这道题就解决了，`traverse` 函数在遍历二叉树的同时顺便把之前辅助函数做的事情都做了，避免了在递归函数中调用递归函数，时间复杂度只有 O(N)。

你看，这就是后序遍历的妙用，相对前序遍历的解法，现在的解法不仅效率高，而且代码量少，比较优美。

**后序遍历这么好，是不是就应该尽可能多用后序遍历**？

其实也不是，主要是看题目，就好比 BST 的中序遍历是有序的一样。

这道题为什么用后序遍历呢，因为我们需要的这些变量都是可以通过后序遍历得到的。

你计算以 `root` 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 `root.val` 计算出来？

你计算以 `root` 为根的二叉树的最大值/最小值，是不是可以通过左右子树的最大值/最小值和 `root.val` 比较出来？

你判断以 `root` 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？

文章开头说过，**如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历**。

## 二叉树的最近公共祖先

Git 的`rebase`工作方式引出一个经典的算法问题：**最近公共祖先**（Lowest Common Ancestor，简称 LCA）。

比如`git pull`这个命令，我们经常会用，它默认是使用`merge`方式将远端别人的修改拉到本地；如果带上上参数`git pull -r`，就会使用`rebase`的方式将远端修改拉到本地。

这二者最直观的区别就是：`merge`方式合并的分支会有很多「分叉」，而`rebase`方式合并的分支就是一条直线。

**对于多人协作，`merge`方式并不好**。

那么问题来了，`rebase`是如何将两条不同的分支合并到同一条分支的呢：

![image-20211220094646114](https://cos.duktig.cn/typora/202112200947816.png)

**首先，找到这两条分支的最近公共祖先`LCA`，然后从`master`节点开始，重演`LCA`到`dev`几个`commit`的修改**，如果这些修改和`LCA`到`master`的`commit`有冲突，就会提示你手动解决冲突，最后的结果就是把`dev`的分支完全接到`master`上面。

Git 是如何找到两条不同分支的最近公共祖先的呢？这就是一个经典的算法问题了。

> [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
>
> `root`节点确定了一棵二叉树，`p`和`q`是这这棵二叉树上的两个节点，让你返回`p`节点和`q`节点的最近公共祖先节点。
>
> **一个节点也可以是它自己的祖先**

我们前文 [学习数据结构和算法的框架思维](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&chksm=9bd7fbbcaca072aa75e2a241064a403fde1e579d57ab846cd8537a54253ceb2c8b93cc3bf38e&scene=21#wechat_redirect) 就说过了，所有二叉树的套路都是一样的：

```java
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

所以，只要看到二叉树的问题，先把这个框架写出来准没问题：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
}
```

现在我们思考如何添加一些细节，把框架改造成解法。

**遇到任何递归型的问题，无非就是灵魂三问**：

**1、这个函数是干嘛的**？

**2、这个函数参数中的变量是什么的是什么**？

**3、得到函数的递归结果，你应该干什么**？

**首先看第一个问题，这个函数是干嘛的**？或者说，你给我描述一下`lowestCommonAncestor`这个函数的「定义」吧。

描述：给该函数输入三个参数`root`，`p`，`q`，它会返回一个节点。

情况 1，如果`p`和`q`都在以`root`为根的树中，函数返回的即使`p`和`q`的最近公共祖先节点。

情况 2，那如果`p`和`q`都不在以`root`为根的树中怎么办呢？函数理所当然地返回`null`呗。

情况 3，那如果`p`和`q`只有一个存在于`root`为根的树中呢？函数就会返回那个节点。

题目说了输入的`p`和`q`一定存在于以`root`为根的树中，但是递归过程中，以上三种情况都有可能发生，所以说这里要定义清楚，后续这些定义都会在代码中体现。

**然后来看第二个问题，这个函数的参数中，变量是什么**？或者说，你描述一个这个函数的「状态」吧。

描述：函数参数中的变量是`root`，因为根据框架，`lowestCommonAncestor(root)`会递归调用`root.left`和`root.right`；至于`p`和`q`，我们要求它俩的公共祖先，它俩肯定不会变化的。

第二个问题也解决了，你也可以理解这是「状态转移」，每次递归在做什么？不就是在把「以`root`为根」转移成「以`root`的子节点为根」，不断缩小问题规模嘛？

**最后来看第三个问题，得到函数的递归结果，你该干嘛**？或者说，得到递归调用的结果后，你做什么「选择」？

这就像动态规划系列问题，怎么做选择，需要观察问题的性质，找规律。那么我们就得分析这个「最近公共祖先节点」有什么特点呢？刚才说了函数中的变量是`root`参数，所以这里都要围绕`root`节点的情况来展开讨论。

先想 base case，如果`root`为空，肯定得返回`null`。如果`root`本身就是`p`或者`q`，比如说`root`就是`p`节点吧，如果`q`存在于以`root`为根的树中，显然`root`就是最近公共祖先；即使`q`不存在于以`root`为根的树中，按照情况 3 的定义，也应该返回`root`节点。

以上两种情况的 base case 就可以把框架代码填充一点了：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // 两种情况的 base case
    if (root == null) return null;
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
}
```

现在就要面临真正的挑战了，用递归调用的结果`left`和`right`来搞点事情。根据刚才第一个问题中对函数的定义，我们继续分情况讨论：

情况 1，如果`p`和`q`都在以`root`为根的树中，那么`left`和`right`一定分别是`p`和`q`（从 base case 看出来的）。

情况 2，如果`p`和`q`都不在以`root`为根的树中，直接返回`null`。

情况 3，如果`p`和`q`只有一个存在于`root`为根的树中，函数返回该节点。

明白了上面三点，可以直接看解法代码了：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // base case
    if (root == null) return null;
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    // 情况 1
    if (left != null && right != null) {
        return root;
    }
    // 情况 2
    if (left == null && right == null) {
        return null;
    }
    // 情况 3
    return left == null ? right : left;
}
```

对于情况 1，你肯定有疑问，`left`和`right`非空，分别是`p`和`q`，可以说明`root`是它们的公共祖先，但能确定`root`就是「最近」公共祖先吗？

这就是一个巧妙的地方了，**因为这里是二叉树的后序遍历啊**！前序遍历可以理解为是从上往下，而后序遍历是从下往上，就好比从`p`和`q`出发往上走，第一次相交的节点就是这个`root`，你说这是不是最近公共祖先呢？

综上，二叉树的最近公共祖先就计算出来了。



## 二叉搜索树

BST 是⼀种特殊的⼆叉树，你只要记住它的两个主要特点：

1、左⼩右⼤，即每个节点的左⼦树都⽐当前节点的值⼩，右⼦树都⽐当前节点的值⼤。

2、中序遍历结果是有序的。

 



# 算法策略——最⼤化「优势」

田忌赛马的故事告诉我们：**打得过就打，打不过就拿⾃⼰的垃圾和对⽅的精锐互换**。

> 给你输⼊两个⻓度相等的数组 nums1 和 nums2，请你重新组织 nums1 中元素的位置，使得 nums1 的「优势」最⼤化。
> 如果 nums1[i] > nums2[i]，就是说 nums1 在索引 i 上对 nums2[i] 有「优势」。优势最⼤化也就是说让你重新组织 nums1，尽可能多的让 nums[i] > nums2[i]。
>
> [870. 优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle/)
>
> 这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒，你就是孙膑。

**小插曲分析：**

**将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。**

**为什么？**

我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。
如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？

显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。

但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢耶，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？

```java
public int[] advantageCount(int[] nums1, int[] nums2) {
    int n = nums1.length;
    // 从大到小排序的优先队列；数组中第一个元素代表num2中当前元素的索引，第二个元素代表其数值
    PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> b[1] - a[1]);
    for (int i = 0; i < n; i++) {
        priorityQueue.offer(new int[] {i, nums2[i]});
    }
    Arrays.sort(nums1);
    int left = 0, right = n - 1;
    int[] res = new int[n];
    // 每次去nums2中最大的
    while (! priorityQueue.isEmpty()) {
        int[] curs = priorityQueue.poll();
        // index为当前最大值的索引
        int index = curs[0], maxValue = curs[1];
        // nums1大于最大值，选取nums1当前的值
        if (nums1[right] > maxValue) {
            res[index] = nums1[right];
            right--;
        } else {
            // nums1小于等于时，选取最差的数
            res[index] = nums1[left];
            left++;
        }
    }
    return res;
}
```





# 深度优先搜索

> **深度优先搜索** 算法（英语：Depth-First-Search，**DFS**）是一种用于遍历或搜索树或图的算法。这个算法会 **尽可能深** 的搜索树的分支。当结点 `v` 的所在边都己被探寻过，搜索将 **回溯** 到发现结点` v `的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。一个理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 **不断变化** 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。

搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。

搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。

## 岛屿问题（网格）

我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「**网格**」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。

### 网格类问题的 DFS 遍历方法

#### 网格问题的基本概念

首先明确一下岛屿问题中的网格结构是如何定义的？

网格问题是由 m×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。

岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。

![岛屿问题示例](https://cos.duktig.cn/typora/202112181649619.jpeg)

在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。

#### 网格问题的 DFS 基本结构

网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的 **二叉树 DFS 遍历** 一般是这样的：

```java
void traverse(TreeNode root) {
    // 判断 base case
    if (root == null) {
        return;
    }
    // 访问两个相邻结点：左子结点、右子结点
    traverse(root.left);
    traverse(root.right);
}
```

可以看到，二叉树的 DFS 有两个要素：「**访问相邻结点**」和「**判断 base case**」。

第一个要素是访问相邻结点。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。

第二个要素是 判断 base case。一般来说，二叉树遍历的 base case 是 `root == null`。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 `root == null` 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。

对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：

首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。

![网格结构中四个相邻的格子](https://cos.duktig.cn/typora/202112181656265.jpeg)

其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、`grid[r][c]` 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。

![网格 DFS 的 base case](https://cos.duktig.cn/typora/202112181657709.jpeg)

这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「**先污染后治理**」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 `root == null` 再返回。

#### 如何避免重复遍历

网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，**遍历中可能遇到遍历过的结点**。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。

这时候，DFS 可能会不停地「兜圈子」，永远停不下来，如下图所示：

![DFS 遍历可能会兜圈子（动图）](https://cos.duktig.cn/typora/202112181659979.gif)

如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：

- 0 —— 海洋格子
- 1 —— 陆地格子（未遍历过）
- 2 —— 陆地格子（已遍历过）

这样，我们就得到了一个岛屿问题、乃至各种网格问题的通用 DFS 遍历方法。

```java
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    if (!inArea(grid, r, c)) {
        return;
    }
    // 如果这个格子不是岛屿，直接返回
    if (grid[r][c] != 1) {
        return;
    }
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 <= r && r < grid.length 
        	&& 0 <= c && c < grid[0].length;
}
```

> 小贴士：
>
> 在一些题解中，可能会把「已遍历过的陆地格子」标记为和海洋格子一样的 0，美其名曰「陆地沉没方法」，即遍历完一个陆地格子就让陆地「沉没」为海洋。这种方法看似很巧妙，但实际上有很大隐患，因为这样我们就无法区分「海洋格子」和「已遍历过的陆地格子」了。如果题目更复杂一点，这很容易出 bug。

### 岛屿的最大面积

> [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)
>
> 给定一个包含了一些 0 和 1 的非空二维数组 grid，一个岛屿是一组相邻的 1（代表陆地），这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表海洋）包围着。
>
> 找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
>

这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。

```java
/** 0代表海洋 */
final int ZERO = 0;
/** 1代表未被遍历过的陆地 */
final int ONE = 1;
/** 2代表已被遍历过的陆地 */
final int TWO = 2;

/**
 * 计算 岛屿面积最大值
 *
 * @param grid 岛屿和海洋的二维网格
 * @return 岛屿面积最大值
 */
public int maxAreaOfIsland(int[][] grid) {
    // 记录结果
    int res = 0;
    // 一次遍历网格（area方法中将遍历过的网格设为2，避免重复遍历）
    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            if (grid[r][c] == ONE) {
                // 计算当前岛屿的面积
                int a = area(grid, r, c);
                res = Math.max(res, a);
            }
        }
    }
    return res;
}

/**
 * 递归计算岛屿的面积（将遍历过的网格设为2，避免重复计算）
 *
 * @param grid 岛屿和海洋的二维网格
 * @param row  行索引
 * @param col  列索引
 * @return 当前岛屿的面积
 */
private int area(int[][] grid, int row, int col) {
    // 越界，停止递归
    if (! inArea(grid, row, col)) {
        return 0;
    }
    // 当前网格遍历过，停止递归
    if (grid[row][col] != ONE) {
        return 0;
    }
    // 将遍历过的网格，设为2，避免下次重复遍历
    grid[row][col] = TWO;

    // 递归计算岛屿的面积
    return 1
            + area(grid, row - 1, col)
            + area(grid, row + 1, col)
            + area(grid, row, col - 1)
            + area(grid, row, col + 1);
}

/**
 * 判断网格遍历时，是否越界
 *
 * @param grid 岛屿和海洋的二维网格
 * @param row  行索引
 * @param col  列索引
 * @return 是否越界
 */
private boolean inArea(int[][] grid, int row, int col) {
    return 0 <= row && row < grid.length && 0 <= col && col < grid[0].length;
}
```



### 岛屿的周长

>  [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)
>
> 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地，0 表示海洋。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（一个或多个表示陆地的格子相连组成岛屿）。
>
> 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。计算这个岛屿的周长。
>
> ![题目示例](https://cos.duktig.cn/typora/202112181710343.jpeg)

实话说，这道题用 DFS 来解并不是最优的方法。对于岛屿，直接用数学的方法求周长会更容易。不过这道题是一个很好的理解 DFS 遍历过程的例题。

可以看到，dfs 函数直接返回有这几种情况：

- `!inArea(grid, r, c)`，即坐标 (r, c) 超出了网格的范围，也就是我所说的「先污染后治理」的情况
- `grid[r][c] != 1`，即当前格子不是岛屿格子，这又分为两种情况：
  - `grid[r][c] == 0`，当前格子是海洋格子
  - `grid[r][c] == 2`，当前格子是已遍历的陆地格子

那么这些和我们岛屿的周长有什么关系呢？实际上，**岛屿的周长是计算岛屿全部的「边缘」，而这些边缘就是我们在 DFS 遍历中，dfs 函数返回的位置**。观察题目示例，我们可以将岛屿的周长中的边分为两类，如下图所示。黄色的边是与网格边界相邻的周长，而蓝色的边是与海洋格子相邻的周长。

![将岛屿周长中的边分为两类](https://cos.duktig.cn/typora/202112181714017.jpeg)

当我们的 dfs 函数因为「坐标 (r, c) 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。这样，我们就把岛屿的周长跟 DFS 遍历联系起来了，我们的题解代码也呼之欲出：

```java
/** 0代表海洋 */
final int ZERO = 0;
/** 1代表未被遍历过的陆地 */
final int ONE = 1;
/** 2代表已被遍历过的陆地 */
final int TWO = 2;

/**
 * 计算岛屿的周长
 */
public int islandPerimeter(int[][] grid) {
    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            if (grid[r][c] == ONE) {
                // 题目限制只有一个岛屿，计算一个即可
                return dfs(grid, r, c);
            }
        }
    }
    return 0;
}

/**
 * DFS遍历
 */
private int dfs(int[][] grid, int r, int c) {
    // 函数因为「坐标 (r, c) 超出网格范围」返回，对应一条黄色的边
    if (! inArea(grid, r, c)) {
        return 1;
    }
    // 函数因为「当前格子是海洋格子」返回，对应一条蓝色的边
    if (grid[r][c] == ZERO) {
        return 1;
    }
    // 函数因为「当前格子是已遍历的陆地格子」返回，和周长没关系
    if (grid[r][c] != ONE) {
        return 0;
    }
    grid[r][c] = TWO;
    return dfs(grid, r - 1, c)
            + dfs(grid, r + 1, c)
            + dfs(grid, r, c - 1)
            + dfs(grid, r, c + 1);
}

/**
 * 判断坐标 (r, c) 是否在网格中
 */
private boolean inArea(int[][] grid, int r, int c) {
    return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
}
```

### 岛屿数量

> [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```java
/** 海洋 */
final int ZERO = '0';
/** 未遍历过的岛屿 */
final int ONE = '1';
/** 已遍历过的岛屿 */
final int TWO = '2';

public int numIslands(char[][] grid) {
    int res = 0;
    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            // 遇到一个岛屿直接标记，有标记 2 ，其他岛屿都进不来，直接标记即可
            if (grid[r][c] == ONE) {
                isLand(grid, r, c);
                res++;
            }
        }
    }
    return res;
}

private void isLand(char[][] grid, int r, int c) {
    if (! inArea(grid, r, c)) {
        return;
    }

    if (grid[r][c] != ONE) {
        return;
    }
    // 将遍历过的网格，设为2，避免下次重复遍历
    grid[r][c] = TWO;

    isLand(grid, r - 1, c);
    isLand(grid, r + 1, c);
    isLand(grid, r, c - 1);
    isLand(grid, r, c + 1);

}

/**
 * 判断是否在网格中
 */
private boolean inArea(char[][] grid, int row, int col) {
    return 0 <= row && row < grid.length && 0 <= col && col < grid[0].length;
}
```





# 数据结构设计

数据结构设计题主要就是给你提需求，让你实现 API，⽽且要求这些 API 的复杂度尽可能低。

根据经验，设计题中 **哈希表的出现频率很⾼**，⼀般都是各类其他数据结构和哈希表组合，从⽽改善这些基本数据结构的特性，获得「超能⼒」。

## LRU缓存机制

LRU 算法就是⼀种缓存淘汰策略，原理不难，但是⾯试中写出没有 bug 的算法⽐较有技巧，需要对数据结构进⾏层层抽象和拆解。

计算机的缓存容量有限，如果缓存满了就要删除⼀些内容，给新内容腾位置。但问题是，删除哪些内容呢？

我们肯定希望删掉哪些没什么⽤的缓存，⽽把有⽤的数据继续留在缓存⾥，⽅便之后继续使⽤。那么，**什么样的数据，我们判定为「有⽤的」的数据呢**？

LRU 缓存淘汰算法就是⼀种常⽤策略。LRU 的全称是 Least Recently Used，也就是说我们认为 **最近使⽤过的数据应该是是「有⽤的」**，很久都没⽤过的数据应该是⽆⽤的，内存满了就优先删那些很久没⽤过的数据。

场景：比如手机杀后台的策略。

> [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

⾸先要接收⼀个 capacity 参数作为缓存的最⼤容量，然后实现两个 API，⼀个是 put(key, val) ⽅法存⼊键值对，另⼀个是 get(key) ⽅法获取 key 对应的 val，如果 key 不存在则返回 -1。

要让 put 和 get ⽅法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必
要的条件：

1. 显然 cache 中的元素必须有时序，以区分最近使⽤的和久未使⽤的数据，当容量满了之后要删除最久未使⽤的那个元素腾位置。
2. 我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val。
3. 每次访问 cache 中的某个 key，需要将这个元素变为最近使⽤的，也就是说 cache 要⽀持在任意位置快速插⼊和删除元素。

那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据⽆固定顺序；链表有顺序之分，插⼊删除快，但是查找慢。所以结合⼀下，形成⼀种新的数据结构：哈希链表 `LinkedHashMap`。

![哈希链表](https://cos.duktig.cn/typora/202112021532046.png)

借助这个结构，我们来逐⼀分析上⾯的 3 个条件：

1. 如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使⽤的，越靠头部的元素就是最久未使⽤的。
2. 对于某⼀个 key，我们可以通过哈希表快速定位到链表中的节点，从⽽取得对应 val。
3. 链表显然是⽀持在任意位置快速插⼊和删除的，改改指针就⾏。只不过传统的链表⽆法按照索引快速访问某⼀个位置的元素，⽽这⾥借助哈希表，可以通过 key 快速映射到任意⼀个链表节点，然后进⾏插⼊和删除。

**为什么必须要⽤双向链表？**

因为我们需要删除操作。删除⼀个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，⽽双向链表才能⽀持直接查找前驱，保证操作的时间复杂度 O(1)。

**为什么要在链表中同时存储 key 和 val，⽽不是只存储 val？**

`removeLeastRecently` 函数中，我们需要⽤ `deletedNode` 得到 `deletedKey`。

也就是说，当缓存容量已满，我们不仅仅要删除最后⼀个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，⽽这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就⽆法得知 key 是什么，就⽆法删除 map 中的键，造成错误。

put ⽅法稍微复杂⼀些，我们先来画个图搞清楚它的逻辑：

![image-20211202165137688](https://cos.duktig.cn/typora/202112021651029.png)

### 借助LinkedHashMap实现

```java
public class LRUCacheAPI {

    int capacity;

    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();

    public LRUCacheAPI(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        if (! cache.containsKey(key)) {
            return - 1;
        }
        // 将 key 变为最近使⽤
        makeRecently(key);
        return cache.get(key);
    }

    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // 修改 key 的值
            cache.put(key, val);
            // 将 key 变为最近使⽤
            makeRecently(key);
            return;
        }

        if (cache.size() >= this.capacity) {
            // 链表头部就是最久未使⽤的 key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // 将新的 key 添加链表尾部
        cache.put(key, val);
    }

    private void makeRecently(int key) {
        int val = cache.get(key);
        // 删除 key，重新插⼊到队尾
        cache.remove(key);
        cache.put(key, val);
    }

}
```



### 简化版自定义代码

```java
public class LRUCache {

    private static class DoubleLinkedNode {
        int k;
        int v;
        DoubleLinkedNode prev;
        DoubleLinkedNode next;

        DoubleLinkedNode() {}

        DoubleLinkedNode(int k, int v) {
            this.k = k;
            this.v = v;
        }
    }

    private Map<Object, DoubleLinkedNode> cache = new HashMap<>();
    private int size;
    private int capacity;
    private DoubleLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DoubleLinkedNode();
        tail = new DoubleLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DoubleLinkedNode node = cache.get(key);
        if (node == null) {
            return - 1;
        }
        this.moveToHead(node);
        return node.v;
    }

    public void put(int key, int value) {
        DoubleLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果没有当前元素，新创建
            DoubleLinkedNode newNode = new DoubleLinkedNode(key, value);
            cache.put(key, newNode);
            this.addToHead(newNode);
            ++ size;
            if (size > capacity) {
                DoubleLinkedNode tail = this.removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.k);
                -- size;
            }
        } else {
            node.v = value;
            moveToHead(node);
        }

    }

    private DoubleLinkedNode removeTail() {
        DoubleLinkedNode res = tail.prev;
        this.removeNode(res);
        return res;
    }


    private void moveToHead(DoubleLinkedNode node) {
        this.removeNode(node);
        this.addToHead(node);
    }

    private void addToHead(DoubleLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DoubleLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }


}
```



### 完善的自定义代码

完整代码如下：

```java
public class LRUCache<K, V> {

    /** key -> Node(key, val) */
    private Map<K, Node<K, V>> map;

    /** Node(k1, v1) <-> Node(k2, v2)... */
    private DoubleList<K, V> cache;

    /** 最大容量 */
    private int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        cache = new DoubleList<>();
    }

    /**
     * 将某个 key 提升为最近使⽤的
     */
    private void makeRecently(K key) {
        Node<K, V> x = map.get(key);
        // 先从链表中删除这个节点
        cache.remove(x);
        // 重新插到队尾
        cache.addLast(x);
    }

    /**
     * 添加最近使⽤的元素
     */
    private void addRecently(K key, V val) {
        Node<K, V> node = new Node<>(key, val);
        // 链表尾部就是最近使⽤的元素
        cache.addLast(node);
        // 别忘了在 map 中添加 key 的映射
        map.put(key, node);
    }

    /**
     * 删除某⼀个 key
     */
    private void deleteKey(K key) {
        Node<K, V> node = map.get(key);
        // 从链表中删除
        cache.remove(node);
        // 从 map 中删除
        map.remove(key);
    }

    /**
     * 删除最久未使⽤的元素
     */
    private void removeLeastRecently() {
        // 链表头部的第⼀个元素就是最久未使⽤的
        Node<K, V> deletedNode = cache.removeFirst();
        // 同时别忘了从 map 中删除它的 key
        K deletedKey = deletedNode.key;
        map.remove(deletedKey);
    }

    /**
     * 从缓存中取值，并将当前的值设为最近使用过的
     */
    public V get(K key) {
        if (! map.containsKey(key)) {
            return null;
        }
        // 将该数据提升为最近使⽤的
        this.makeRecently(key);
        return map.get(key).val;
    }

    /**
     * 往缓存添加数据
     * 如果存在删除旧数据，将新数据添加到链表尾部
     * 如果达到容量，删除头部的元素，新元素添加到尾部
     */
    public void put(K key, V val) {
        if (map.containsKey(key)) {
            // 删除旧的数据
            deleteKey(key);
            // 新插⼊的数据为最近使⽤的数据
            addRecently(key, val);
            return;
        }

        if (capacity == cache.size()) {
            // 删除最久未使⽤的元素
            removeLeastRecently();
        }
        // 添加为最近使⽤的元素
        addRecently(key, val);
    }

    /**
     * 双向链表的节点
     */
    private static class Node<K, V> {
        K key;
        V val;
        Node<K, V> next, prev;

        public Node(K k, V v) {
            this.key = k;
            this.val = v;
        }
    }

    /**
     * 双向链表
     */
    static class DoubleList<K, V> {
        // 头尾虚节点
        private Node<K, V> head, tail;
        // 链表元素数
        private int size;

        /**
         * 初始化双向链表的数据
         */
        public DoubleList() {
            head = new Node<>(null, null);
            tail = new Node<>(null, null);
            head.next = tail;
            tail.prev = head;
            size = 0;
        }

        /**
         * 在链表尾部添加节点 node，时间 O(1)
         */
        public void addLast(Node<K, V> node) {
            node.prev = tail.prev;
            node.next = tail;
            tail.prev.next = node;
            tail.prev = node;
            size++;
        }

        /**
         * 删除链表中的 node 节点（node ⼀定存在）
         * 由于是双链表且给的是⽬标 Node 节点，时间 O(1)
         */
        public void remove(Node<K, V> node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
            size--;
        }

        /**
         * 删除链表中第⼀个节点，并返回该节点，时间 O(1)
         *
         * @return del node
         */
        public Node<K, V> removeFirst() {
            // 如果只有一个节点，直接返回null
            if (head.next == tail) {
                return null;
            }
            Node<K, V> first = head.next;
            this.remove(first);
            return first;
        }

        /**
         * 返回链表⻓度，时间 O(1)
         */
        public int size() { return size; }

    }
    
}
```

代码步骤：

- 构造双向链表的节点
- 构造双向链表
  - 初始化数据，尤其是虚拟头结点和尾节点，以及链表的长度
  - 提供双向链表常用的API
    - 在链表尾部添加节点
    - 删除链表中的指定节点
    - 删除链表中的第一个节点，并返回该节点
    - 返回链表的长度
- 构造LRU缓存类
  - 初始化 map、双向链表和缓存容量
  - 提供封装的私有方法，同时操作缓存（双向链表）和map可能出现失误
    - 将某个可以提升为最近使用的。删除节点，重新插入到尾部。
    - 添加最近使用的元素。节点添加到尾部，并加入到map的映射中。
    - 删除一个key。删除链表节点，同时删除map的key。
    - 删除最久未使用的元素。删除链表节点，得到key，根据key删除map的映射。
  - 提供get方法，获取缓存的值。
    - 不存在，返回null
    - 将该数据提升为最近使用的
    - 返回该数据
  - 提供put方法，修改和新增缓存的值
    - 存在key，删除旧数据，新数据插入到头部
    - 达到缓存容量，删除最久未使用的数据，将新数据添加到头部

## LFU缓存机制

LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使⽤的数据；

LFU 算法的淘汰策略是 Least Frequently Used，也就是 **每次淘汰那些使⽤次数最少的数据**。

LRU 算法的核⼼数据结构是使⽤哈希链表 `LinkedHashMap`，⾸先借助链表的有序性使得链表元素维持插⼊顺序，同时借助哈希映射的快速访问能⼒使得我们可以在 O(1) 时间访问链表的任意元素。

从实现难度上来说，LFU 算法的难度⼤于 LRU 算法，因为 LRU 算法相当于把数据按照时间排序，这个需求借助链表很⾃然就能实现，你⼀直从链表头部加⼊元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进⾏缓存淘汰的时候只要简单地将尾部的元素淘汰掉就⾏了。

⽽ LFU 算法相当于是把数据按照访问频次进⾏排序，这个需求恐怕没有那么简单，⽽且还有⼀种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插⼊的那个数据。也就是说 **LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据**。

**算法描述**：

> 要求你写⼀个类，接受⼀个 capacity 参数，实现 get 和 put ⽅法：
>
> get(key) ⽅法会去缓存中查询键 key，如果 key 存在，则返回 key 对应的 val，否则返回 -1。
>
> put(key, value) ⽅法插⼊或修改缓存。如果 key 已存在，则将它对应的值改为 val；如果 key 不存在，则插⼊键值对 (key, val)。
>
> 当缓存达到容量 capacity 时，则应该在插⼊新的键值对之前，删除使⽤频次（后⽂⽤ freq 表示）最低的键值对。如果 freq 最低的键值对有多个，则删除其中最旧的那个。

**思路分析：**

需求：

1、调用`get(key)`方法时，要返回该`key`对应的`val`。

2、只要用`get`或者`put`方法访问一次某个`key`，该`key`的`freq`就要加一。

3、如果在容量满了的时候进行插入，则需要将`freq`最小的`key`删除，如果最小的`freq`对应多个`key`，则删除其中最旧的那一个。

好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使⽤基本数据结构来逐个击破：

**1、**使用一个`HashMap`存储`key`到`val`的映射，就可以快速计算`get(key)`。

```
HashMap<Integer, Integer> keyToVal;
```

**2、**使用一个`HashMap`存储`key`到`freq`的映射，就可以快速操作`key`对应的`freq`。

```
HashMap<Integer, Integer> keyToFreq;
```

**3、**这个需求应该是 LFU 算法的核心，所以我们分开说。

**3.1****、**首先，肯定是需要`freq`到`key`的映射，用来找到`freq`最小的`key`。

**3.2、**将`freq`最小的`key`删除，那你就得快速得到当前所有`key`最小的`freq`是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量`minFreq`来记录当前最小的`freq`吧。

**3.3、**可能有多个`key`拥有相同的`freq`，所以 **`freq`对`key`是一对多的关系**，即一个`freq`对应一个`key`的列表。

**3.4、**希望`freq`对应的`key`的列表是**存在时序**的，便于快速查找并删除最旧的`key`。

**3.5、**希望**能够快速删除`key`列表中的任何一个`key`**，因为如果频次为`freq`的某个`key`被访问，那么它的频次就会变成`freq+1`，就应该从`freq`对应的`key`列表中删除，加到`freq+1`对应的`key`的列表中。

介绍⼀下这个`LinkedHashSet`，它满⾜我们 3.3，3.4，3.5 这⼏个要求。你会发现普通的链表`LinkedList` 能够满⾜ 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某⼀个节点，所以⽆法满⾜ 3.5 的要求。

`LinkedHashSet` 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插⼊元素具有时序；哈希集合中的元素⽆序，但是可以对元素进⾏快速的访问和删除。

那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，⼜可以保持插⼊的时序，⾼效实现 3.5 这个需求。

基本数据结构如下：

```java
class LFUCache {
    // key 到 val 的映射，我们后文称为 KV 表
    HashMap<Integer, Integer> keyToVal;
    // key 到 freq 的映射，我们后文称为 KF 表
    HashMap<Integer, Integer> keyToFreq;
    // freq 到 key 列表的映射，我们后文称为 FK 表
    HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
    // 记录最小的频次
    int minFreq;
    // 记录 LFU 缓存的最大容量
    int cap;

    public LFUCache(int capacity) {
        keyToVal = new HashMap<>();
        keyToFreq = new HashMap<>();
        freqToKeys = new HashMap<>();
        this.cap = capacity;
        this.minFreq = 0;
    }

    public int get(int key) {}

    public void put(int key, int val) {}

}
```

LFU 的逻辑不难理解，但是写代码实现并不容易，因为你看我们要维护`KV`表，`KF`表，`FK`表三个映射，特别容易出错。注意事项：

1. 不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。
2. 搞清楚映射关系，如果我们更新了某个`key`对应的`freq`，那么就要同步修改`KF`表和`FK`表，这样才不会出问题。
3. 画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。

下面我们先来实现`get(key)`方法，逻辑很简单，返回`key`对应的`val`，然后增加`key`对应的`freq`：

```java
public int get(int key) {
    if (!keyToVal.containsKey(key)) {
        return -1;
    }
    // 增加 key 对应的 freq
    increaseFreq(key);
    return keyToVal.get(key);
}
```

增加`key`对应的`freq`是 LFU 算法的核心，所以我们干脆直接抽象成一个函数`increaseFreq`，这样`get`方法看起来就简洁清晰了。

下面来实现`put(key, val)`方法，逻辑略微复杂，我们直接画个图来看：

![图片](https://cos.duktig.cn/typora/202112022144504.webp)

```java
public void put(int key, int val) {
    if (this.cap <= 0) return;

    /* 若 key 已存在，修改对应的 val 即可 */
    if (keyToVal.containsKey(key)) {
        keyToVal.put(key, val);
        // key 对应的 freq 加一
        increaseFreq(key);
        return;
    }

    /* key 不存在，需要插入 */
    /* 容量已满的话需要淘汰一个 freq 最小的 key */
    if (this.cap <= keyToVal.size()) {
        removeMinFreqKey();
    }

    /* 插入 key 和 val，对应的 freq 为 1 */
    // 插入 KV 表
    keyToVal.put(key, val);
    // 插入 KF 表
    keyToFreq.put(key, 1);
    // 插入 FK 表
    freqToKeys.putIfAbsent(1, new LinkedHashSet<>());
    freqToKeys.get(1).add(key);
    // 插入新 key 后最小的 freq 肯定是 1
    this.minFreq = 1;
}
```

`increaseFreq`和`removeMinFreqKey`方法是 LFU 算法的核心，我们下面来看看怎么借助`KV`表，`KF`表，`FK`表这三个映射巧妙完成这两个函数。

**核心逻辑：**

首先来实现`removeMinFreqKey`函数：

```java
private void removeMinFreqKey() {
    // freq 最小的 key 列表
    LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
    // 其中最先被插入的那个 key 就是该被淘汰的 key
    int deletedKey = keyList.iterator().next();
    /* 更新 FK 表 */
    keyList.remove(deletedKey);
    if (keyList.isEmpty()) {
        freqToKeys.remove(this.minFreq);
        // 问：这里需要更新 minFreq 的值吗？
    }
    /* 更新 KV 表 */
    keyToVal.remove(deletedKey);
    /* 更新 KF 表 */
    keyToFreq.remove(deletedKey);
}
```

删除某个键`key`肯定是要同时修改三个映射表的，借助`minFreq`参数可以从`FK`表中找到`freq`最小的`keyList`，根据时序，其中第一个元素就是要被淘汰的`deletedKey`，操作三个映射表删除这个`key`即可。

但是有个细节问题，如果`keyList`中只有一个元素，那么删除之后`minFreq`对应的`key`列表就为空了，也就是`minFreq`变量需要被更新。如何计算当前的`minFreq`是多少呢？

实际上没办法快速计算`minFreq`，只能线性遍历`FK`表或者`KF`表来计算，这样肯定不能保证 O(1) 的时间复杂度。

**但是，其实这里没必要更新`minFreq`变量**，因为你想想`removeMinFreqKey`这个函数是在什么时候调用？在`put`方法中插入新`key`时可能调用。而你回头看`put`的代码，插入新`key`时一定会把`minFreq`更新成 1，所以说即便这里`minFreq`变了，我们也不需要管它。

下面来实现`increaseFreq`函数：

```java
private void increaseFreq(int key) {
    int freq = keyToFreq.get(key);
    /* 更新 KF 表 */
    keyToFreq.put(key, freq + 1);
    /* 更新 FK 表 */
    // 将 key 从 freq 对应的列表中删除
    freqToKeys.get(freq).remove(key);
    // 将 key 加入 freq + 1 对应的列表中
    freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
    freqToKeys.get(freq + 1).add(key);
    // 如果 freq 对应的列表空了，移除这个 freq
    if (freqToKeys.get(freq).isEmpty()) {
        freqToKeys.remove(freq);
        // 如果这个 freq 恰好是 minFreq，更新 minFreq
        if (freq == this.minFreq) {
            this.minFreq++;
        }
    }
}
```

更新某个`key`的`freq`肯定会涉及`FK`表和`KF`表，所以我们分别更新这两个表就行了。

和之前类似，当`FK`表中`freq`对应的列表被删空后，需要删除`FK`表中`freq`这个映射。如果这个`freq`恰好是`minFreq`，说明`minFreq`变量需要更新。

能不能快速找到当前的`minFreq`呢？这里是可以的，因为我们刚才把`key`的`freq`加了 1 嘛，所以`minFreq`也加 1 就行了。

至此，经过层层拆解，LFU 算法就完成了。

完整代码如下：

```java
public class LFUCache {

    /** key 到 val 的映射，我们后文称为 KV 表 */
    Map<Integer, Integer> keyToVal;

    /** key 到 freq 的映射，我们后文称为 KF 表 */
    Map<Integer, Integer> keyToFreq;

    /** freq 到 key 列表的映射，我们后文称为 FK 表 */
    Map<Integer, LinkedHashSet<Integer>> freqToKeys;

    /** 记录最小的频次 */
    int minFreq;

    /** 记录 LFU 缓存的最大容量 */
    int capacity;

    public LFUCache(int capacity) {
        keyToVal = new HashMap<>();
        keyToFreq = new HashMap<>();
        freqToKeys = new HashMap<>();
        this.capacity = capacity;
        this.minFreq = 0;
    }

    /**
     * 获取缓存值
     * 需要增加当前缓存的频次
     */
    public int get(int key) {
        if (! keyToVal.containsKey(key)) {
            return - 1;
        }
        // 增加 key 对应的 freq
        increaseFreq(key);
        return keyToVal.get(key);
    }

    /**
     * 新增或修改缓存值
     * 1. 若 key 已存在，修改对应的 val
     * 2. key 不存在，需要插入
     * 3. 容量已满的话需要淘汰一个 freq 最小的 key
     */
    public void put(int key, int val) {
        if (this.capacity <= 0) {
            return;
        }

        /* 若 key 已存在，修改对应的 val 即可 */
        if (keyToVal.containsKey(key)) {
            keyToVal.put(key, val);
            // key 对应的 freq 加一
            increaseFreq(key);
            return;
        }

        /* key 不存在，需要插入 */
        /* 容量已满的话需要淘汰一个 freq 最小的 key */
        if (this.capacity <= keyToVal.size()) {
            removeMinFreqKey();
        }

        /* 插入 key 和 val，对应的 freq 为 1 */
        // 插入 KV 表
        keyToVal.put(key, val);
        // 插入 KF 表
        keyToFreq.put(key, 1);
        // 插入 FK 表
        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());
        freqToKeys.get(1).add(key);
        // 插入新 key 后最小的 freq 肯定是 1
        this.minFreq = 1;
    }

    /**
     * 删除最小频次，并且最久未使用的key
     * 即LinkedHashSet的头结点
     */
    private void removeMinFreqKey() {
        // freq 最小的 key 列表
        LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
        // 其中最先被插入的那个 key 就是该被淘汰的 key
        int deletedKey = keyList.iterator().next();
        /* 更新 FK 表 */
        keyList.remove(deletedKey);
        if (keyList.isEmpty()) {
            freqToKeys.remove(this.minFreq);
            // 问：这里需要更新 minFreq 的值吗？
        }
        /* 更新 KV 表 */
        keyToVal.remove(deletedKey);
        /* 更新 KF 表 */
        keyToFreq.remove(deletedKey);
    }

    /**
     * 增加 key 对应的 freq
     */
    private void increaseFreq(int key) {
        int freq = keyToFreq.get(key);
        /* 更新 KF 表 */
        keyToFreq.put(key, freq + 1);
        /* 更新 FK 表 */
        // 将 key 从 freq 对应的列表中删除
        freqToKeys.get(freq).remove(key);
        // 将 key 加入 freq + 1 对应的列表中
        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
        freqToKeys.get(freq + 1).add(key);
        // 如果 freq 对应的列表空了，移除这个 freq
        if (freqToKeys.get(freq).isEmpty()) {
            freqToKeys.remove(freq);
            // 如果这个 freq 恰好是 minFreq，更新 minFreq
            if (freq == this.minFreq) {
                this.minFreq++;
            }
        }
    }
    
}
```

## 常数时间的增删改查

这个问题的⼀个技巧点在于，如何结合哈希表和数组，使得数组的删除操作时间复杂度也变成 O(1)？

### O(1) 时间插入、删除和获取随机元素

> #### [380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)
>
> ```java
> class RandomizedSet {
> 
>     public RandomizedSet() {}
>     /** 如果 val 不存在集合中，则插⼊并返回 true，否则直接返回 false */ 
>     public boolean insert(int val) {}
>     /** 如果 val 在集合中，则删除并返回 true，否则直接返回 false */ 
>     public boolean remove(int val) {}
>     /** 从集合中等概率地随机获得⼀个元素 */ 
>     public int getRandom() {}
>     
> }
> ```

本题的难点在于两点：

1. **插⼊，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)。**
2. **`getRandom` ⽅法返回的元素必须等概率返回随机元素，也就是说，如果集合⾥⾯有 n 个元素，每个元素被返回的概率必须是 1/n**。

我们先来分析⼀下：对于插⼊，删除，查找这⼏个操作，哪种数据结构的时间复杂度是 O(1)？

`HashSet` 肯定算⼀个对吧。哈希集合的底层原理就是⼀个⼤数组，我们把元素通过哈希函数映射到⼀个索引上；如果⽤拉链法解决哈希冲突，那么这个索引可能连着⼀个链表或者红⿊树。那么请问对于这样⼀个标准的 `HashSet`，你能否在 O(1) 的时间内实现 `getRandom` 函数？

其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组⾥⾯的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素。

`LinkedHashSet` 只是给 `HashSet` 增加了有序性，依然⽆法按要求实现我们的 `getRandom` 函数，因为底层⽤链表结构存储元素的话，是⽆法在 O(1) 的时间内访问某⼀个元素的。

根据上⾯的分析，对于 getRandom ⽅法，**如果想「等概率」且「在 O(1) 的时间」取出元素，⼀定要满⾜：底层⽤数组实现，且数组必须是紧凑的**。

这样我们就可以直接⽣成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。

**但如果⽤数组存储元素的话，插⼊，删除的时间复杂度怎么可能是 O(1) 呢？**

可以做到！对数组尾部进⾏插⼊和删除操作不会涉及数据搬移，时间复杂度是 O(1)。

**所以，如果我们想在 O(1) 的时间删除数组中的某⼀个元素 `val`，可以先把这个元素交换到数组的尾部，然后再 `pop` 掉**。

交换两个元素必须通过索引进⾏交换对吧，那么我们需要⼀个哈希表 `valToIndex` 来记录每个元素值对应的索引。

```java
public class RandomizedSet {

    List<Integer> nums;
    Map<Integer, Integer> valToIndex;
    Random rand = new Random();

    public RandomizedSet() {
        nums = new ArrayList<>();
        valToIndex = new HashMap<>();
    }

    /**
     * 新增元素
     *
     * @return 如果存在，返回false；不存在插入后，返回true
     */
    public boolean insert(int val) {
        if (valToIndex.containsKey(val)) {
            return false;
        }
        valToIndex.put(val, nums.size());
        nums.add(nums.size(), val);
        return true;
    }

    /**
     * 删除元素
     * 1. 数组将删除元素的下标，设置为最后一个元素的值
     * 2. 删除最后数组最后一个元素
     * 3. 维护map中元素和索引的映射关系
     */
    public boolean remove(int val) {
        // 若 val 不存在，不⽤再删除
        if (! valToIndex.containsKey(val)) {
            return false;
        }
        // 最后一个元素
        int lastElement = nums.get(nums.size() - 1);
        // 当前删除元素的索引
        int index = valToIndex.get(val);

        // 待删除元素索引设置为最后一个元素
        nums.set(index, lastElement);
        // 修改map中最后一个元素的索引指向
        valToIndex.put(lastElement, index);

        // list中删除最后一个元素
        nums.remove(nums.size() - 1);
        // map中删除待删除元素的索引映射
        valToIndex.remove(val);

        return true;
    }

    /**
     * @return 等概率返回其中一个元素
     */
    public int getRandom() {
        return nums.get(rand.nextInt(nums.size()));
    }

}
```

### 避开⿊名单的随机数

> **[710. 黑名单中的随机数](https://leetcode-cn.com/problems/random-pick-with-blacklist/)**
>
> 给定一个包含 [0，n) 中不重复整数的黑名单 blacklist ，写一个函数从 [0, n) 中返回一个不在 blacklist 中的随机整数。
>
> 对它进行优化使其尽量少调用系统方法 Math.random() 。
>
> ```java
> class Solution {
> 
>     public Solution(int n, int[] blacklist) {}
>     
>     /**在区间 [0,N) 中等概率随机选取⼀个元素并返回，这个元素不能是 blacklist 中的元素  */
>     public int pick() {}
> }
> ```

pick 函数会被多次调⽤，每次调⽤都要在区间 [0,N) 中「等概率随机」返回⼀个「不在 blacklist 中」的整数。

⽐如给你输⼊ N = 5, blacklist = [1,3]，那么多次调⽤ pick 函数，会等概率随机返回 0, 2, 4 中的某⼀个数字。

**⽽且题⽬要求，在 `pick` 函数中应该尽可能少调⽤随机数⽣成函数 `rand()`。**

**我们可以将区间 [0,N) 看做⼀个数组，然后将 blacklist 中的元素移到数组的最末尾，同时⽤⼀个哈希表进⾏映射**：

```java
public class BlackListRandom {

    /** 数组中黑明的分界线[sz,n)为黑名单的数 */
    int sz;
    /** 黑名单的映射 */
    Map<Integer, Integer> map;

    Random random = new Random();

    public BlackListRandom(int n, int[] blacklist) {
        map = new HashMap<>();
        sz = n - blacklist.length;
        // 初始化映射表
        for (int b : blacklist) {
            map.put(b, 0);
        }
        int last = n - 1;
        for (int b : blacklist) {
            // 如果 b 已经在区间 [sz, N) , 可以直接忽略
            if (b >= sz) {
                continue;
            }
            // 跳过无效索引
            while (map.containsKey(last)) {
                last--;
            }
            map.put(b, last);
            last--;
        }
    }

    public int pick() {
        // 随机选取⼀个索引
        int index = random.nextInt(sz);
        return map.getOrDefault(index, index);
    }

}
```

总结⼀下核⼼思想：
1、如果想⾼效地，等概率地随机获取元素，就要使⽤数组作为底层容器。

2、如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 pop 掉末尾的元素，这样时间复杂度就是 O(1) 了。当然，我们需要额外的哈希表记录值到索引的映射。

3、对于第⼆题，数组中含有「空洞」（⿊名单数字），也可以利⽤哈希表巧妙处理映射关系，让数组在逻辑上是紧凑的，⽅便随机取元素。



### 数据流的中位数

> **[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)**
>
> 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
>
> [2,3,4] 的中位数是 3
>
> [2,3] 的中位数是 (2 + 3) / 2 = 2.5
>
> 设计一个支持以下两种操作的数据结构：
>
> `void addNum(int num)` - 从数据流中添加一个整数到数据结构中。
> `double findMedian()` - 返回目前所有元素的中位数。
>
> ```java
> class MedianFinder {
> 
>     public MedianFinder() {}
>     /** 添加⼀个数字 */
>     public void addNum(int num) {}
>     /** 计算当前添加的所有数字的中位数 */
>     public double findMedian() {}
> }
> 
> ```

一个直接的解法可以用一个数组记录所有`addNum`添加进来的数字，通过插入排序的逻辑保证数组中的元素有序，当调用`findMedian`方法时，可以通过数组索引直接计算中位数。

但是用数组作为底层容器的问题也很明显，`addNum`搜索插入位置的时候可以用二分搜索算法，但是插入操作需要搬移数据，所以最坏时间复杂度为 O(N)。

那换链表？链表插入元素很快，但是查找插入位置的时候只能线性遍历，最坏时间复杂度还是 O(N)，而且`findMedian`方法也需要遍历寻找中间索引，最坏时间复杂度也是 O(N)。

那么就用平衡二叉树呗，增删查改复杂度都是 O(logN)，这样总行了吧？

比如用 Java 提供的`TreeSet`容器，底层是红黑树，`addNum`直接插入，`findMedian`可以通过当前元素的个数推出计算中位数的元素的排名。

很遗憾，依然不行，这里有两个问题。

1. `TreeSet`是一种`Set`，其中不存在重复元素的元素，但是我们的数据流可能输入重复数据的，而且计算中位数也是需要算上重复元素的。
2. `TreeSet`并没有实现一个通过排名快速计算元素的 API。假设我想找到`TreeSet`中第 5 大的元素，并没有一个现成可用的方法实现这个需求。

除了平衡二叉树，还有没有什么常用的数据结构是动态有序的？优先级队列（二叉堆）行不行？

好像也不太行，因为优先级队列是一种受限的数据结构，只能从堆顶添加/删除元素，我们的`addNum`方法可以从堆顶插入元素，但是`findMedian`函数需要从数据中间取，这个功能优先级队列是没办法提供的。

**我们必然需要有序数据结构，本题的核心思路是使用两个优先级队列**。

中位数是有序数组最中间的元素算出来的对吧，我们可以把「有序数组」抽象成一个倒三角形，宽度可以视为元素的大小，那么这个倒三角的中部就是计算中位数的

然后我把这个大的倒三角形从正中间切成两半，变成一个小倒三角和一个梯形，这个小倒三角形相当于一个从小到大的有序数组，这个梯形相当于一个从大到小的有序数组。

中位数就可以通过小倒三角和梯形顶部的元素算出来对吧？嗯，你联想到什么了没有？它们能不能用优先级队列表示？**小倒三角不就是个大顶堆嘛，梯形不就是个小顶堆嘛，中位数可以通过它们的堆顶元素算出来**。

![image-20211203162439489](https://cos.duktig.cn/typora/202112031625330.png)

梯形虽然是小顶堆，但其中的元素是较大的，我们称其为`large`，倒三角虽然是大顶堆，但是其中元素较小，我们称其为`small`。

当然，这两个堆需要算法逻辑正确维护，才能保证堆顶元素是可以算出正确的中位数，**我们很容易看出来，两个堆中的元素之差不能超过 1**。

因为我们要求中位数嘛，假设元素总数是`n`，如果`n`是偶数，我们希望两个堆的元素个数是一样的，这样把两个堆的堆顶元素拿出来求个平均数就是中位数；如果`n`是奇数，那么我们希望两个堆的元素个数分别是`n/2 + 1`和`n/2`，这样元素多的那个堆的堆顶元素就是中位数。

**不仅要维护`large`和`small`的元素个数之差不超过 1，还要维护`large`堆的堆顶元素要大于等于`small`堆的堆顶元素**。

**想要往`large`里添加元素，不能直接添加，而是要先往`small`里添加，然后再把`small`的堆顶元素加到`large`中；向`small`中添加元素同理**。

```java
public class 数据流的中位数_295 {

    static class MedianFinder {

        PriorityQueue<Integer> large;
        PriorityQueue<Integer> small;

        public MedianFinder() {
            // 小顶堆
            large = new PriorityQueue<>();
            // 大顶堆
            small = new PriorityQueue<>((a, b) -> b - a);
        }

        public double findMedian() {
            // 如果元素不一样多，多的那个堆的堆顶元素就是中位数
            if (large.size() < small.size()) {
                return small.peek();
            } else if (large.size() > small.size()) {
                return large.peek();
            }
            // 如果元素一样多，两个堆堆顶元素的平均数是中位数
            return (large.peek() + small.peek()) / 2.0;
        }

        public void addNum(int num) {
            if (small.size() >= large.size()) {
                small.offer(num);
                large.offer(Objects.requireNonNull(small.poll()));
            } else {
                large.offer(num);
                small.offer(Objects.requireNonNull(large.poll()));
            }
        }
    }

}

```







参看：[回溯算法入门级详解 + 练习（持续更新）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

