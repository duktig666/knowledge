# 数组

数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。

此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 前缀和

前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。

### 数组中的前缀和

[303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

求一个数字区间内的数字之和。

正常题解：

```java
class NumArray { 
 
    private int[] nums; 
 
    public NumArray(int[] nums) { 
        this.nums = nums; 
    } 
     
    public int sumRange(int left, int right) { 
        int res = 0; 
        for (int i = left; i <= right; i++) { 
            res += nums[i]; 
        } 
        return res; 
    } 
} 
```

前缀和：

```java
class NumArray { 
    // 前缀和数组 
    private int[] preSum; 
 
    /* 输⼊⼀个数组，构造前缀和 */ 
    public NumArray(int[] nums) { 
        // preSum[0] = 0，便于计算累加和 
        preSum = new int[nums.length + 1]; 
        // 计算 nums 的累加和 
        for (int i = 1; i < preSum.length; i++) { 
            preSum[i] = preSum[i - 1] + nums[i - 1]; 
        } 
    } 
     
    /* 查询闭区间 [left, right] 的累加和 */ 
    public int sumRange(int left, int right) { 
        return preSum[right + 1] - preSum[left]; 
    } 
} 
```

使用前缀和避免每次都进行O(n)的计算，而降为O(1)。

实际场景中的例子：输⼊任意⼀个分数段，返回有多少同学的成绩在这个分数段内。

```java
int[] scores; // 存储着所有同学的分数
// 试卷满分 100 分
int[] count = new int[100 + 1] 
// 记录每个分数有⼏个同学
for (int score : scores) 
    count[score]++ 
// 构造前缀和
for (int i = 1; i < count.length; i++) 
    count[i] = count[i] + count[i-1]; 
 
// 利⽤ count 这个前缀和数组进⾏分数段查询
```

### 矩阵中的前缀和

[304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

## 差分数组

差分数组的主要适⽤场景是 **频繁对原始数组的某个区间的元素进⾏增减**。

⽐如说，我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给...⼀通操作猛如⻁，然后问你，最后 nums 数组的值是什么？

对 nums 数组构造⼀个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差。

这样构造差分数组 diff，就可以快速进⾏区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可。

```java
public class Difference {

    /** 差分数组 */
    private int[] diff;

    /**
     * 输⼊⼀个初始数组，区间操作将在这个数组上进⾏
     */
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /**
     * 给闭区间 [i,j] 增加 val（可以是负数）
     */
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    /**
     * 返回结果数组
     */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
    
}
```

## 二分查找

⼆分查找：思路很简单，细节是魔⻤。⼆分查找真正的坑根本就不是那个细节问题，⽽是在于**到底要给 mid 加⼀还是减⼀，while ⾥到底⽤ <= 还是 <**。

⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。

**二分查找框架**：

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2 ;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

分析⼆分查找的⼀个技巧是：**不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节**。

其中 ... 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。

另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 `left + (right - left) / 2 `就和 `(left +right) / 2` 的结果相同，但是**有效防⽌了 left 和 right 太⼤直接相加导致溢出**。

### 寻找⼀个数（基本的⼆分搜索）

即搜索⼀个数，如果存在，返回其索引，否则返回 -1。

```java
int binarySearch(int[] nums, int target) { 
    int left = 0;  
    int right = nums.length - 1; // 注意 

    while(left <= right) { 
        int mid = left + (right - left) / 2; 
        if(nums[mid] == target) 
            return mid;  
        else if (nums[mid] < target) 
            left = mid + 1; // 注意 
        else if (nums[mid] > target) 
            right = mid - 1; // 注意 
    } 
    return -1; 
} 
```

#### **1、为什么 while 循环的条件中是 <=，⽽不是 <？**

答：因为初始化 right 的赋值是 nums.length - 1，即最后⼀个元素的索引，⽽不是 nums.length。

这⼆者可能出现在不同功能的⼆分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引⼤⼩为 `nums.length` 是越界的。

我们这个算法中使⽤的是前者 [left, right] 两端都闭的区间。**这个区间其实就是每次进⾏搜索的区间**。

**那 while 循环什么时候应该终⽌？**搜索区间为空的时候应该终⽌。

`while(left <= right)` 的终⽌条件是 `left == right + 1`，写成区间的形式就是 `[right + 1,right]`，或者带个具体的数字进去 [3, 2]，可⻅这时候区间为空，因为没有数字既⼤于等于 3 ⼜⼩于等于2 的吧。所以这时候 while 循环终⽌是正确的，直接返回 -1 即可。

`while(left < right)` 的终⽌条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 [2, 2]，这时候区间⾮空，还有⼀个数 2，但此时 while 循环终⽌了。也就是说这区间[2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你⾮要⽤ while(left < right) 也可以，我们已经知道了出错的原因，就打个补丁好了：

```java
//... 
while(left < right) { 
    // ... 
} 
return nums[left] == target ? left : -1; 
```

#### **2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？**

答：这也是⼆分查找的⼀个难点，不过只要你能理解前⾯的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，⽽且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下⼀步应该去搜索哪⾥呢？

当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。

#### **3、此算法有什么缺陷？**

答：⾄此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

⽐如说给你有序数组 `nums = [1,2,2,2,3]`，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是⽆法处理的。

这样的需求很常⻅，你也许会说，找到⼀个 target，然后向左或向右线性搜索不⾏吗？可以，但是不好，因为这样难以保证⼆分查找对数级的复杂度了。

我们后续的算法就来讨论这两种⼆分查找的算法。

### 寻找左侧边界的⼆分搜索

```java
int leftBound(int[] nums, int target) { 
    int left = 0, right = nums.length - 1; 
    while (left <= right) { 
        int mid = left + (right - left) / 2; 
        if (nums[mid] < target) { 
            left = mid + 1; 
        } else if (nums[mid] > target) { 
            right = mid - 1; 
        } else if (nums[mid] == target) { 
            // 别返回，锁定左侧边界 
            right = mid - 1; 
        } 
    } 
    // 最后要检查 left 越界的情况 
    if (left >= nums.length || nums[left] != target) 
        return -1; 
    return left;
} 
```

### 寻找右侧边界的二分搜索

```java
int rightBound(int[] nums, int target) { 
    int left = 0, right = nums.length - 1; 
    while (left <= right) { 
        int mid = left + (right - left) / 2; 
        if (nums[mid] < target) { 
            left = mid + 1; 
        } else if (nums[mid] > target) { 
            right = mid - 1; 
        } else if (nums[mid] == target) { 
            // 别返回，锁定右侧边界 
            left = mid + 1; 
        } 
    } 
    // 最后要检查 right 越界的情况 
    if (right < 0 || nums[right] != target) 
        return -1; 
    return right; 
} 
```



### ⼆分搜索问题的泛化

什么问题可以运⽤⼆分搜索算法技巧？

⾸先，**你要从题⽬中抽象出⼀个⾃变量 x，⼀个关于 x 的函数 f(x)，以及⼀个⽬标值 target**。同时，x, f(x), target 还要满⾜以下条件：

1、**f(x) 必须是在 x 上的单调函数（单调增单调减都可以）**。

2、**题⽬是让你计算满⾜约束条件 f(x) == target 时的 x 的值**。

举个具体的例⼦：

给你⼀个升序排列的有序数组 nums 以及⼀个⽬标元素 target，请你计算 target 在数组中的索引位置，如果有多个⽬标元素，返回最⼩的索引。

这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这⾥⾯ x, f(x), target 分别是什么呢？
我们可以把数组中元素的索引认为是⾃变量 x，函数关系 f(x) 就可以这样设定：

```java
// 函数 f(x) 是关于⾃变量 x 的单调递增函数
// ⼊参 nums 是不会改变的，所以可以忽略，不算⾃变量
int f(int x, int[] nums) { 
    return nums[x]; 
} 
```

其实这个函数 f 就是在访问数组 nums，因为题⽬给我们的数组 nums 是升序排列的，所以函数 f(x) 就是在x 上单调递增的函数。

### 运⽤⼆分搜索的套路框架

想要运⽤⼆分搜索解决具体的算法问题，可以从以下代码框架着⼿思考：

```java
// 函数 f 是关于⾃变量 x 的单调函数
int f(int x) { 
    // ... 
} 

// 主函数，在 f(x) == target 的约束下求 x 的最值
int solution(int[] nums, int target) { 
    if (nums.length == 0) return -1; 
    // 问⾃⼰：⾃变量 x 的最⼩值是多少？ 
    int left = ...; 
    // 问⾃⼰：⾃变量 x 的最⼤值是多少？ 
    int right = ... + 1; 

    while (left < right) { 
        int mid = left + (right - left) / 2; 
        if (f(mid) == target) { 
            // 问⾃⼰：题⽬是求左边界还是右边界？ 
            // ... 
        } else if (f(mid) < target) { 
            // 问⾃⼰：怎么让 f(x) ⼤⼀点？ 
            // ... 
        } else if (f(mid) > target) { 
            // 问⾃⼰：怎么让 f(x) ⼩⼀点？ 
            // ... 
        } 
    } 
    return left; 
} 
```
## 原地修改数组

对于数组来说，在尾部插⼊、删除元素是⽐较⾼效的，时间复杂度是 O(1)，但是如果在中间或者开头插⼊、删除元素，就会涉及数据的搬移，时间复杂度为O(N)，效率较低。

**把待删除元素交换到最后⼀个，然后再删除，可以避免数据搬移**。

### 有序数组/链表去重

即有序数组/链表，返回其不重复的数组/链表。

最常用的解法即 **快慢指针** 的元素覆盖。

针对于数组，快指针fast指向的元素与慢指针slow不同时，`arr[slow]=arr[fast]`.

针对于链表，快指针fast指向的元素与慢指针slow不同时，`slow.next=fast`，最后断掉slow之后的元素，即`slow.next=null`。

# 链表

单链表结构如下：

```java
public class ListNode {
    int val;
    ListNode next;

    ListNode() {}

    ListNode(int val) { this.val = val; }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```



## 合并两个有序链表

> [21.合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
>
> 给你输⼊两个有序链表，请你把他俩合并成⼀个新的有序链表。
>

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    // 虚拟头结点作用：并不知道谁的节点小，方便计算
    ListNode dummy = new ListNode(- 1), p = dummy;
    ListNode p1 = list1, p2 = list2;
    while (p1 != null && p2 != null) {
        // 谁的元素小，p指向谁，保持有序
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p不断前进
        p = p.next;
    }
    // 另一条链可能还存在节点
    if (p1 != null) {
        p.next = p1;
    }
    if (p2 != null) {
        p.next = p2;
    }
    // 去掉虚拟头结点
    return dummy.next;
}
```

这道题算是比较简单的，重点思路在：

1. **比较两条链表的当前节点，谁的节点小就将其接到最终链表上，然后修改链表的指针**。
2. **当其中一条链的节点为null时，结束比较，直接将另一条节点续接在结果链表的尾端即可。**

这里有一个小技巧：因为初始时，你的结果链表的第一个节点不知道该选择两条链表的哪一个节点，为了方便写代码，借助虚拟头结点的思想，最终合并完时，返回 `dummy.next`。



## 合并K个升序链表

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。
>
> [23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) {
        return null;
    }
    ListNode dummy = new ListNode(- 1);
    // 在使用一个变量，用来进行链表向后遍历的操作，dummy方便最后结果的返回
    ListNode res = dummy;
    PriorityQueue<ListNode> priorityQueue = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);
    // 利用优先队列，维护一个二叉堆（堆排），计算时每次取出最小的节点
    for (ListNode head : lists) {
        // 当前链表头结点不为null，加入优先队列当中
        if (head != null) {
            priorityQueue.add(head);
        }
    }
    // 每次将最小节点添加到 res 的末尾
    while (! priorityQueue.isEmpty()) {
        ListNode minNode = priorityQueue.poll();
        res.next = minNode;
        // 当前最小元素节点 下一个元素 不为null时，继续向优先队列添加
        if (minNode.next != null) {
            priorityQueue.add(minNode.next);
        }
        // 结果链表，后移
        res = res.next;
    }
    return dummy.next;
}
```

这道题算是 合并2个升序链表的进阶版，主体的思路还是不变，但是 **怎么从所有链表中选取最小的头结点** 这是一个问题？

数量固定，动态排序，最直观的想法就是堆排。所以我们选用 `PriorityQueue`  来解决问题，其底层实现是 二叉堆。

## 删除单链表的倒数第 k 个节点

从前往后寻找单链表的第 k 个节点很简单，⼀个 for 循环遍历过去就找到了，但是 **如何寻找从后往前数的第k 个节点呢**？

那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k 个节点，不也是⼀个 for 循环的事⼉吗？

是的，但是算法题⼀般只给你⼀个 ListNode 头结点代表⼀条单链表，你不能直接得出这条链表的⻓度 n，⽽需要先遍历⼀遍链表算出 n 的值，然后再遍历链表计算第 n - k 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点。

那么，我们能不能 **只遍历⼀次链表，就算出倒数第 k 个节点**？

这个解法就⽐较巧妙了，假设 k = 2，思路如下：

⾸先，我们先让⼀个指针 p1 指向链表的头节点 head，然后⾛ k 步：

![image-20211129171930518](https://cos.duktig.cn/typora/202111291719252.png)

现在的 p1，只要再⾛ n - k 步，就能⾛到链表末尾的空指针了对吧？

趁这个时候，再⽤⼀个指针 p2 指向链表头节点 head：

![image-20211129172052893](https://cos.duktig.cn/typora/202111291720146.png)

接下来就很显然了，让 p1 和 p2 同时向前⾛，p1 ⾛到链表末尾的空指针时⾛了 n - k 步，p2 也⾛了 n -k 步，也就是链表的倒数第 k 个节点：

![image-20211129172209983](https://cos.duktig.cn/typora/202111291722623.png)

这样，只遍历了⼀次链表，就获得了倒数第 k 个节点 p2。

代码如下：

```java
/**
 * 寻找链表倒数第 N 个节点
 */
public ListNode findNthFromEnd(ListNode head, int n) {
    ListNode p1 = head, p2 = head;
    for (int i = 0; i < n; i++) {
        p1 = p1.next;
    }
    while (p1 != null) {
        p1 = p1.next;
        p2 = p2.next;
    }
    return p2;
}
```

至于删除倒数第N个链表节点，需要借助下虚拟头结点，毕竟还需要返回头结点。另一个作用，是为了解决空指针的问题。

比如：说链表总共有 5 个节点，题⽬就让你删除倒数第 5 个节点，也就是第⼀个节点，那按照算法逻辑，应该⾸先找到倒数第 6 个节点。但第⼀个节点前⾯已经没有节点了，这就会出错。

代码入下：

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(- 1);
    dummy.next = head;
    ListNode pre = findNthFromEnd(dummy, n + 1);
    pre.next = pre.next.next;
    return dummy.next;
}
```

## 链表的中间节点

[https://leetcode-cn.com/problems/middle-of-the-linked-list/](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

> 如果节点个数为偶数，两个中点，返回第二个

寻找链表的重点有三个思路

1. 利用辅助数组存储链表节点，arr[N/2]即为链表中点。
   1. 需要额外的数组空间
   2. 链表节点数量不确定，需要申请足够数量的空间，造成浪费
2. 单指针扫描。第一次扫描统计元素个数N，第二次扫描到N/2即为中点
3. 快慢指针。快指针走两步，慢指针走一步，当快指针为null或者快指针的下一个节点为null时，慢指针指向的节点即为中点。

辅助数组实现

```java
/**
   * 辅助数组实现： 中点即为 N / 2
     * 缺点：需要利用辅助空间，不确定节点数量，根据题意申请固定的100个空间有些浪费
     */
public ListNode middleNode2(ListNode head) {
    ListNode[] nodes = new ListNode[100];
    int t = 0;
    while (head != null) {
        nodes[t++] = head;
        head = head.next;
    }
    return nodes[t / 2];
}
```

快慢指针

```java
/**
 * 快慢指针寻找链表中点
 * 快指针是慢指针的2倍，快指针为空或者快指针的下一个节点为空，证明慢指针找到了链表的中点
 * (两个中点的情况，选取第二个)
 * <p>
 * 另一种思路：单指针扫描（不如快慢指针）
 * 单指针扫描第一次统计有N个节点
 * 第二次扫描到N/2时返回中点
 */
public ListNode middleNode(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```

## 判断单链表是否有环

[https://leetcode-cn.com/problems/linked-list-cycle/](https://leetcode-cn.com/problems/linked-list-cycle/)

判断链表是否包含环属于经典问题了，解决⽅案也是⽤快慢指针：

每当慢指针 slow 前进⼀步，快指针 fast 就前进两步。

如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了slow ⼀圈，说明链表中含有环。

![单链表成环](https://cos.duktig.cn/typora/202109062136574.gif)

**思路**：

（1）定义两个指针分别为 slow，fast，并且将指针均指向链表头节点。
（2）规定，slow 指针每次前进 1 个节点，fast 指针每次前进两个节点。
（3）当 slow 与 fast 相等，且二者均不为空，则链表存在环。

只需要把寻找链表中点的代码稍加修改就⾏了：

```java
/**
 * 快慢指针判断链表是否成环
 */
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
```

## 链表中环的入口

如果链表中含有环，如何计算这个环的起点？

本题算是“判断链表是否有环”的进阶题。

> 给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。
>
> 题目详情参看：[链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)

思路：**当快慢指针相遇时，让其中任⼀个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。**

我们假设快慢指针相遇时，慢指针 slow ⾛了 k 步，那么快指针 fast ⼀定⾛了 2k 步：

![image-20211129194031537](https://cos.duktig.cn/typora/202111291940177.png)

fast ⼀定⽐ slow 多⾛了 k 步，这多⾛的 k 步其实就是 fast 指针在环⾥转圈圈，所以 k 的值就是环⻓度的「整数倍」。

假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k -m，也就是说如果从 head 前进 k - m 步就能到达环起点。

巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始⾛k步可以转回到相遇点，那⾛ k - m 步肯定就⾛到环起点了：

![image-20211129194348546](https://cos.duktig.cn/typora/202111291943431.png)

所以，只要我们把快慢指针中的任⼀个重新指向 head，然后两个指针同速前进，k - m 步后⼀定会相遇，相遇之处就是环的起点了。

**代码实现**：

```java
/**
 * 找到环的入口节点
 */
public ListNode detectCycle(ListNode head) {
    // 先找出环中的相遇节点
    ListNode meetingNode = getMeetingNode(head);
    // 没有环，返回null
    if (meetingNode == null) {
        return null;
    }
    // p1 指向快慢指针相遇的节点
    ListNode p1 = meetingNode;
    // p2 指向头节点
    ListNode p2 = head;
    // p1和p2以相同的速度向前移动，当p2指向环的入口节点时，p1已经围绕着环走了n圈又回到了入口节点。
    while (p1 != p2) {
        p1 = p1.next;
        p2 = p2.next;
    }
    //返回入口节点
    return p1;
}

/**
 * 找到环中相遇的节点，不存在环返回null
 */
private ListNode getMeetingNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            return slow;
        }
    }
    return null;
}
```

## 链表是否相交

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
>
> ![链表相交](https://cos.duktig.cn/typora/202109171631046.png)
>
> **注意：**
>
> - 如果两个链表没有交点，返回 null。
> - 在返回结果后，两个链表仍须保持原有的结构。
> - 可假定整个链表结构中没有循环。
> - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
>
> 题目详细信息参看：[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**借助辅助空间（Set）解题**

**思路**：

1. 扫描链表A，将所有节点添加到`HashSet`中;
2. 扫描链表B，判断没有节点是否存在在集合中，如果存在，表示两个链表相交，返回此节点；
3. 扫描完B，都不存在，说明未相交，返回`null`。

**时间复杂度**：O(n)  **空间复杂度**：O(n)

**代码实现**：

```java
public ListNode getIntersectionNodeByHashSet(ListNode headA, ListNode headB) {
    // 边界判断
    if (headA == null || headB == null) {
        return null;
    }
    Set<ListNode> set = new HashSet<>();
    while (headA != null) {
        set.add(headA);
        headA = headA.next;
    }
    // 存在A相同的节点，即说明相交
    while (headB != null) {
        if (set.contains(headB)) {
            return headB;
        }
        headB = headB.next;
    }
    return null;
}
```

**快慢指针**

难点在于，由于两条链表的⻓度可能不同，两条链表之间的节点⽆法对应：

![image-20211129200123732](https://cos.duktig.cn/typora/202111292001140.png)

如果⽤两个指针 p1 和 p2 分别在两条链表上前进，并不能同时⾛到公共节点，也就⽆法得到相交节点 c1。

所以，**解决这个问题的关键是，通过某些⽅式，让 p1 和 p2 能够同时到达相交节点 c1**。

所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了⼀起。

如果这样进⾏拼接，就可以让 p1 和 p2 同时进⼊公共部分，也就是同时到达相交节点 c1：

![image-20211129200245331](https://cos.duktig.cn/typora/202111292002414.png)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。

```java
/**
 * 得到链表相交的起点节点，若未相交返回null
 * 思路二：双指针
 * 时间复杂度：O(a+b) 空间复杂度：O(1)
 * <p>
 * 循环中的代码可以写为：
 * // p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表
 * if (p1 == null) {
 * p1 = headB;
 * } else {
 * p1 = p1.next;
 * }
 * // p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表
 * if (p2 == null) {
 * p2 = headA;
 * } else {
 * p2 = p2.next;
 * }
 */
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // p1 指向 A 链表头结点，p2 指向 B 链表头结点
    ListNode p1 = headA, p2 = headB;
    while (p1 != p2) {
        p1 = p1 == null ? headB : p1.next;
        p2 = p2 == null ? headA : p2.next;
    }
    return p1;
}
```

## 链表的递归



# 字符串

## 滑动窗口

**滑动窗⼝算法的思路是这样：**

1、我们在字符串 S 中使⽤双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间[left, right) 称为⼀个「窗⼝」。

2、我们先不断地增加 right 指针扩⼤窗⼝ [left, right)，直到窗⼝中的字符串符合要求（包含了 T 中的所有字符）。

3、此时，我们停⽌增加 right，转⽽不断增加 left 指针缩⼩窗⼝ [left, right)，直到窗⼝中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新⼀轮结果。

4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

**思考以下四个问题：**

1、当移动 right 扩⼤窗⼝，即加⼊字符时，应该更新哪些数据？

2、什么条件下，窗⼝应该暂停扩⼤，开始移动 left 缩⼩窗⼝？

3、当移动 left 缩⼩窗⼝，即移出字符时，应该更新哪些数据？

4、我们要的结果应该在扩⼤窗⼝时还是缩⼩窗⼝时进⾏更新？

```java
/**
 * 滑动窗⼝算法框架
 */
public void slidingWindow(String s, String t) {
    // needs代表t中字符出现次数，window代表窗口中相应字符出现的次数
    Map<Character, Integer> need = new HashMap<>(), window = new HashMap<>();
    // 将t对应字符及次数存储到map
    for (char c : t.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }
    // 左右指针
    int left = 0, right = 0;
    // valid 变量表示窗⼝中满⾜ need 条件的字符个数；如果 valid 和 need.size 的⼤⼩相同，则说明窗⼝已满⾜条件，已经完全覆盖了串 T
    int valid = 0;
    while (right < s.length()) {
        // c 是将移⼊窗⼝的字符
        char c = s.charAt(right);
        // 右移窗⼝
        right++;
        // 进⾏窗⼝内数据的⼀系列更新

        /* debug 输出的位置 */
        System.out.printf("window: [%d, %d)\n", left, right);

        // 判断左侧窗⼝是否要收缩（条件根据具体题意判断）
        while (left <= right) {
            // d 是将移出窗⼝的字符
            char d = s.charAt(left);
            // 左移窗⼝
            left++;
            // 进⾏窗⼝内数据的⼀系列更新

        }
    }
}
```



# 算法策略——最⼤化「优势」

田忌赛马的故事告诉我们：**打得过就打，打不过就拿⾃⼰的垃圾和对⽅的精锐互换**。

> 给你输⼊两个⻓度相等的数组 nums1 和 nums2，请你重新组织 nums1 中元素的位置，使得 nums1 的「优势」最⼤化。
> 如果 nums1[i] > nums2[i]，就是说 nums1 在索引 i 上对 nums2[i] 有「优势」。优势最⼤化也就是说让你重新组织 nums1，尽可能多的让 nums[i] > nums2[i]。
>
> [870. 优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle/)
>
> 这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒，你就是孙膑。

**小插曲分析：**

**将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。**

**为什么？**

我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。
如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？

显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。

但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢耶，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？

```java
public int[] advantageCount(int[] nums1, int[] nums2) {
    int n = nums1.length;
    // 从大到小排序的优先队列；数组中第一个元素代表num2中当前元素的索引，第二个元素代表其数值
    PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> b[1] - a[1]);
    for (int i = 0; i < n; i++) {
        priorityQueue.offer(new int[] {i, nums2[i]});
    }
    Arrays.sort(nums1);
    int left = 0, right = n - 1;
    int[] res = new int[n];
    // 每次去nums2中最大的
    while (! priorityQueue.isEmpty()) {
        int[] curs = priorityQueue.poll();
        // index为当前最大值的索引
        int index = curs[0], maxValue = curs[1];
        // nums1大于最大值，选取nums1当前的值
        if (nums1[right] > maxValue) {
            res[index] = nums1[right];
            right--;
        } else {
            // nums1小于等于时，选取最差的数
            res[index] = nums1[left];
            left++;
        }
    }
    return res;
}
```









# 深度优先搜索

> **深度优先搜索** 算法（英语：Depth-First-Search，**DFS**）是一种用于遍历或搜索树或图的算法。这个算法会 **尽可能深** 的搜索树的分支。当结点 `v` 的所在边都己被探寻过，搜索将 **回溯** 到发现结点` v `的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。一个理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 **不断变化** 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。

搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。

搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。





参看：[回溯算法入门级详解 + 练习（持续更新）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)