# 网络常见面试题

## 1.HTTP

### 1.1 HTTP状态码

状态码分类：

| 分类 | 描述                                               |
| ---- | -------------------------------------------------- |
| 1**  | **信息**，服务器收到请求，需要请求者继续执行操作   |
| 2**  | **成功**，操作被成功接收并处理                     |
| 3**  | **重定向**，需要进一步的操作以完成请求             |
| 4**  | **请求错误**，请求包含语法错误或无法完成请求       |
| 5**  | **服务器错误**，服务器在处理请求的过程中发生了错误 |

常见状态码：

| 状态码 | 状态码英文名称                | 描述                                                         |
| ------ | ----------------------------- | ------------------------------------------------------------ |
| 100    | Continue                      | 客户端应当继续发送请求                                       |
| 101    | Switching Protocols           | 切换协议（只能切换到更高级的协议，例如，切换到HTTP的新版本协议）。 |
| 200    | OK                            | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                       | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                      | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information | 非授权信息。请求成功。但返回的实体头部元信息不在原始的服务器，而是一个副本（来自本地或者第三方的拷贝） |
| 204    | No Content                    | 无内容。服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。在未更新网页的情况下，可确保浏览器继续显示当前文档。 |
| 205    | Reset Content                 | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content               | 部分内容。服务器成功处理了部分GET请求                        |
| 300    | Multiple Choices              | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently             | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                         | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                     | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                  | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                     | 使用代理。所请求的资源必须通过代理访问                       |
| 400    | Bad Request                   | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                  | 请求要求用户的身份认证（没有权限）                           |
| 402    | Payment Required              | 保留，将来使用                                               |
| 403    | Forbidden                     | 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不足）   |
| 404    | Not Found                     | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed            | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                | 服务器无法根据客户端请求的内容特性完成请求                   |
| 408    | Request Time-out              | 服务器等待客户端发送的请求时间过长，超时                     |
| 500    | Internal Server Error         | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented               | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                   | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable           | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out              | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported    | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

高频：200、201、202、301、302、400、401、402、403、404、405、408、500、502、503、504

完整HTTP状态码参看：[HTTP状态码（百度百科）](https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin)    [HTTP状态码（菜鸟教程）](https://www.runoob.com/http/http-status-codes.html)

### 1.2 HTTP包含哪些请求？

- GET：对服务器资源的简单请求
- POST：用于发送包含用户提交数据的请求

------------以及------------

- HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头
- PUT：传说中请求文档的一个版本
- DELETE：发出一个删除指定文档的请求
- TRACE：发送一个请求副本，以跟踪其处理进程
- OPTIONS：返回所有可用的方法，检查服务器支持哪些方法
- CONNECT：用于ssl隧道的基于代理的请求

### 1.3 各种协议与 HTTP 协议之间的关系

一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。

图片来源：《图解 HTTP》

![各种协议与HTTP协议之间的关系](https://cos.duktig.cn/typora/202109171410125.png)

### 1.4 HTTP 长连接、短连接

在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。**

—— [《HTTP 长连接、短连接究竟是什么？》](https://www.cnblogs.com/gotodsp/p/6366163.html)

### 1.5 HTTP 是不保存状态的协议,如何保存用户状态?

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？

Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。

![HTTP是无状态协议](https://cos.duktig.cn/typora/202109171421646.png)

### 1.6 Cookie 的作用是什么?和 Session 有什么区别？

Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如 ：

① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；

② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；

③ 登录一次网站后访问网站其他页面不需要重新登录。

**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### 1.7 HTTP 1.0 和 HTTP 1.1 的主要区别是什么?

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：

1. **长连接** : **在 HTTP/1.0 中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1 起，默认使用长连接** ,默认开启 Connection： keep-alive。 **HTTP/1.1 的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
2. **错误状态响应码** :在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
3. **缓存处理** :在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
4. **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

### 1.8 URI 和 URL 的区别是什么?

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### 1.9 HTTP 和 HTTPS 的区别？

1. **端口** ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

2. 安全性和资源消耗：

   HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。

   HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

   - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；
   - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。



## 2. https

### 2.1 https加密过程

1. 服务器的**公钥**和**身份信息**（原始信息）用一个**hash算法**生成一个**消息摘要**。
2. 使用CA机构的私钥将消息摘要加密生成**数字签名**。
3. 将原始信息和数字签名合并，形成**数字证书**，发送至客户端。
4. 客户端将原始信息用同样的hash算法再次生成消息摘要。
5. 客户端用CA机构的公钥将数字签名解密，得到CA的消息摘要。
6. 客户端将**原始信息hash后的消息摘要**与**CA解密后的消息摘要**进行对比，如果相同证明无问题。
7. 随后进行非对称+对称加密解密通信（参看下文https通信流程）

![https加密流程](https://gitee.com/koala010/typora/raw/master/img/20210624091448.png)



![https客户端解密](https://gitee.com/koala010/typora/raw/master/img/20210624091518.png)

### 2.2 https通信流程

1. 客户端发送请求。
2. 服务器发送数字证书（包含公钥）
3. 客户端用预置的CA列表验证证书（有问题，提示风险）
4. 浏览器随机生成对称密钥，并使用服务器的公钥加密
5. 服务器使用私钥进行解密，得到对称密钥
6. 双方使用对称加密进行通信

![https流程](https://gitee.com/koala010/typora/raw/master/img/20210624091840.png)



参考：

- [彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231) (演变过程和每个步骤的漏洞及解决方案讲的比较清楚)
- [谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)     [一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)  （以故事的方式讲解，更加容易理解）

## 3. TCP三次握手、四次挥手

参看：[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

### 3.1 三次握手过程

> 三次握手（Three-way Handshake）是建立TCP连接时，客户端和服务端总共发送3个包，确认双方的接受能力和发送能力是否正常，指定初始化序列号，为后面的可靠传输做准备。实质是连接服务器指定端口，建立TCP连接，同步双方的序列号和确认号，交换TCP的窗口大小信息。

![三次握手漫画](https://cos.duktig.cn/typora/202109171107769.png)

![三次握手过程](https://gitee.com/koala010/typora/raw/master/img/三次握手过程20210624165041.png)

名词解释：

**SYN**：同步序列编号，是TCP/IP建立连接时使用的握手信号。表示建立连接。

**seq**：TCP报文段中第一个字节的数据编号，由本地随机生成。

**ACK**：报文段首部“ACK”字段，为1时表示发来的数据已确认接收无误。当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

**ack**：TCP报文段首部中“**确认号字段**”的具体数值，“`ack=x+1`”表示服务器希望客户端下次发送数据的字节序号为`x+1`



刚开始客户端处于**CLOSED状态**，服务端处于**LISTEN状态**。

第一次握手：

客户端给服务端发送一个SYN报文，并指明客户端的初始化序列号ISN（seq的值，假设为x）。此时客户端的状态为**CLOSED->SYN_SEND**。

发送给服务器的数据为：`SYN=1`，`seq=x`。SYN=1的报文段不能携带数据，而且需要消耗一个序号。

第二次握手：

服务器接收到客户端的SYN报文后，用自己的SYN作为应答，并且指定了服务端的初始化序列号ISN（seq的值，假设为y）。并且将ACK的值设置为客户端ISN+1（即客户端的seq+1），标识已经收到客户端的SYN报文。此时服务器的状态为**LISTEN->SYN_RCVD**。

发送给客户端的数据为：`SYN=1`，`ACK=1`，初始序号`seq=y`，确认号`ack=x+1`。

第三次握手：

客户端收到SYN报文后，应答一个ACK报文，将服务器的ISN+1（seq+1）作为ACK的值，表示收到服务器的SYN报文。此时客户端的状态为**SYN_SENT->ESTABLISHED**，服务器的状态为**SYN_RCVD->ESTABLISHED**。

发送服务端数据为：`ACK=1`，初始序号`seq=x+1`，确认号`ack=y+1`。



发送第一个SYN报文的一端执行**主动打开（active open）**，接收这个SYN并回发SYN的一端执行**被动打开（passive open）**。

### 3.2 为什么要三次握手，两次不行吗？

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

**第一次握手**：客户端发送网络包，服务端确认接收。服务端就能得出结论：客户端发送能力和服务端接收能力正常。

**第二次握手**：服务端发送网络包，客户端确认接收。客户端就能得出结论：服务端的发送、接收能力和客户端的发送能力正常。**但服务端并不能确定客户端的接收能力正常。**

**第三次握手**：客户端发送网络包，服务端确认接收。服务端可以得出：客户端服务端发送、接收能力都正常。三次发送才能保证。

**如果是两次握手可能出现的情况**：

如果客户端发送一个连接请求，但因为报文丢失没有收到确认，于是客户端又发送了第二个连接请求，服务端确认连接，发送完数据后，释放了当前的连接。但是客户端发送的第一个连接请求，可能因为是在某些网络节点长时间滞留，延误到释放第二个连接后才到达服务端，此时服务端认为这是一个新的连接请求，回复确认并建立连接，但是客户端忽略此确认，一直未向服务端发送数据，导致服务端一直等待客户端发送数据，浪费资源。

### 3.3 第 2 次握手传回了 ACK，为什么还要传回 SYN？

接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”

> SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

### 3.4 什么是半连接队列？

> 服务器第一次收到SYN后，处于SYN_RVCD状态，双方还未正式建立连接，此时服务器会将此种状态下的连接放在一个队列里，成为“半连接队列”。

当然，建立完三次握手的连接会放在**全连接队列**里。如果队列满，可能会出现丢包现象。

**SYN-ACK 重传次数的问题**：

服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

### 3.5 ISN(Initial Sequence Number)是固定的吗？

建立连接时发送SYN是，需要为连接选择初始序列号ISN。ISN可以看做一个32位的计数器，每4ms加1，随时间变化，每个连接具有不同的ISN。

目的是为了防止网络中被延迟的分组在以后被再次传送，而导致连接的另一方对它做出错误的解释。

三次握手中客户端和服务端要交换ISN，以便让对方知道接下来接收数据按照何种序列号组装数据。如果ISN是固定的，攻击者和容易猜出后续的确认号。

### 3.6 三次握手的过程中可以携带数据吗？

第一次和第二次不可以携带数据，第三次可以携带数据。

如果第一次握手客户端携带数据，如果有恶意攻击者攻击服务器，每次都携带了大量的数据，疯狂发送，而且不理会服务器的接收、发送能力，那么服务器需要花费很多时间和空间接受这些报文。浪费时间，可能还会导致服务器崩溃。第二次同理。

第三次，客户端已经处于ESTABLISHED状态，而且已知服务端的发送接收能力正常，所以可以携带数据。

### 3.7 什么是SYN攻击？

服务端资源在第二次握手时分配，客户端资源在第三次握手时分配。服务器容易受到SYN洪泛攻击，即客户端在短时间内伪造大量不存在的IP地址，并向服务端不断发SYN包，服务端需要回复确认并等待客户端的回复。由于源地址IP不存在，服务端不断重发直至超时，这些伪造的SYN包长时间占用未连接队列，导致正常的SYN队列满而被丢弃，从而引发网络堵塞甚至系统瘫痪。

SYN是一种典型的DoS/DDoS攻击。

检测：服务器大量存在半连接状态，特别是源地址IP是随机的，基本可以判断为SYN攻击。

在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```java
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

### 3.8 四次挥手过程

![四次挥手流程图](https://gitee.com/koala010/typora/raw/master/img/四次挥手流程图20210624203352.jpg)

名词解释：

**FIN**：代表关闭连接。

> 建立连接需要三次握手，而终止连接需要四次握手，这是由于TCP的半关闭（half-close）造成的。
>
> 半关闭：TCP提供了在结束发送后还能接收来自另一端数据的能力。

刚开始客户端和服务端都处于ESTABLISHED状态。

以下过程，假设由客户端先发起关闭请求

第一次挥手：

客户端发送FIN报文，并携带生成的序列号，停止再发送数据，主动关闭TCP连接，等待后端确认。此时客户端的状态为**ESTABLISHED->FIN_WAIT1**。

发送到服务端的数据：`FIN=1`，`seq=u`。

第二次挥手：

服务端收到FIN后，发送ACK报文，并将ACK值设置为客户端序列值+1，表明已经收到客户端的报文。此时TCP处于半关闭状态，客户端客户端到服务端的连接被释放（服务端还可以向客户端发送数据），客户端等待服务端发出的连接释放报文段。此时服务端的状态为**ESTABLISHED->CLOSE_WAIT**。

客户端收到服务端的确认后，状态为**FIN_WAIT1->FIN_WAIT2**。

发送到客户端的数据：`ACK=1`，`seq=v`，`ack=u+1`。

第三次挥手：

如果服务器也想断开连接，同客户端一样发送FIN报文，等待客户端确认。此时服务端的状态为**CLOSE_WAIT->LAST_ACK**。

发送到客户端的数据：`FIN=1`,`ACK=1`，`seq=w`，`ack=u+1`。

第四次挥手：

客户端收到FIN报文后，发送ACK报文作为应答，并携带ACK报文序列号的值（服务端seq+1）。客户端的状态为**FIN_WAIT2->TIME_WAIT**。等待2MSL后，客户端的状态为**TIME_WAIT->CLOSED**。

发送到服务端的数据：`ACK=1`，`seq=u+1`，`ack=w+1`。

服务端收到ACK报文后，状态为**LAST_ACK->CLOSED**。

如果服务端收不到ACK报文，那么服务端超时重传FIN-ACK报文，客户端重新确认，重启时间等待计时器，直至最后客户端和服务端都变为CLOSED状态。

### 3.9 挥手为什么要四次？

挥手操作需要四次，是因为**TCP提供了在一段结束发送后还能接收来自另一端数据的能力**。

握手时，SYN报文用来同步，客户端可以发送SYN报文给服务端，服务端收到后可以直接发送SYN+ACK报文来应答。但是挥手时需要考虑到服务端并不会立即关闭SOCKET，可能还需要向客户端发送数据，所以只是先回复一个ACK报文，告诉客户端“你的FIN报文我收到了”。等到数据全部发完，服务端再发送FIN报文。故需要四次挥手。

### 3.10 为什么要有2MSL等待状态？

> MSL（Maximum Segment Lifetime）可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

> TIME_WAIT状态也成为2MSL等待状态，每个具体TCP实现必须选择一个报文段最大生存时间MSL，这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

两个理由：

- **保证客户端发送的最后一个ACK报文段能够到达服务端**。
  - 第四次挥手的ACK报文可能丢失，服务端则可能不会改变为CLOSED状态。所以需要服务端超时重新发送FIN+ACK报文，客户端重新确认，重启时间等待计时器，重新发送ACK报文，保证客户端和服务端都能进入到CLOSED状态。
- **防止“已失效的连接请求报文段”出现在本连接中**。

### 3.11 三次握手和四次挥手状态变迁总结

![三次握手和四次挥手状态变迁总结](https://gitee.com/koala010/typora/raw/master/img/三次握手和四次挥手状态变迁总结.jpg)



## 4. TCP和UDP

### 4.1 TCP和UDP的区别

参考：

- [TCP和UDP的最完整的区别](https://www.cnblogs.com/williamjie/p/9390164.html)
- [TCP和UDP的区别](https://blog.csdn.net/zhang6223284/article/details/81414149)

|                                                      | TCP                      | UDP                                |
| :--------------------------------------------------- | ------------------------ | ---------------------------------- |
| 是否需要建立连接                                     | 是                       | 否                                 |
| 结构                                                 | 较复杂                   | 简单                               |
| 是否可靠（数据完整性）                               | 可靠                     | 不可靠                             |
| 流量控制（发送方不会发送过快而超过接收方的处理能力） | 支持                     | 不支持                             |
| 时间/延迟保障                                        | 不支持                   | 不支持                             |
| 最小带宽保障                                         | 不支持                   | 不支持                             |
| 数据发送顺序                                         | 保障                     | 不保障                             |
| 发送方式                                             | 字节流                   | 数据报                             |
| 传输速度                                             | 较慢                     | 较快                               |
| 对系统资源要求                                       | 较高                     | 较低                               |
| 适用场景                                             | 保证数据完整性、少量数据 | 可容忍一定的数据丢包、传输大量数据 |

总结：

- TCP面向连接，UDP是无连接的
- TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付
- UDP的传输速度大于TCP
- TCP面向字节流，实际上TCP是把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机发送速率降低（对实时应用很有用）
- TCP只能是点到点的；UDP支持一对一，一对多，多对多的交互通信
- TCP首部开销20个字节；UDP首部开销小，只有8字节
- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
- TCP适合需要保证数据完整性且数据量小的场景；UDP适合可容忍一定的数据丢包、传输大量数据，对数据实时性要求高的场景

#### UDP

![UDP报头](https://gitee.com/koala010/typora/raw/master/img/UDP20210624221808.png)

UDP 除了端口号，基本啥都没有了。

**适用场景**：

- 网络情况稳定的内网或者可以在一定程度上容忍丢包的应用。
- 不需要一对一建立连接，可以广播应用。
- 需要处理速度够快，即使网络拥塞。

**例子**：

- 直播。实时性要求高，可以丢包，但不能卡顿。
- 实时游戏。实时性高，需要极大程度上降低延迟，减少网络问题对游戏的影响。
- 物联网。中断资源少，很可能是一个很小的嵌入式系统，维护TCP代价太大，而且对实时性要求比较高。

#### TCP

![TCP报头](https://gitee.com/koala010/typora/raw/master/img/TCP20210624222442.png)

**报头的作用**：

- 源端口和目标端口必不可少。
- 包的序号。主要是为了解决乱序问题。TCP传输是有序的。
- 确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题。
- 状态位。SYN 是发起一个请求连接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更。
- 窗口大小。TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。

### 4.2 TCP 协议如何保证可靠传输？

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### ARQ 协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。

##### 停止等待 ARQ 协议

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。

在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

**优缺点：**

- **优点：** 简单
- **缺点：** 信道利用率低，等待时间长

**1) 无差错情况:**

发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。

**2) 出现差错情况（超时重传）:**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。

因此每发送完一个分组需要设置一个**超时计时器**，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。

另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。

**3) 确认丢失和确认迟到**

- **确认丢失** ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。
- **确认迟到** ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。

##### 连续 ARQ 协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优缺点：**

- **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。
- **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

#### 滑动窗口和流量控制

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

#### 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1。
- **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

## 5.OSI与TCP/IP以及五层模型

### OSI与TCP/IP以及五层模型各层的结构与功能，都有哪些协议？

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。

![五层体系结构](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)

低三层为**通信子网，负责数据传输**；高三层为**资源子网，相当于计算机系统，完成数据处理**； 传输层承上启下。

结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。

#### 应用层

应用层是体系结构中的最高层。应用层的任务是**通过应用进程间的交互来完成特定的网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**等等。我们把应用层交互的数据单元称为报文。

- 应用层

  - 应用层定义的是应用程序用于请求网络服务的**接口**，而不是指应用程序本身。应用层主要定义了应用程序能够从网络上请求使用哪种类型的服务，并且规定了在从应用程序接收消息或向应用程序发送消息时，数据所必须采用的**格式**。各种应用程序协议，如http、FTP、SMTP、POP3

- 表示层

  - 信息的语法语义以及他们的关联，如加密解密、转换翻译、压缩解压缩，解决数据的语法表示问题，如文本、声音、图形图像的表示，即确定数据传输时的数据结构。

- 会话层

  - 不同机器上的用户之间建立及管理会话，会话层不参与具体的数据传输，是在发送方和接收方之间进行通信时**创建**、**维持**、之后**终止**或**断开连接**的地方。

> 理解：定义应用层协议来确定应用进程间的通信和交互规则，用以完成特定的网络应用。

#### 运输层

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

接受上一层的数据，在必要的时候吧数据进行分割，并将这些数据交给网络层，并保证这些数据段有效到达对端。

运输层主要使用以下两种协议：

1. **传输控制协议TCP(Transmisson Control Protocol)** —— 提供面向连接的、可靠的数据传输服务，其数据传输的单位是**报文段（segment）**
2. **用户数据包协议UDP(User Datagram Protocol)** —— 提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是**用户数据报。**

**理解**：

> **运输层向面的应用层提供通信服务**，它属于面向通信的最高层，也是用户功能的最底层。
>
> **网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信**。
>
> 运输层要对收到的报文进行差错检测。（网络层IP数据报只对首部进行检测，而不检查数据内容）
>
> 运输层屏蔽下面的网络核心细节。

网络边缘的两台主机进行端对端通信时，只有主机的协议栈有运输层；而网络核心部分的路由器在转发分组时都只用到下三层功能。

> 逻辑通信：好像通信沿水平方向直接传送数据，但实际上并没有，而是按照各层间数据传输的。

#### 网络层

**网络层(network layer)负责为分组交换网上的不同主机提供通信服务。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。

**在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。** 

**理解**：

> 研究问题：多个网络相互连接，分组（数据报）怎样通过路由器，从一个网络转发到另一个网络上。
>
> 网络层选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。
>
> 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。但是并不提供服务质量的承诺。

#### 数据链路层

**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装程帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

理解：

> 研究问题：同一个局域网中，在不经过路由器的情况下，分组怎样从一台主机传送到另一台主机。
>
> 数据链路层把网络层传下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出交给网络层。

> 封装成帧：将网络层的IP数据报前后添加首部（SOH）和尾部（EOT），组装成帧。
>
> 作用：确定帧定界（确定帧的界限）。采用特殊的帧定界符。



> 透明传输：不管从键盘上输入什么字符都可以放在帧中传输。
>
> 使用非ASCII的二级制代码，如果恰好和SOH和EOT重复，会造成找到错误的帧边界。
>
> 添加转义字符ESC

> 差错检测：

> 差错检测：
>
> 可能差生比特差错，广泛采用循环冗余校验CRC。

#### 物理层

在物理层上所传送的数据单位是比特。**物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。** 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

机械、电子、定时接口通信信道上的原始比特流的传输。

理解：

> 传输数据比特流，尽可能屏蔽传输媒体和通信手段的差异，使上层的数据链路层只考虑本层的协议和服务，而不必考虑那些差异。



总结：

![OSI七层模型](https://gitee.com/koala010/typora/raw/master/img/20210806103610.gif)



![img](https://gitee.com/koala010/typora/raw/master/img/20210804084725.png)



![img](https://gitee.com/koala010/typora/raw/master/img/20210804084459.png)



## 6. 常用端口和对应服务

| 端口 | 服务                           |
| ---- | ------------------------------ |
| 21   | FTP（文件传输协议）            |
| 22   | SSH                            |
| 23   | Telnet（远程登录）服务         |
| 25   | SMTP（简单邮件传输协议）       |
| 53   | DNS域名服务器                  |
| 80   | HTTP超文本传输协议             |
| 110  | POP3邮件协议3                  |
| 443  | HTTPS                          |
| 1080 | Sockets                        |
| 1521 | Oracle数据库默认端口           |
| 3306 | MySQL服务                      |
| 4000 | QQ客户端（服务端使用8000端口） |
| 8080 | Tomcat服务                     |

### 端口划分

服务端使用的端口号（需在IANA按规定登记，可在 www.iana.org 查询）：

- 系统端口号（熟知端口号）：0~1023
- 登记端口号：1021~49151

客户端使用端口号：19152~65535 （客户端进程运行时暂时选择使用）

## 7. 有哪些私有（保留）地址？

> 私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。

**私有地址（内部局域网可以使用的）**

A级：10.0.0.0 - 10.255.255.255

B级：172.16.0.0 - 172.31.255.255

C级：192.168.0.0 - 192.168.255.255

**保留地址（特殊用途的）**

A类：127.X.X.X

B类：169.254.X.X

***联通运营商就是使用的10.开头的保留地址, 局域网组网，然后用户通过拨号的方式进入局域网，然后再通过访问网关访问Internet，这样做最大的好处就是节约了公网IP地址，极大的降低了成本。***

## 8. IP地址分为哪几类？简单说一下各个分类

![IP地址分类](https://cos.duktig.cn/typora/202108271554266.png)

IPv6 -- 采用128bit，首部固定部分为40字节。

## 9. 在浏览器中输入网址之后执行会发生什么？

图解（图片来源：《图解 HTTP》）：

![ 在浏览器中输入网址之后执行过程](https://cos.duktig.cn/typora/202109171405230.jpeg)

上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议,是由 Internet 工程任务组开发的路由选择协议

1、先查找强缓存，命中直接使用，没有命中往下进行
2、没有命中强缓存，浏览器发送请求，并根据请求头里边的参数判断是否命中协商缓存，命中直接使用，没有命中往下进行
3、没有拿到缓存则进行DNS域名解析
4、建立tcp连接，三次握手
5、发送http请求
6、服务器处理http请求，并返回http报文
7、浏览器解析和渲染页面
8、连接结束，四次挥手
参看：

- [输入url之后发生的事情（完整汇总）](https://blog.csdn.net/weixin_42880088/article/details/117654325)
- [从输入URL开始建立前端知识体系](https://juejin.cn/post/6935232082482298911#heading-27)
- [前端经典面试题: 从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)



## 10. DNS域名解析过程

![DNS域名解析过程](https://cos.duktig.cn/typora/202108271639160.webp)



DNS 客户端进行域名的解析过程如下：

1. **DNS 客户端**向本地域名服务器发送请求，查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机的 IP 地址；

2. **本地域名服务器**查询数据库，发现没有域名为 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 的主机，于是将请求发送给根域名服务器；

3. **根域名服务器**查询数据库，发现没有这个主机域名记录，但是根域名服务器知道 cn 域名服务器可以解析这个域名，于是将 cn 域名服务器的 IP 地址返回给本地域名服务器；

4. **本地域名服务器**向 cn 域名服务器查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机的 IP 地址；

5. **cn 域名服务器**查询数据库，也没有相关记录，但是知道 [http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn) 域名服务器可以解析这个域名，于是将 [http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn) 域名服务器的 IP 地址返回给本地域名服务器；

6. **本地域名服务器**再向 [http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn) 域名服务器查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机 IP 地址；

7. **[http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn)** **域名服务器**查询数据库，也没有相关记录，但是知道 [http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn) 域名服务器可以解析这个域名，于是将 [http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn) 的域名服务器 IP 地址返回给本地域名服务器；

8. **本地域名服务器**向 [http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn) 域名服务器查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机的 IP 地址；

9. **[http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn)** **域名服务器**查询数据库，发现有主机域名记录，于是给本地域名服务器返回 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 对应的 IP 地址；

10. 最后**本地域名服务器**将 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 的 IP 地址返回给客户端，整个解析过程完成。


参看：

- [面试官:讲讲DNS的原理？](https://zhuanlan.zhihu.com/p/79350395)
- [DNS解析的过程是什么，求详细的？](https://www.zhihu.com/question/23042131)



## 参考：

- 完整HTTP状态码参看：[HTTP状态码（百度百科）](https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin)    [HTTP状态码（菜鸟教程）](https://www.runoob.com/http/http-status-codes.html)
- [《HTTP 长连接、短连接究竟是什么？》](https://www.cnblogs.com/gotodsp/p/6366163.html)
- [彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231) (演变过程和每个步骤的漏洞及解决方案讲的比较清楚)
- [谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)     [一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)  （以故事的方式讲解，更加容易理解）
- [面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)
- [TCP和UDP的最完整的区别](https://www.cnblogs.com/williamjie/p/9390164.html)
- [TCP和UDP的区别](https://blog.csdn.net/zhang6223284/article/details/81414149)
- [输入url之后发生的事情（完整汇总）](https://blog.csdn.net/weixin_42880088/article/details/117654325)
- [从输入URL开始建立前端知识体系](https://juejin.cn/post/6935232082482298911#heading-27)
- [前端经典面试题: 从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)
- [面试官:讲讲DNS的原理？](https://zhuanlan.zhihu.com/p/79350395)
- [DNS解析的过程是什么，求详细的？](https://www.zhihu.com/question/23042131)

