# 网络常见面试题

## 1.HTTP

### 1.1 HTTP状态码

状态码分类：

| 分类 | 描述                                               |
| ---- | -------------------------------------------------- |
| 1**  | **信息**，服务器收到请求，需要请求者继续执行操作   |
| 2**  | **成功**，操作被成功接收并处理                     |
| 3**  | **重定向**，需要进一步的操作以完成请求             |
| 4**  | **请求错误**，请求包含语法错误或无法完成请求       |
| 5**  | **服务器错误**，服务器在处理请求的过程中发生了错误 |

常见状态码：

| 状态码 | 状态码英文名称                | 描述                                                         |
| ------ | ----------------------------- | ------------------------------------------------------------ |
| 100    | Continue                      | 客户端应当继续发送请求                                       |
| 101    | Switching Protocols           | 切换协议（只能切换到更高级的协议，例如，切换到HTTP的新版本协议）。 |
| 200    | OK                            | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                       | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                      | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information | 非授权信息。请求成功。但返回的实体头部元信息不在原始的服务器，而是一个副本（来自本地或者第三方的拷贝） |
| 204    | No Content                    | 无内容。服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。在未更新网页的情况下，可确保浏览器继续显示当前文档。 |
| 205    | Reset Content                 | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content               | 部分内容。服务器成功处理了部分GET请求                        |
| 300    | Multiple Choices              | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently             | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                         | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                     | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                  | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                     | 使用代理。所请求的资源必须通过代理访问                       |
| 400    | Bad Request                   | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                  | 请求要求用户的身份认证（没有权限）                           |
| 402    | Payment Required              | 保留，将来使用                                               |
| 403    | Forbidden                     | 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不足）   |
| 404    | Not Found                     | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed            | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                | 服务器无法根据客户端请求的内容特性完成请求                   |
| 408    | Request Time-out              | 服务器等待客户端发送的请求时间过长，超时                     |
| 500    | Internal Server Error         | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented               | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                   | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable           | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out              | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported    | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

高频：200、201、202、301、302、400、401、402、403、404、405、408、500、502、503、504

完整HTTP状态码参看：[HTTP状态码（百度百科）](https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin)    [HTTP状态码（菜鸟教程）](https://www.runoob.com/http/http-status-codes.html)

### 1.2 HTTP包含哪些请求？

- GET：对服务器资源的简单请求
- POST：用于发送包含用户提交数据的请求

------------以及------------

- HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头
- PUT：传说中请求文档的一个版本
- DELETE：发出一个删除指定文档的请求
- TRACE：发送一个请求副本，以跟踪其处理进程
- OPTIONS：返回所有可用的方法，检查服务器支持哪些方法
- CONNECT：用于ssl隧道的基于代理的请求



## 2. https

### 2.1 https加密过程

1. 服务器的**公钥**和**身份信息**（原始信息）用一个**hash算法**生成一个**消息摘要**。
2. 使用CA机构的私钥将消息摘要加密生成**数字签名**。
3. 将原始信息和数字签名合并，形成**数字证书**，发送至客户端。
4. 客户端将原始信息用同样的hash算法再次生成消息摘要。
5. 客户端用CA机构的公钥将数字签名解密，得到CA的消息摘要。
6. 客户端将**原始信息hash后的消息摘要**与**CA解密后的消息摘要**进行对比，如果相同证明无问题。
7. 随后进行非对称+对称加密解密通信（参看下文https通信流程）

![https加密流程](https://gitee.com/koala010/typora/raw/master/img/20210624091448.png)



![https客户端解密](https://gitee.com/koala010/typora/raw/master/img/20210624091518.png)

### 2.2 https通信流程

1. 客户端发送请求。
2. 服务器发送数字证书（包含公钥）
3. 客户端用预置的CA列表验证证书（有问题，提示风险）
4. 浏览器随机生成对称密钥，并使用服务器的公钥加密
5. 服务器使用私钥进行解密，得到对称密钥
6. 双方使用对称加密进行通信

![https流程](https://gitee.com/koala010/typora/raw/master/img/20210624091840.png)



参考：

- [彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231) (演变过程和每个步骤的漏洞及解决方案讲的比较清楚)
- [谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)     [一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)  （以故事的方式讲解，更加容易理解）

## 3. TCP三次握手、四次挥手

参看：[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

### 3.1 三次握手过程

> 三次握手（Three-way Handshake）是建立TCP连接时，客户端和服务端总共发送3个包，确认双方的接受能力和发送能力是否正常，指定初始化序列号，为后面的可靠传输做准备。实质是连接服务器指定端口，建立TCP连接，同步双方的序列号和确认号，交换TCP的窗口大小信息。

![三次握手过程](https://gitee.com/koala010/typora/raw/master/img/三次握手过程20210624165041.png)

名词解释：

**SYN**：同步序列编号，是TCP/IP建立连接时使用的握手信号。表示建立连接。

**seq**：TCP报文段中第一个字节的数据编号，由本地随机生成。

**ACK**：报文段首部“ACK”字段，为1时表示发来的数据已确认接收无误。当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

**ack**：TCP报文段首部中“**确认号字段**”的具体数值，“`ack=x+1`”表示服务器希望客户端下次发送数据的字节序号为`x+1`



刚开始客户端处于**CLOSED状态**，服务端处于**LISTEN状态**。

第一次握手：

客户端给服务端发送一个SYN报文，并指明客户端的初始化序列号ISN（seq的值，假设为x）。此时客户端的状态为**CLOSED->SYN_SEND**。

发送给服务器的数据为：`SYN=1`，`seq=x`。SYN=1的报文段不能携带数据，而且需要消耗一个序号。

第二次握手：

服务器接收到客户端的SYN报文后，用自己的SYN作为应答，并且指定了服务端的初始化序列号ISN（seq的值，假设为y）。并且将ACK的值设置为客户端ISN+1（即客户端的seq+1），标识已经收到客户端的SYN报文。此时服务器的状态为**LISTEN->SYN_RCVD**。

发送给客户端的数据为：`SYN=1`，`ACK=1`，初始序号`seq=y`，确认号`ack=x+1`。

第三次握手：

客户端收到SYN报文后，应答一个ACK报文，将服务器的ISN+1（seq+1）作为ACK的值，表示收到服务器的SYN报文。此时客户端的状态为**SYN_SENT->ESTABLISHED**，服务器的状态为**SYN_RCVD->ESTABLISHED**。

发送服务端数据为：`ACK=1`，初始序号`seq=x+1`，确认号`ack=y+1`。



发送第一个SYN报文的一端执行**主动打开（active open）**，接收这个SYN并回发SYN的一端执行**被动打开（passive open）**。

### 3.2 为什么要三次握手，两次不行吗？

**第一次握手**：客户端发送网络包，服务端确认接收。服务端就能得出结论：客户端发送能力和服务端接收能力正常。

**第二次握手**：服务端发送网络包，客户端确认接收。客户端就能得出结论：服务端的发送、接收能力和客户端的发送能力正常。**但服务端并不能确定客户端的接收能力正常。**

**第三次握手**：客户端发送网络包，服务端确认接收。服务端可以得出：客户端服务端发送、接收能力都正常。三次发送才能保证。

**如果是两次握手可能出现的情况**：

如果客户端发送一个连接请求，但因为报文丢失没有收到确认，于是客户端又发送了第二个连接请求，服务端确认连接，发送完数据后，释放了当前的连接。但是客户端发送的第一个连接请求，可能因为是在某些网络节点长时间滞留，延误到释放第二个连接后才到达服务端，此时服务端认为这是一个新的连接请求，回复确认并建立连接，但是客户端忽略此确认，一直未向服务端发送数据，导致服务端一直等待客户端发送数据，浪费资源。

### 3.3 什么是半连接队列？

> 服务器第一次收到SYN后，处于SYN_RVCD状态，双方还未正式建立连接，此时服务器会将此种状态下的连接放在一个队列里，成为“半连接队列”。

当然，建立完三次握手的连接会放在**全连接队列**里。如果队列满，可能会出现丢包现象。

**SYN-ACK 重传次数的问题**：

服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

### 3.4 ISN(Initial Sequence Number)是固定的吗？

建立连接时发送SYN是，需要为连接选择初始序列号ISN。ISN可以看做一个32位的计数器，每4ms加1，随时间变化，每个连接具有不同的ISN。

目的是为了防止网络中被延迟的分组在以后被再次传送，而导致连接的另一方对它做出错误的解释。

三次握手中客户端和服务端要交换ISN，以便让对方知道接下来接收数据按照何种序列号组装数据。如果ISN是固定的，攻击者和容易猜出后续的确认号。

### 3.5 三次握手的过程中可以携带数据吗？

第一次和第二次不可以携带数据，第三次可以携带数据。

如果第一次握手客户端携带数据，如果有恶意攻击者攻击服务器，每次都携带了大量的数据，疯狂发送，而且不理会服务器的接收、发送能力，那么服务器需要花费很多时间和空间接受这些报文。浪费时间，可能还会导致服务器崩溃。第二次同理。

第三次，客户端已经处于ESTABLISHED状态，而且已知服务端的发送接收能力正常，所以可以携带数据。

### 3.6 什么是SYN攻击？

服务端资源在第二次握手时分配，客户端资源在第三次握手时分配。服务器容易受到SYN洪泛攻击，即客户端在短时间内伪造大量不存在的IP地址，并向服务端不断发SYN包，服务端需要回复确认并等待客户端的回复。由于源地址IP不存在，服务端不断重发直至超时，这些伪造的SYN包长时间占用未连接队列，导致正常的SYN队列满而被丢弃，从而引发网络堵塞甚至系统瘫痪。

SYN是一种典型的DoS/DDoS攻击。

检测：服务器大量存在半连接状态，特别是源地址IP是随机的，基本可以判断为SYN攻击。

在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```java
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

### 3.7 四次挥手过程

![四次挥手流程图](https://gitee.com/koala010/typora/raw/master/img/四次挥手流程图20210624203352.jpg)

名词解释：

**FIN**：代表关闭连接。

> 建立连接需要三次握手，而终止连接需要四次握手，这是由于TCP的半关闭（half-close）造成的。
>
> 半关闭：TCP提供了在结束发送后还能接收来自另一端数据的能力。

刚开始客户端和服务端都处于ESTABLISHED状态。

以下过程，假设由客户端先发起关闭请求

第一次挥手：

客户端发送FIN报文，并携带生成的序列号，停止再发送数据，主动关闭TCP连接，等待后端确认。此时客户端的状态为**ESTABLISHED->FIN_WAIT1**。

发送到服务端的数据：`FIN=1`，`seq=u`。

第二次挥手：

服务端收到FIN后，发送ACK报文，并将ACK值设置为客户端序列值+1，表明已经收到客户端的报文。此时TCP处于半关闭状态，客户端客户端到服务端的连接被释放（服务端还可以向客户端发送数据），客户端等待服务端发出的连接释放报文段。此时服务端的状态为**ESTABLISHED->CLOSE_WAIT**。

客户端收到服务端的确认后，状态为**FIN_WAIT1->FIN_WAIT2**。

发送到客户端的数据：`ACK=1`，`seq=v`，`ack=u+1`。

第三次挥手：

如果服务器也想断开连接，同客户端一样发送FIN报文，等待客户端确认。此时服务端的状态为**CLOSE_WAIT->LAST_ACK**。

发送到客户端的数据：`FIN=1`,`ACK=1`，`seq=w`，`ack=u+1`。

第四次挥手：

客户端收到FIN报文后，发送ACK报文作为应答，并携带ACK报文序列号的值（服务端seq+1）。客户端的状态为**FIN_WAIT2->TIME_WAIT**。等待2MSL后，客户端的状态为**TIME_WAIT->CLOSED**。

发送到服务端的数据：`ACK=1`，`seq=u+1`，`ack=w+1`。

服务端收到ACK报文后，状态为**LAST_ACK->CLOSED**。

如果服务端收不到ACK报文，那么服务端超时重传FIN-ACK报文，客户端重新确认，重启时间等待计时器，直至最后客户端和服务端都变为CLOSED状态。

### 3.8 挥手为什么要四次？

挥手操作需要四次，是因为**TCP提供了在一段结束发送后还能接收来自另一端数据的能力**。

握手时，SYN报文用来同步，客户端可以发送SYN报文给服务端，服务端收到后可以直接发送SYN+ACK报文来应答。但是挥手时需要考虑到服务端并不会立即关闭SOCKET，可能还需要向客户端发送数据，所以只是先回复一个ACK报文，告诉客户端“你的FIN报文我收到了”。等到数据全部发完，服务端再发送FIN报文。故需要四次挥手。

### 3.9 为什么要有2MSL等待状态？

> MSL（Maximum Segment Lifetime）可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

> TIME_WAIT状态也成为2MSL等待状态，每个具体TCP实现必须选择一个报文段最大生存时间MSL，这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

两个理由：

- **保证客户端发送的最后一个ACK报文段能够到达服务端**。
  - 第四次挥手的ACK报文可能丢失，服务端则可能不会改变为CLOSED状态。所以需要服务端超时重新发送FIN+ACK报文，客户端重新确认，重启时间等待计时器，重新发送ACK报文，保证客户端和服务端都能进入到CLOSED状态。
- **防止“已失效的连接请求报文段”出现在本连接中**。

### 3.10 三次握手和四次挥手状态变迁总结

![三次握手和四次挥手状态变迁总结](https://gitee.com/koala010/typora/raw/master/img/三次握手和四次挥手状态变迁总结.jpg)



## 4. TCP和UDP的区别

参考：

- [TCP和UDP的最完整的区别](https://www.cnblogs.com/williamjie/p/9390164.html)
- [TCP和UDP的区别](https://blog.csdn.net/zhang6223284/article/details/81414149)

|                                                      | TCP                      | UDP                                |
| :--------------------------------------------------- | ------------------------ | ---------------------------------- |
| 是否需要建立连接                                     | 是                       | 否                                 |
| 结构                                                 | 较复杂                   | 简单                               |
| 是否可靠（数据完整性）                               | 可靠                     | 不可靠                             |
| 流量控制（发送方不会发送过快而超过接收方的处理能力） | 支持                     | 不支持                             |
| 时间/延迟保障                                        | 不支持                   | 不支持                             |
| 最小带宽保障                                         | 不支持                   | 不支持                             |
| 数据发送顺序                                         | 保障                     | 不保障                             |
| 发送方式                                             | 字节流                   | 数据报                             |
| 传输速度                                             | 较慢                     | 较快                               |
| 对系统资源要求                                       | 较高                     | 较低                               |
| 适用场景                                             | 保证数据完整性、少量数据 | 可容忍一定的数据丢包、传输大量数据 |

总结：

- TCP面向连接，UDP是无连接的
- TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付
- UDP的传输速度大于TCP
- TCP面向字节流，实际上TCP是把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机发送速率降低（对实时应用很有用）
- TCP只能是点到点的；UDP支持一对一，一对多，多对多的交互通信
- TCP首部开销20个字节；UDP首部开销小，只有8字节
- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
- TCP适合需要保证数据完整性且数据量小的场景；UDP适合可容忍一定的数据丢包、传输大量数据，对数据实时性要求高的场景

### UDP

![UDP报头](https://gitee.com/koala010/typora/raw/master/img/UDP20210624221808.png)

UDP 除了端口号，基本啥都没有了。

**适用场景**：

- 网络情况稳定的内网或者可以在一定程度上容忍丢包的应用。
- 不需要一对一建立连接，可以广播应用。
- 需要处理速度够快，即使网络拥塞。

**例子**：

- 直播。实时性要求高，可以丢包，但不能卡顿。
- 实时游戏。实时性高，需要极大程度上降低延迟，减少网络问题对游戏的影响。
- 物联网。中断资源少，很可能是一个很小的嵌入式系统，维护TCP代价太大，而且对实时性要求比较高。

### TCP

![TCP报头](https://gitee.com/koala010/typora/raw/master/img/TCP20210624222442.png)

**报头的作用**：

- 源端口和目标端口必不可少。
- 包的序号。主要是为了解决乱序问题。TCP传输是有序的。
- 确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题。
- 状态位。SYN 是发起一个请求连接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更。
- 窗口大小。TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。

## 5.OSI与TCP/IP以及五层模型



### OSI与TCP/IP以及五层模型各层的结构与功能，都有哪些协议

| OSI体系结构（7层） | TCP/IP（4层）         | 五层体系结构（5层） |
| ------------------ | --------------------- | ------------------- |
| 7. 应用层          | 4. 应用层（HTTP）     | 5. 应用层           |
| 6. 表示层          |                       |                     |
| 5. 会话层          |                       |                     |
| 4. 传输层          | 3. 运输层（TCP、UDP） | 4. 运输层           |
| 3. 网络层          | 2. 网际层（IP）       | 3. 网络层           |
| 2. 数据链路层      | 1. 网络接口层         | 2.数据链路层        |
| 1. 物理层          |                       | 1. 物理层           |

低三层为通信子网，负责数据传输；高三层为资源子网，相当于计算机系统，完成数据处理； 传输层承上启下



### 5.1 体系结构

![OSI七层模型](https://gitee.com/koala010/typora/raw/master/img/20210806103610.gif)



![img](https://gitee.com/koala010/typora/raw/master/img/20210804084725.png)



![img](https://gitee.com/koala010/typora/raw/master/img/20210804084459.png)



#### 应用层

应用层是体系结构中的最高层。应用层的任务是**通过应用进程间的交互来完成特定的网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**等等。我们把应用层交互的数据单元称为报文。

- 应用层

- - 应用层定义的是应用程序用于请求网络服务的**接口**，而不是指应用程序本身。应用层主要定义了应用程序能够从网络上请求使用哪种类型的服务，并且规定了在从应用程序接收消息或向应用程序发送消息时，数据所必须采用的**格式**。各种应用程序协议，如http、FTP、SMTP、POP3

- 表示层

- - 信息的语法语义以及他们的关联，如加密解密、转换翻译、压缩解压缩，解决数据的语法表示问题，如文本、声音、图形图像的表示，即确定数据传输时的数据结构。

- 会话层

- - 不同机器上的用户之间建立及管理会话，会话层不参与具体的数据传输，是在发送方和接收方之间进行通信时**创建**、**维持**、之后**终止**或**断开连接**的地方。

> 理解：定义应用层协议来确定应用进程间的通信和交互规则，用以完成特定的网络应用。

#### 运输层

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

接受上一层的数据，在必要的时候吧数据进行分割，并将这些数据交给网络层，并保证这些数据段有效到达对端。

运输层主要使用以下两种协议：

1. **传输控制协议TCP(Transmisson Control Protocol)** —— 提供面向连接的、可靠的数据传输服务，其数据传输的单位是**报文段（segment）**
2. **用户数据包协议UDP(User Datagram Protocol)** —— 提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是**用户数据报。**

**理解**：

> **运输层向面的应用层提供通信服务**，它属于面向通信的最高层，也是用户功能的最底层。
>
> **网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信**。
>
> 运输层要对收到的报文进行差错检测。（网络层IP数据报只对首部进行检测，而不检查数据内容）
>
> 运输层屏蔽下面的网络核心细节。

网络边缘的两台主机进行端对端通信时，只有主机的协议栈有运输层；而网络核心部分的路由器在转发分组时都只用到下三层功能。

> 逻辑通信：好像通信沿水平方向直接传送数据，但实际上并没有，而是按照各层间数据传输的。

#### 网络层

**网络层(network layer)负责为分组交换网上的不同主机提供通信服务。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。

**理解**：

> 研究问题：多个网络相互连接，分组（数据报）怎样通过路由器，从一个网络转发到另一个网络上。
>
> 网络层选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。
>
> 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。但是并不提供服务质量的承诺。

#### 数据链路层

**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装程帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

理解：

> 研究问题：同一个局域网中，在不经过路由器的情况下，分组怎样从一台主机传送到另一台主机。
>
> 数据链路层把网络层传下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出交给网络层。

> 封装成帧：将网络层的IP数据报前后添加首部（SOH）和尾部（EOT），组装成帧。
>
> 作用：确定帧定界（确定帧的界限）。采用特殊的帧定界符。



> 透明传输：不管从键盘上输入什么字符都可以放在帧中传输。
>
> 使用非ASCII的二级制代码，如果恰好和SOH和EOT重复，会造成找到错误的帧边界。
>
> 添加转义字符ESC

> 差错检测：

> 差错检测：
>
> 可能差生比特差错，广泛采用循环冗余校验CRC。

#### 物理层

在物理层上所传送的数据单位是比特。**物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。** 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

机械、电子、定时接口通信信道上的原始比特流的传输。

理解：

> 传输数据比特流，尽可能屏蔽传输媒体和通信手段的差异，使上层的数据链路层只考虑本层的协议和服务，而不必考虑那些差异。



## 6. 常用端口和对应服务

| 端口 | 服务                           |
| ---- | ------------------------------ |
| 21   | FTP（文件传输协议）            |
| 22   | SSH                            |
| 23   | Telnet（远程登录）服务         |
| 25   | SMTP（简单邮件传输协议）       |
| 53   | DNS域名服务器                  |
| 80   | HTTP超文本传输协议             |
| 110  | POP3邮件协议3                  |
| 443  | HTTPS                          |
| 1080 | Sockets                        |
| 1521 | Oracle数据库默认端口           |
| 3306 | MySQL服务                      |
| 4000 | QQ客户端（服务端使用8000端口） |
| 8080 | Tomcat服务                     |

### 端口划分

服务端使用的端口号（需在IANA按规定登记，可在 www.iana.org 查询）：

- 系统端口号（熟知端口号）：0~1023
- 登记端口号：1021~49151

客户端使用端口号：19152~65535 （客户端进程运行时暂时选择使用）

## 7. 有哪些私有（保留）地址？

> 私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。

**私有地址（内部局域网可以使用的）**

A级：10.0.0.0 - 10.255.255.255

B级：172.16.0.0 - 172.31.255.255

C级：192.168.0.0 - 192.168.255.255

**保留地址（特殊用途的）**

A类：127.X.X.X

B类：169.254.X.X

***联通运营商就是使用的10.开头的保留地址, 局域网组网，然后用户通过拨号的方式进入局域网，然后再通过访问网关访问Internet，这样做最大的好处就是节约了公网IP地址，极大的降低了成本。***

## 8. IP地址分为哪几类？简单说一下各个分类

![IP地址分类](https://cos.duktig.cn/typora/202108271554266.png)

IPv6 -- 采用128bit，首部固定部分为40字节。

## 9. 在浏览器中输入网址之后执行会发生什么？

1、先查找强缓存，命中直接使用，没有命中往下进行
2、没有命中强缓存，浏览器发送请求，并根据请求头里边的参数判断是否命中协商缓存，命中直接使用，没有命中往下进行
3、没有拿到缓存则进行DNS域名解析
4、建立tcp连接，三次握手
5、发送http请求
6、服务器处理http请求，并返回http报文
7、浏览器解析和渲染页面
8、连接结束，四次挥手
参看：[输入url之后发生的事情（完整汇总）](https://blog.csdn.net/weixin_42880088/article/details/117654325)

## 10. DNS域名解析过程

![DNS域名解析过程](https://cos.duktig.cn/typora/202108271639160.webp)



DNS 客户端进行域名的解析过程如下：

1. **DNS 客户端**向本地域名服务器发送请求，查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机的 IP 地址；

2. **本地域名服务器**查询数据库，发现没有域名为 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 的主机，于是将请求发送给根域名服务器；

3. **根域名服务器**查询数据库，发现没有这个主机域名记录，但是根域名服务器知道 cn 域名服务器可以解析这个域名，于是将 cn 域名服务器的 IP 地址返回给本地域名服务器；

4. **本地域名服务器**向 cn 域名服务器查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机的 IP 地址；

5. **cn 域名服务器**查询数据库，也没有相关记录，但是知道 [http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn) 域名服务器可以解析这个域名，于是将 [http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn) 域名服务器的 IP 地址返回给本地域名服务器；

6. **本地域名服务器**再向 [http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn) 域名服务器查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机 IP 地址；

7. **[http://edu.cn](https://link.zhihu.com/?target=http%3A//edu.cn)** **域名服务器**查询数据库，也没有相关记录，但是知道 [http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn) 域名服务器可以解析这个域名，于是将 [http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn) 的域名服务器 IP 地址返回给本地域名服务器；

8. **本地域名服务器**向 [http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn) 域名服务器查询 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 主机的 IP 地址；

9. **[http://tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//tsinghua.edu.cn)** **域名服务器**查询数据库，发现有主机域名记录，于是给本地域名服务器返回 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 对应的 IP 地址；

10. 最后**本地域名服务器**将 [http://www.tsinghua.edu.cn](https://link.zhihu.com/?target=http%3A//www.tsinghua.edu.cn) 的 IP 地址返回给客户端，整个解析过程完成。

    

参看：

- [面试官:讲讲DNS的原理？](https://zhuanlan.zhihu.com/p/79350395)
- [DNS解析的过程是什么，求详细的？](https://www.zhihu.com/question/23042131)



