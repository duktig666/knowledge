# 操作系统面经面试题

## 1. 虚拟内存实现原理

> **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。

### 局部性原理

> 早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。

- 时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
- 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

### 实现方式

请求分页存储管理、请求分段存储管理、请求段页式存储管理三种方式。

1. 一定容量的内存和外存：在载入程序的时，将程序的一部分装入内存，而将其他部分留在外存；（计算机好像提供了一个比实际大内存大的存储器——虚拟存储器）
2. **缺页/段中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**（可将暂时不用的页面置换到外存），然后继续执行程序；
3. **虚拟地址空间** ：逻辑地址到物理地址的变换。

参看：[虚拟内存的那点事儿](https://juejin.cn/post/6844903507594575886) 

### 页面置换算法

- **OPT 页面置换算法（最佳页面置换算法）**：淘汰页为之后永久不使用或者最长时间不使用，可保证最低的缺页率。（无法预测淘汰也，几乎无法实现，一般作为衡量其他算法）
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）**：总是淘汰最先进入内存的页面（即内存中驻留最久的页面）。
- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）**：每个页面有一个访问字段，记录上次访问以来经历的时间T，淘汰T最长的（最久未使用）。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）**：淘汰使用最少的页面。

## 2. 交换和覆盖的区别

解决**程序大小超过物理内存总和**的问题

覆盖：

程序分段，常用的在“**固定区**”，调入后不在调出（除非运行结束），不常用的放在“**覆盖区**”，需要时调入内存，不需要时调出。

缺点：覆盖技术对用户不透明，所有操作由程序员声明，大大增加编程难度。

交换：

内存紧张时，将某些内存暂时换出内存（挂起），将外存已具备运行条件的进程换入内存。

主要区别：

**覆盖是在同一个程序或者进程中进行的，交换是在不同进程之间进行的。**

参考：

- https://blog.csdn.net/github_36487770/article/details/54934919
- https://blog.csdn.net/qq_40608137/article/details/104840730



