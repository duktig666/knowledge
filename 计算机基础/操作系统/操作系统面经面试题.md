# 操作系统面经面试题

## 1. 虚拟内存实现原理

> **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。

### 局部性原理

> 早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。

- 时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。（**指令和数据，不久后可能再次被执行/访问**）
- 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。（**附近的存储空间可能被访问**）

### 实现方式

请求分页存储管理、请求分段存储管理、请求段页式存储管理三种方式。

1. 一定容量的内存和外存：在载入程序的时，将程序的一部分装入内存，而将其他部分留在外存；（计算机好像提供了一个比实际大内存大的存储器——虚拟存储器）
2. **缺页/段中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**（可将暂时不用的页面置换到外存），然后继续执行程序；
3. **虚拟地址空间** ：逻辑地址到物理地址的变换。

参看：[虚拟内存的那点事儿](https://juejin.cn/post/6844903507594575886) 

### 页面置换算法

- **OPT 页面置换算法（最佳页面置换算法）**：淘汰页为之后永久不使用或者最长时间不使用，可保证最低的缺页率。（无法预测淘汰也，几乎无法实现，一般作为衡量其他算法）
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）**：总是淘汰最先进入内存的页面（即内存中驻留最久的页面）。
- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）**：每个页面有一个访问字段，记录上次访问以来经历的时间T，淘汰T最长的（最久未使用）。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）**：淘汰使用最少的页面。

## 2. 交换和覆盖的区别

解决**程序大小超过物理内存总和**的问题

覆盖：

程序分段，常用的在“**固定区**”，调入后不在调出（除非运行结束），不常用的放在“**覆盖区**”，需要时调入内存，不需要时调出。

缺点：覆盖技术对用户不透明，所有操作由程序员声明，大大增加编程难度。

交换：

内存紧张时，将某些进程暂时换出内存（挂起），将外存已具备运行条件的进程换入内存。

主要区别：

**覆盖是在同一个程序或者进程中进行的，交换是在不同进程之间进行的。**

参考：

- https://blog.csdn.net/github_36487770/article/details/54934919
- https://blog.csdn.net/qq_40608137/article/details/104840730

## 3. 并行与并发

> 并行： 两个或多个事件在同一时刻发生。
>
> 多个CPU同时执行多个任务。比如：多个人同时做不同的事。
>
> CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。
>
> 单处理机宏观上利用时间片模拟出并行，微观上实际无法做到。
>
> 
>
> 并发： 两个或多个事件在同一时间间隔内发生。
>
> 一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。
>
> CPU多核，多个线程可以同时执行。 我们可以使用线程池！



## 4. 进程与线程

### 概念

> 进程是进程实体的运行过程，是系统能独立运行和资源分配的基本单位。
>
> 进程实体 = 程序段 + 相关数据段 + 进程控制块（PCB，创建/撤销进程的对象，保证进程并发独立运行）。

> 线程是程序调度和分派的基本的单位。

#### 为什么引入进程/线程？

引入进程，解决单处理机环境下程序并发执行的问题。

引入线程，为了减少程序在并发执行时付出的时空开销，提高程序并发程度，使OS有更好的性能。

### 状态切换

-  就绪：当进程已分配到必要的资源，只要获得处理机便可立即执行。 
-  运行：当进程已获得处理机，其程序正在处理机上执行。 
-  阻塞：正在执行过程中，由于等待某个事件发生而无法执行，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。

 执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时（如临界资源被其他进程所占有），便从执行状态变成阻塞状态。

**线程与进程的基本状态相同**

![image-20210805091405927](https://gitee.com/koala010/typora/raw/master/img/20210805091406.png)

为了满足PCB数据操作的完整性和灵活性，常引入创建和终止两种状态。

- 创建状态：
  - 申请空白的PCB，填写用于控制和管理进程的信息；
  - 为进程分配必须的资源
  - 进程转为就绪状态，插入到就绪队列
- 終止状态：
  - 首先等待操作系统进行善后处理。（终止状态不能执行，保存状态码和一些计时数据，待其他进程收集后，删除该进程）
  - 最后将PCB清零，将PCB空间返还给系统。

**什么情况下进入终止状态？**

- 进程达到自然结束点
- 出现无法克服的错误
- 被操作系统终止
- 被其他拥有终止权限的进程终止

![image-20210805091805684](https://gitee.com/koala010/typora/raw/master/img/20210805091805.png)

挂起状态的引入，操作时进程由活动变为静止。

**为什么引入挂起状态？**

- 终端用户的需要（出现问题暂停进程）
- 父进程请求（父进程希望挂起某个进程，考察和修改子进程，协调各个子进程）
- 负荷调节（负荷较重时，挂起某些进程）
- 操作系统需要（挂起某些进程，检查资源使用情况）

**状态**：

*激活原语Active，挂起原语Suspend*

活动就绪（Readya）：进程未被挂起的就绪状态，表示进程可接受调度。

静止就绪（Readys）：此状态不再被调度执行。

活动阻塞（Blockeda）：未被挂起的阻塞状态

静止阻塞（Blockeda）：在进程期待的事件出现后，转为静止就绪。

<img src="https://gitee.com/koala010/typora/raw/master/img/20210805092039.png" alt="image-20210805092039267" style="zoom:67%;" />

### 进程和线程的区别

- 调度单位：进程是操作系统资源分配的基本单位，线程是CPU调度和分派的基本单位。
- 拥有资源：进程是系统拥有资源的基本单位，线程并不拥有系统资源，仅有一点必不可少、保证独立运行的单位；线程共享进程的资源。
- 独立性：线程的独立性比进程的独立性低（线程共享进程资源）
- 系统开销：进程分配资源多，上下文切换代价高。
- 支持多处理机系统：传统进程同一时刻只能运行在一个处理机上；而引入多线程后的进程，多个线程可以分配到多个处理机，并发执行
- 并发性：多线程的并发性好于传统进程

## 5. 死锁

### 定义（说说你对死锁的理解？）

> 如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。

理解

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

<img src="https://gitee.com/koala010/typora/raw/master/img/image-20200814111731992.png" alt="image-20200814111731992" style="zoom:80%;" />

### 死锁必须具备以下四个条件

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可抢占条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

### 如何预防死锁？

预防死锁，破坏死锁产生的必要条件：

1. **破坏请求与保持条件** ：请求资源时，不能持有不可抢占资源。
   1. 一次性申请所有的资源（破坏“请求”条件）；只要有一种资源申请不到，该进程阻塞，在进程阻塞期间，其他已申请到的资源也不保持（破坏“保持”条件） 。
   2. 初期申请资源，便开始运行；运行中逐步释放分配的、且已用完毕的资源，然后再请求资源。
2. **破坏不可抢占条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

### 如何避免死锁？

在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。

#### 系统安全状态

> **安全状态**指的是系统能够按照某种进行推进顺序（P1、P2、P3.....Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。

#### 银行家算法

